<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="en" class="translated-ltr" style="height: 100%;"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <link rel="stylesheet" type="text/css" href="./Chapter 1 _ Real-Time GPU-Based Voxelizer_files/style.scss">
  <meta name="generator" content="Re:VIEW">
  <title>Real-Time GPU-Based Voxelizer</title>

			<style>
				img {
					max-width: 80vw;
					max-height: 80vh;
				}
			</style><style>
					.goog-te-banner-frame {
						display: none;
					}
				</style>
			<script>(function(){(function injection() {
  var pageLang = 'ja';
  var userLang = 'en';

  var uid = '1E07F158C6FA4460B352973E9693B329';
  var teId = 'TE_' + uid;
  var cbId = 'TECB_' + uid;

  function show() {
    window.setTimeout(function() {
      window[teId].showBanner(true);
    }, 10);
  }

  function newElem() {
    
  }

  if (window[teId]) {
    show();
  } else {
    if (!window.google || !google.translate ||
        !google.translate.TranslateElement) {
      if (!window[cbId]) {
        window[cbId] = function() {
          window[teId] = newElem();
          show();
        };
      }
      
    }
  }
})();})();</script><script src="https://translate.google.com/translate_a/element.js?cb=TECB_1E07F158C6FA4460B352973E9693B329&amp;client=tee&amp;hl=en"></script><script src="./Chapter 1 _ Real-Time GPU-Based Voxelizer_files/f.txt"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://translate.googleapis.com/translate_static/css/translateelement.css"><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/translate_static/js/element/main.js"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="./Chapter 1 _ Real-Time GPU-Based Voxelizer_files/translateelement.css"><script type="text/javascript" charset="UTF-8" src="./Chapter 1 _ Real-Time GPU-Based Voxelizer_files/main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script><script type="text/javascript" charset="UTF-8" src="./Chapter 1 _ Real-Time GPU-Based Voxelizer_files/element_main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://translate.googleapis.com/translate_static/css/translateelement.css"><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/translate_static/js/element/main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script></head>
		
<body style="position: relative; min-height: 100%; top: 40px;"><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div>
<h1><a id="h1"></a><span class="secno">第1章　</span>Real-Time GPU-Based Voxelizer</h1>

<h2><a id="h1-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Introduction</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this chapter, we will develop GPU Voxelizer, a program that uses GPU to make voxels of meshes in real time.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The sample in this chapter is </font><font style="vertical-align: inherit;">"RealTime GPUBasedVoxelizer" from </font></font><br><a href="https://github.com/IndieVisualLab/UnityGraphicsProgramming2" class="link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/IndieVisualLab/UnityGraphicsProgramming2</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, after confirming the voxelization procedure and the obtained results based on the implementation on the CPU, we will explain the implementation method on the GPU and introduce an example of effects that apply high-speed voxelization.</font></font></p>

<h3><a id="h1-1-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.1.1 What is a　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> voxel?</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A voxel represents a basic unit in a three-dimensional reciprocal lattice space. </font><font style="vertical-align: inherit;">It can be imagined as an increase in the dimension of the pixel (Pixel) used as the basic unit of the two-dimensional normal lattice space, and it is named Voxel in the sense of Pixel with Volume. </font><font style="vertical-align: inherit;">Voxels can express volume, and each voxel may have a data format that stores values ​​such as concentration, which may be used for visualization and analysis of medical and scientific data.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, in the game, Minecraft </font></font><a id="fnb-minecraft" href="https://freder.io/files/unity2/Nakamura.html#fn-minecraft" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is listed as using voxels.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It takes time to create a detailed model and stage, but if it is a voxel model, it can be created with relatively little effort, and even if it is free, there </font><font style="vertical-align: inherit;">are excellent editors such as </font><font style="vertical-align: inherit;">MagicaVoxel </font></font><a id="fnb-magicavoxel" href="https://freder.io/files/unity2/Nakamura.html#fn-magicavoxel" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 2,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and the model looks like a 3D pixel art. Can be created.</font></font></p>
<div class="footnote" epub:type="footnote" id="fn-minecraft"><p class="footnote">[*1] https://minecraft.net</p></div>
<div class="footnote" epub:type="footnote" id="fn-magicavoxel"><p class="footnote">[*2] http://ephtracy.github.io/</p></div>

<h2><a id="h1-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voxelization algorithm</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will explain the voxelization algorithm based on the implementation on the CPU. </font><font style="vertical-align: inherit;">The CPU implementation is described in CPUVoxelizer.cs.</font></font></p>

<h3><a id="h1-2-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rough flow of voxelization</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The general flow of voxelization is as follows.</font></font></p>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Set voxel resolution</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Set the range for voxelization</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generate 3D array data to store voxel data</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generate voxels located on the surface of the mesh</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fill the voxels located inside the mesh from the voxel data representing the surface of the mesh</font></font></li>
</ol>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voxelization in CPU is a static function of CPUVoxelizer class</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist">public class CPUVoxelizer<font></font>
{<font></font>
    public static void Voxelize (<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        Mesh mesh,</font></font></font></font><font></font>
        int resolution,<font></font>
        out List&lt;Vector3&gt; voxels,<font></font>
        out float unit,<font></font>
        bool surfaceOnly = false<font></font>
    ) {<font></font>
    ...<font></font>
    }<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    ...</font></font></font></font><font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Execute by calling. </font><font style="vertical-align: inherit;">If you specify the mesh and resolution you want to voxel in the argument and execute it, the voxel array voxels and the unit representing the size of one voxel are returned via the reference argument.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the following, I will explain what is done inside the Voxelize function along the general flow.</font></font></p>

<h3><a id="h1-2-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Set the voxel resolution</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To make voxels, first set the voxel resolution. </font><font style="vertical-align: inherit;">The finer the resolution, the smaller the cube will be built, so a detailed voxel model can be generated, but it requires more calculation time.</font></font></p>
<div id="id_Nakamura_2FVoxelResolution" class="image">
<img src="./Chapter 1 _ Real-Time GPU-Based Voxelizer_files/VoxelResolution.png" alt="Difference in voxel resolution">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.1: Differences in voxel resolution
</font></font></p>
</div>

<h3><a id="h1-2-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2.3</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Set the range for </font><span class="secno"><font style="vertical-align: inherit;">voxelization　</font></span></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Specifies the range to voxelize the target mesh model. </font><font style="vertical-align: inherit;">If you specify the BoundingBox (the smallest rectangular parallelepiped that fits all the vertices of the model) of the mesh model as the voxelization range, you can voxelize the entire mesh model.</font></font></p>
<div id="id_Nakamura_2FBoundingBox" class="image">
<img src="./Chapter 1 _ Real-Time GPU-Based Voxelizer_files/BoundingBox.png" alt="Bounding Box of mesh">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.2: Mesh BoundingBox
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It should be noted here that if the BoundingBox of the mesh model is used as it is as the voxelization range, problems will occur when voxelizing a mesh that has a surface that exactly overlaps the BoundingBox, such as a Cube mesh. ..</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As will be described in detail later, when voxels are created, the intersection of the triangles and voxels that make up the mesh is determined. However, if the triangles and voxel surfaces overlap exactly, the intersection may not be determined correctly.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, the range in which the BoundingBox of the mesh model is expanded by "half the length of the unit length that constitutes one voxel" is specified as the voxelization range.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPUVoxelizer.cs</font></font></font></font></font></font></p>
<pre class="emlist">mesh.RecalculateBounds();<font></font>
var bounds = mesh.bounds;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Calculate the unit lengths that make up one voxel from the specified resolution</font></font><font></font>
float maxLength = Mathf.Max(<font></font>
    bounds.size.x,<font></font>
    Mathf.Max(bounds.size.y, bounds.size.z)<font></font>
);<font></font>
unit = maxLength / resolution;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Half the unit length</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
var hunit = unit * 0.5f;</font></font></font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// "Half the length of the unit length that makes up one voxel" Expanded range</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Scope of voxels</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Minimum value of bounds to voxelize</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
var start = bounds.min - new Vector3 (unit, unit, unit);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Maximum value of bounds to voxelize</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
var end = bounds.max + new Vector3 (unit, unit, unit);</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Size of bounds to voxelize</font></font><font></font>
var size = end - start;<font></font>
</pre>
</div>

<h3><a id="h1-2-4"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2.4　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generate 3D array data to store voxel data</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The sample code provides a Voxel_t structure as a structure that represents voxels.</font></font></p>
<div class="emlist-code">
<p class="caption">Voxel.cs</p>
<pre class="emlist">[StructLayout(LayoutKind.Sequential)]<font></font>
public struct Voxel_t {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public Vector3 position; // Voxel position</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public uint fill; // Flag whether voxels should be filled</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public uint front; // Flag whether the triangle that intersects the voxel is the front when viewed from the determined direction</font></font><font></font>
    ...<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A three-dimensional array of this Voxel_t is generated, and voxel data is stored in it.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Determine the size of 3D voxel data based on the unit length of voxels and the range of voxelization</font></font><font></font>
var width = Mathf.CeilToInt(size.x / unit);<font></font>
var height = Mathf.CeilToInt(size.y / unit);<font></font>
var depth = Mathf.CeilToInt(size.z / unit);<font></font>
var volume = new Voxel_t[width, height, depth];<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, in order to refer to the position and size of each voxel in the subsequent processing, generate an AABB array that matches the 3D voxel data in advance.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist">var boxes = new Bounds[width, height, depth];<font></font>
var voxelUnitSize = Vector3.one * unit;<font></font>
for(int x = 0; x &lt; width; x++)<font></font>
{<font></font>
    for(int y = 0; y &lt; height; y++)<font></font>
    {<font></font>
        for(int z = 0; z &lt; depth; z++)<font></font>
        {<font></font>
            var p = new Vector3(x, y, z) * unit + start;<font></font>
            var aabb = new Bounds(p, voxelUnitSize);<font></font>
            boxes[x, y, z] = aabb;<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<div class="column">

<h3><a id="column-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AABB</font></font></font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AABB (Axis-Aligned Bounding Box) is a rectangular parallelepiped boundary figure whose sides are parallel to the XYZ axes in 3D space.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AABB is often used for collision detection, and in some cases it is used for collision detection between two meshes or for simple collision detection between a certain mesh and a light beam.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you want to make a strict collision detection for a mesh, you have to make a judgment for all the triangles that make up the mesh, but if you only use AABB including the mesh, you can calculate at high speed, which is convenient.</font></font></p>
<div id="id_Nakamura_2FAABB" class="image">
<img src="./Chapter 1 _ Real-Time GPU-Based Voxelizer_files/AABB.png" alt="Collision detection between AABBs of two polygonal objects">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.3: Collision detection between AABBs of two polygonal objects
</font></font></p>
</div>
</div>

<h3><a id="h1-2-5"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2.5　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generate voxels located on the surface of the mesh</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generate voxels located on the surface of the mesh as shown in the figure below.</font></font></p>
<div id="id_Nakamura_2FVoxelSurface2" class="image">
<img src="./Chapter 1 _ Real-Time GPU-Based Voxelizer_files/VoxelSurface2.png" alt="First, generate voxels located on the surface of the mesh, and then generate voxels based on it so as to fill the contents of the mesh.">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.4: First, generate voxels located on the surface of the mesh, and then generate voxels based on it so as to fill the contents of the mesh.
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To find the voxels located on the surface of the mesh, it is necessary to determine the intersection of each of the triangles that make up the mesh and the voxels.</font></font></p>

<h4><a id="h1-2-5-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crossing judgment of triangle and voxel (crossing judgment algorithm using SAT)</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SAT (Separating Axis Theorem) is used to determine the intersection of a triangle and a voxel. </font><font style="vertical-align: inherit;">The intersection determination algorithm using SAT is not limited to triangles and voxels, but can be used for general purposes as intersection determination between convex surfaces.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The SAT has proved that:</font></font></p>
<div class="column">

<h3><a id="column-2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A brief explanation of SAT (Separating Axis Theorem)</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you want a straight line with the entire object A on one side and the entire object B on the other, object A and object B will not intersect. </font><font style="vertical-align: inherit;">Such a straight line that separates two objects is called a separation straight line, and the separation line is always orthogonal to the separation axis.</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the SAT finds an axis (separation axis) where the projections of two convex surfaces do not overlap, it can be derived that the two convex surfaces do not intersect because there is a straight line that separates the two convex surfaces. </font><font style="vertical-align: inherit;">Conversely, if no separation axis is found, it can be determined that the two convex surfaces intersect. </font><font style="vertical-align: inherit;">(If the shape is concave, it may not intersect even if the separation axis is not found.)</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When a convex shape is projected onto an axis, the shadow of that shape appears as if it were projected onto a line that represents that axis. </font><font style="vertical-align: inherit;">This can be represented as a line segment on the axis and can be represented by the range interval [min, max].</font></font></p>
<div id="id_Nakamura_2FSAT1" class="image">
<img src="./Chapter 1 _ Real-Time GPU-Based Voxelizer_files/SAT1.png" alt="The convex shape is projected onto a certain axis, and the range of the convex shape projected on the axis (min, max).">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.5: Convex shape projected onto a certain axis and the range of the convex shape projected on the axis (min, max)
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As shown in the figure below, when there are two convex separation straight lines, the projection sections of the convex shape with respect to the separation axis orthogonal to the straight lines do not overlap.</font></font></p>
<div id="id_Nakamura_2FSAT2" class="image">
<img src="./Chapter 1 _ Real-Time GPU-Based Voxelizer_files/SAT2.png" alt="If there is a straight line that separates the two convex shapes, the projection sections on the axis orthogonal to the straight line do not overlap.">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.6: If there is a straight line that separates the two convex shapes, the projection sections on the axes orthogonal to the straight line do not overlap.
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, even with the same two convex surfaces, projections on other non-separable axes may overlap, as shown in the figure below.</font></font></p>
<div id="id_Nakamura_2FSAT3" class="image">
<img src="./Chapter 1 _ Real-Time GPU-Based Voxelizer_files/SAT3.png" alt="When projecting on an axis orthogonal to a straight line that does not separate the two convex shapes, the projections may overlap.">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.7: When projecting on an axis orthogonal to a straight line that does not separate the two convex shapes, the projections may overlap.
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For some shapes, the possible axes of separation are obvious, and to determine the intersection of two such shapes A and B, two for each of the possible axes of separation. Crossing can be determined by projecting the shape and checking whether the two projection sections [Amin, Amax] and [Bmin, Bmax] overlap each other. </font><font style="vertical-align: inherit;">Expressed in the formula, if Amax &lt;Bmin or Bmax &lt;Amin, the two intervals do not overlap.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The axis that can be the separation axis between the convex surfaces is</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cross product of the side of convex surface 1 and the side of convex surface 2</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Convex 1 normal</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Convex 2 normal</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From this, the axis that can be the separation axis between the triangle and the voxel (AABB) is</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nine cross products obtained from the combination of the three sides of the triangle and the three orthogonal sides of AABB.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AABB's three normals</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triangle normal</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, for each of these 13 axes, the intersection of the triangle and the voxel is determined by determining whether or not the projections overlap.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since it may be useless to judge the intersection of one triangle and all voxel data, calculate the AABB including the triangle and judge the intersection with the voxels contained in it. ..</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Calculate the triangle AABB</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
var min = tri.bounds.min - start;</font></font></font></font><font></font>
var max = tri.bounds.max - start;<font></font>
int iminX = Mathf.RoundToInt(min.x / unit);<font></font>
int iminY = Mathf.RoundToInt(min.y / unit);<font></font>
int iminZ = Mathf.RoundToInt(min.z / unit);<font></font>
int imaxX = Mathf.RoundToInt(max.x / unit);<font></font>
int imaxY = Mathf.RoundToInt(max.y / unit);<font></font>
int imaxZ = Mathf.RoundToInt(max.z / unit);<font></font>
iminX = Mathf.Clamp(iminX, 0, width - 1);<font></font>
iminY = Mathf.Clamp(iminY, 0, height - 1);<font></font>
iminZ = Mathf.Clamp(iminZ, 0, depth - 1);<font></font>
imaxX = Mathf.Clamp(imaxX, 0, width - 1);<font></font>
imaxY = Mathf.Clamp(imaxY, 0, height - 1);<font></font>
imaxZ = Mathf.Clamp(imaxZ, 0, depth - 1);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Judge the intersection with voxels in the triangular AABB</font></font><font></font>
for(int x = iminX; x &lt;= imaxX; x++) {<font></font>
    for(int y = iminY; y &lt;= imaxY; y++) {<font></font>
        for(int z = iminZ; z &lt;= imaxZ; z++) {<font></font>
            if(Intersects(tri, boxes[x, y, z])) {<font></font>
                ...<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Intersects (Triangle, Bounds) function is used to determine the intersection of a triangle and a voxel.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist">public static bool Intersects(Triangle tri, Bounds aabb)<font></font>
{<font></font>
    ...<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this function, the intersection judgment is performed for the above 13 axes, but the three normals of AABB are known (since they have sides along the XYZ axes, they are simply the X axis (1, 0, 0), Y-axis (0, 1, 0), Z-axis (0, 0, 1) normals), or so that the center of AABB is at the origin (0, 0, 0) The intersection judgment is optimized by translating the coordinates of the triangle and AABB.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Get the center coordinates of AABB and the extents of each side</font></font><font></font>
Vector3 center = aabb.center, extents = aabb.max - center;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Translate the coordinates of the triangle so that the center of AABB is at the origin (0, 0, 0)</font></font><font></font>
Vector3 v0 = tri.a - center,<font></font>
        v1 = tri.b - center,<font></font>
        v2 = tri.c - center;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Get the vector representing the three sides of the triangle</font></font><font></font>
Vector3 f0 = v1 - v0,<font></font>
        f1 = v2 - v1,<font></font>
        f2 = v0 - v2;<font></font>
<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, we will make an intersection judgment based on the nine cross products obtained from the combination of the three sides of the triangle and the three orthogonal sides of AABB, but the direction of the three sides of AABB will be the XYZ axes. You can take advantage of the parallelism and omit the calculation to get the cross product.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Since the sides of AABB are the direction vectors x (1, 0, 0), y (0, 1, 0), z (0, 0, 1), respectively,</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// You can get 9 different cross products without doing any calculations</font></font><font></font>
Vector3<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    a00 = new Vector3 (0, -f0.z, f0.y), // Cross product of X axis and f0</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    a01 = new Vector3 (0, -f1.z, f1.y), // X and f1</font></font><font></font>
    a02 = new Vector3(0, -f2.z, f2.y), // Xとf2<font></font>
    a10 = new Vector3(f0.z, 0, -f0.x), // Yとf0<font></font>
    a11 = new Vector3(f1.z, 0, -f1.x), // Yとf1<font></font>
    a12 = new Vector3(f2.z, 0, -f2.x), // Yとf2<font></font>
    a20 = new Vector3(-f0.y, f0.x, 0), // Zとf0<font></font>
    a21 = new Vector3(-f1.y, f1.x, 0), // Zとf1<font></font>
    a22 = new Vector3(-f2.y, f2.x, 0); // Zとf2<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Perform intersection judgment for 9 axes (described later)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// (If any one of the axes does not intersect, the triangle and AABB do not intersect, so false is returned)</font></font><font></font>
if (<font></font>
    !Intersects(v0, v1, v2, extents, a00) ||<font></font>
    !Intersects(v0, v1, v2, extents, a01) ||<font></font>
    !Intersects(v0, v1, v2, extents, a02) ||<font></font>
    !Intersects(v0, v1, v2, extents, a10) ||<font></font>
    !Intersects(v0, v1, v2, extents, a11) ||<font></font>
    !Intersects(v0, v1, v2, extents, a12) ||<font></font>
    !Intersects(v0, v1, v2, extents, a20) ||<font></font>
    !Intersects(v0, v1, v2, extents, a21) ||<font></font>
    !Intersects(v0, v1, v2, extents, a22)<font></font>
)<font></font>
{<font></font>
    return false;<font></font>
}<font></font>
<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following function projects the triangle and AABB on these axes to determine the intersection.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist">protected static bool Intersects(<font></font>
    Vector3 v0,<font></font>
    Vector3 v1,<font></font>
    Vector3 v2,<font></font>
    Vector3 extents,<font></font>
    Vector3 axis<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
)</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{</font></font></font></font><font></font>
    ...<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The point to note here is that the optimization is performed by bringing the center of AABB to the origin. </font><font style="vertical-align: inherit;">It is not necessary to project all the vertices of AABB on the axis, and the interval on the axis can be obtained simply by projecting the vertex with the maximum value for the XYZ axes of AABB, that is, the extents of half the length of each side. I will.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The value r obtained by projecting extents represents the interval [-r, r] on the projection axis of AABB, which means that the projection can be calculated only once for AABB.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Project the vertices of the triangle on the axis</font></font><font></font>
float p0 = Vector3.Dot(v0, axis);<font></font>
float p1 = Vector3.Dot(v1, axis);<font></font>
float p2 = Vector3.Dot(v2, axis);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Project the extents with the maximum value for the XYZ axes of AABB on the axis to get the value r</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Since the section of AABB is [-r, r], it is not necessary to project all vertices for AABB.</font></font><font></font>
float r =<font></font>
    extents.x * Mathf.Abs(axis.x) +<font></font>
    extents.y * Mathf.Abs(axis.y) +<font></font>
    extents.z * Mathf.Abs(axis.z);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Triangular projection section</font></font><font></font>
float minP = Mathf.Min(p0, p1, p2);<font></font>
float maxP = Mathf.Max(p0, p1, p2);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Determine if the triangular section and the AABB section overlap</font></font><font></font>
return !((maxP &lt; -r) || (r &lt; minP));<font></font>
<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next to the discrimination based on the nine cross products, the discrimination is performed based on the three normals of AABB.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using the characteristic that the normal of AABB is parallel to the XYZ axes, the coordinate values ​​are translated so as to bring the center of AABB to the origin, so the minimum value for the XYZ component of each vertex of the triangle is simply. Crossing judgment can be performed simply by comparing the maximum value and extends.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// X axis</font></font><font></font>
if (<font></font>
    Mathf.Max(v0.x, v1.x, v2.x) &lt; -extents.x ||<font></font>
    Mathf.Min(v0.x, v1.x, v2.x) &gt; extents.x<font></font>
)<font></font>
{<font></font>
    return false;<font></font>
}<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Y axis</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
if (</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    Mathf.Max (v0.y, v1.y, v2.y) &lt;-extents.y ||</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    Mathf.Min (v0.y, v1.y, v2.y)&gt; extents.y</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
)</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    return false;</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Z axis</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
if (</font></font></font></font><font></font>
    Mathf.Max(v0.z, v1.z, v2.z) &lt; -extents.z ||<font></font>
    Mathf.Min(v0.z, v1.z, v2.z) &gt; extents.z<font></font>
)<font></font>
{<font></font>
    return false;<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lastly, regarding the triangular normal, we are making a judgment about the intersection of the Plane with the triangular normal and AABB.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist">var normal = Vector3.Cross(f1, f0).normalized;<font></font>
var pl = new Plane(normal, Vector3.Dot(normal, tri.a));<font></font>
return Intersects(pl, aabb);<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Intersects (Plane, Bounds) function determines the intersection of Plane and AABB.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist">public static bool Intersects(Plane pl, Bounds aabb)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{</font></font></font></font><font></font>
    Vector3 center = aabb.center;<font></font>
    var extents = aabb.max - center;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Project the extents on the normal of Plane</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    var r =</font></font></font></font><font></font>
        extents.x * Mathf.Abs(pl.normal.x) +<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        extents.y * Mathf.Abs (pl.normal.y) +</font></font></font></font><font></font>
        extents.z * Mathf.Abs(pl.normal.z);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Calculate the distance between Plane and the center of AABB</font></font><font></font>
    var s = Vector3.Dot(pl.normal, center) - pl.distance;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Determine if s is in the range [-r, r]</font></font><font></font>
    return Mathf.Abs(s) &lt;= r;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
</pre>
</div>

<h4><a id="h1-2-5-2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Write intersected voxels to array data</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the intersecting voxels can be determined for one triangle, the fill flag of the voxel data is set, and the front flag is set to indicate whether the triangle is front or back when viewed from the determined direction. </font><font style="vertical-align: inherit;">(The front flag will be described later)</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some voxels may intersect both front-facing and back-facing triangles, in which case the front flag should prioritize the back.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist">if(Intersects(tri, boxes[x, y, z])) {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Get voxels at intersecting (x, y, z)</font></font><font></font>
    var voxel = volume[x, y, z];<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Set the voxel position</font></font><font></font>
    voxel.position = boxes[x, y, z].center;<font></font>
<font></font>
    if(voxel.fill &amp; 1 == 0) {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // If the voxels are not yet filled</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Flag the triangle that intersects the voxel for the front</font></font><font></font>
        voxel.front = front;<font></font>
    } else {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // If the voxel is already filled with other triangles</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Give priority to the flag on the back</font></font><font></font>
        voxel.front = voxel.front &amp; front;<font></font>
    }<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Flag to fill voxels</font></font><font></font>
    voxel.fill = 1;<font></font>
    volume[x, y, z] = voxel;<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The front flag is required for the "process to fill the contents of the mesh" described later, and sets whether it is the front or the back when viewed from the "direction to fill the contents".</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the sample code, the contents of the mesh are filled in the forward (0, 0, 1) direction, so it is determined whether the triangle is in front when viewed from forward (0, 0, 1).</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the inner product of the normal of the triangle and the direction to fill the voxels is 0 or less, it means that the triangle is the front when viewed from that direction.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPUVoxelizer.cs</font></font></p>
<pre class="emlist">public class Triangle {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public Vector3 a, b, c; // 3 points that make up a triangle</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public bool frontFacing; // Flag whether the triangle is a surface when viewed from the direction of filling the voxels</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public Bounds bounds; // Triangular AABB</font></font><font></font>
<font></font>
    public Triangle (Vector3 a, Vector3 b, Vector3 c, Vector3 dir) {<font></font>
        this.a = a;<font></font>
        this.b = b;<font></font>
        this.c = c;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Determine if the triangle is front when viewed from the direction of filling the voxels</font></font><font></font>
        var normal = Vector3.Cross(b - a, c - a);<font></font>
        this.frontFacing = (Vector3.Dot(normal, dir) &lt;= 0f);<font></font>
<font></font>
        ...<font></font>
    }<font></font>
}<font></font>
</pre>
</div>

<h3><a id="h1-2-6"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2.6　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fill the voxels located inside the mesh from the voxel data representing the surface of the mesh</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we have calculated the voxel data located on the mesh surface, we will fill in the inside.</font></font></p>
<div id="id_Nakamura_2FVoxelFill" class="image">
<img src="./Chapter 1 _ Real-Time GPU-Based Voxelizer_files/VoxelFill.png" alt="State after generating voxel data located on the mesh surface">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.8: State after generating voxel data located on the mesh surface
</font></font></p>
</div>

<h4><a id="h1-2-6-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flow to fill voxels</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Search for voxels that are facing forward when viewed from the direction of filling the voxels.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Empty voxels will pass through as shown in the figure below.</font></font></p>
<div id="id_Nakamura_2FVoxelFill0" class="image">
<img src="./Chapter 1 _ Real-Time GPU-Based Voxelizer_files/VoxelFill0.png" alt="Search for voxels that are facing forward when viewed from the direction of filling the voxels. Empty voxels pass through (the arrow indicates the direction of filling the voxels, and the frame indicates the voxel position being searched).">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.9: Search for voxels facing forward when viewed from the voxel-filling direction Empty voxels pass through (arrows fill voxels and frames represent voxel positions being searched)
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Once you find a voxel that is facing the front, proceed through the voxel that is facing the front.</font></font></p>
<div id="id_Nakamura_2FVoxelFill1" class="image">
<img src="./Chapter 1 _ Real-Time GPU-Based Voxelizer_files/VoxelFill1.png" alt="The state where the voxel facing the front is found (the line protruding from the mesh surface is the normal of the mesh, and in the figure, the normal of the mesh and the direction of filling the voxel are opposite, so the voxel at the frame position is You can see that it is located on the front)">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.10: Finding a voxel facing the front (the line coming out of the mesh surface is the mesh normal, and in the figure the mesh normal and the voxel filling direction are opposite, so the position of the frame You can see that the voxel is located in the front)
</font></font></p>
</div>
<div id="id_Nakamura_2FVoxelFill2" class="image">
<img src="./Chapter 1 _ Real-Time GPU-Based Voxelizer_files/VoxelFill2.png" alt="Go through the voxels facing the front">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.11: Go through a voxel facing the front
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After passing through the voxels facing the front, you will reach the inside of the mesh.</font></font></p>
<div id="id_Nakamura_2FVoxelFill3" class="image">
<img src="./Chapter 1 _ Real-Time GPU-Based Voxelizer_files/VoxelFill3.png" alt="After passing through the voxels facing the front and reaching the inside of the mesh">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.12: Passing through a voxel facing the front and reaching the inside of the mesh
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proceed through the inside of the mesh and fill the voxels that have arrived.</font></font></p>
<div id="id_Nakamura_2FVoxelFill4" class="image">
<img src="./Chapter 1 _ Real-Time GPU-Based Voxelizer_files/VoxelFill4.png" alt="Fill the reached voxels as if filling the inside of the mesh">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.13: Fill the reached voxels as they fill the inside of the mesh
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then, when you reach the voxel facing the back when viewed from the direction of filling the voxel, you can see that the inside of the mesh has been filled. </font><font style="vertical-align: inherit;">Go through the voxels facing the back, and when you reach the outside of the mesh, you will start searching for the voxels facing the front again.</font></font></p>
<div id="id_Nakamura_2FVoxelFill5" class="image">
<img src="./Chapter 1 _ Real-Time GPU-Based Voxelizer_files/VoxelFill5.png" alt="Proceed through the voxel facing the back from the direction of filling the voxel, and reach the outside of the mesh again">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.14: Proceed through the voxel facing backwards from the direction of filling the voxel and then out of the mesh
</font></font></p>
</div>

<h4><a id="h1-2-6-2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementation to fill voxels</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As determined in the previous section, the inside is filled in the forward (0, 0, 1) direction, so in a 3D voxel array, the inside is filled in the z direction.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The process of filling the contents starts from volume [x, y, 0] on the front side in the z direction and proceeds to volume [x, y, depth -1].</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Fill the inside of the mesh</font></font><font></font>
for(int x = 0; x &lt; width; x++)<font></font>
{<font></font>
    for(int y = 0; y &lt; height; y++)<font></font>
    {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Fill the inside of the mesh from the front side in the z direction to the back side</font></font><font></font>
        for(int z = 0; z &lt; depth; z++)<font></font>
        {<font></font>
            ...<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Based on the front flag (front or back in the z direction) already written in the voxel data, the process proceeds according to the above-mentioned flow of filling voxels.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist">...<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Fill the inside of the mesh from the front side in the z direction to the back side</font></font><font></font>
for(int z = 0; z &lt; depth; z++)<font></font>
{<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Ignore if (x, y, z) is empty</font></font><font></font>
    if (volume[x, y, z].IsEmpty()) continue;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Go through the voxels located in front</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    int ifront = z;</font></font></font></font><font></font>
    for(; ifront &lt; depth &amp;&amp; volume[x, y, ifront].IsFrontFace(); ifront++) {}<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // If you go to the end, it's over</font></font><font></font>
    if(ifront &gt;= depth) break;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Find the voxels located on the back</font></font><font></font>
    int iback = ifront;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Go inside the mesh</font></font><font></font>
    for (; iback &lt; depth &amp;&amp; volume[x, y, iback].IsEmpty(); iback++) {}<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // If you go to the end, it's over</font></font></font></font><font></font>
    if (iback &gt;= depth) break;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Determine if (x, y, iback) is on the back</font></font><font></font>
    if(volume[x, y, iback].IsBackFace()) {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Follow the voxels located on the back</font></font><font></font>
        for (; iback &lt; depth &amp;&amp; volume[x, y, iback].IsBackFace(); iback++) {}<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Fill voxels from (x, y, ifront) to (x, y, iback)</font></font><font></font>
    for(int z2 = ifront; z2 &lt; iback; z2++)<font></font>
    {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        var p = boxes [x, y, z2] .center;</font></font></font></font><font></font>
        var voxel = volume[x, y, z2];<font></font>
        voxel.position = p;<font></font>
        voxel.fill = 1;<font></font>
        volume[x, y, z2] = voxel;<font></font>
    }<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Proceed through the loop until it finishes processing (x, y, iback)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    z = iback;</font></font></font></font><font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Up to this point, we have obtained voxel data filled with the contents of the mesh.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the processed 3D voxel data contains empty voxels, CPUVoxelizer.Voxelize returns only the voxels that make up the surface of the mesh and the filled contents.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Get non-empty voxels</font></font><font></font>
voxels = new List&lt;Voxel_t&gt;();<font></font>
for(int x = 0; x &lt; width; x++) {<font></font>
    for(int y = 0; y &lt; height; y++) {<font></font>
        for(int z = 0; z &lt; depth; z++) {<font></font>
            if(!volume[x, y, z].IsEmpty())<font></font>
            {<font></font>
                voxels.Add(volume[x, y, z]);<font></font>
            }<font></font>
        }<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In CPUVoxelizerTest.cs, a mesh is constructed using the voxel data obtained by CPUVoxelizer, and the voxels are visualized.</font></font></p>
<div id="id_Nakamura_2FCPUVoxelizerTest" class="image">
<img src="./Chapter 1 _ Real-Time GPU-Based Voxelizer_files/CPUVoxelizerTest.png" alt="Demonstration of visualization of voxel data obtained by CPUVoxelizer.Voxelize as a mesh (CPUVoxelizerTest.scene)">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.15: Demo of voxel data obtained by CPUVoxelizer.Voxelize visualized as a mesh (CPUVoxelizerTest.scene)
</font></font></p>
</div>

<h2><a id="h1-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voxel mesh representation</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The VoxelMesh class describes the process of constructing a mesh based on the voxel data array Voxel_t [] and the unit length information of one voxel.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPUVoxelizerTest.cs in the previous section uses this class to generate voxel mesh.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VoxelMesh.cs</font></font></font></font></p>
<pre class="emlist">public class VoxelMesh {<font></font>
<font></font>
    public static Mesh Build (Voxel_t[] voxels, float size)<font></font>
    {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        var hsize = size * 0.5f;</font></font></font></font><font></font>
        var forward = Vector3.forward * hsize;<font></font>
        var back = -forward;<font></font>
        var up = Vector3.up * hsize;<font></font>
        var down = -up;<font></font>
        var right = Vector3.right * hsize;<font></font>
        var left = -right;<font></font>
<font></font>
        var vertices = new List&lt;Vector3&gt;();<font></font>
        var normals = new List&lt;Vector3&gt;();<font></font>
        var triangles = new List&lt;int&gt;();<font></font>
<font></font>
        for(int i = 0, n = voxels.Length; i &lt; n; i++)<font></font>
        {<font></font>
            if(voxel[i].fill == 0) continue;<font></font>
<font></font>
            var p = voxels[i].position;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // The vertices of the eight corners that make up the Cube that represents one voxel</font></font><font></font>
            var corners = new Vector3[8] {<font></font>
                p + forward + left + up,<font></font>
                p + back + left + up,<font></font>
                p + back + right + up,<font></font>
                p + forward + right + up,<font></font>
<font></font>
                p + forward + left + down,<font></font>
                p + back + left + down,<font></font>
                p + back + right + down,<font></font>
                p + forward + right + down,<font></font>
            };<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // Build the 6 faces that make up the Cube</font></font><font></font>
<font></font>
            // up<font></font>
            AddTriangle(<font></font>
                corners[0], corners[3], corners[1],<font></font>
                up, vertices, normals, triangles<font></font>
            );<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            AddTriangle(</font></font></font></font><font></font>
                corners[2], corners[1], corners[3],<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                up, vertices, normals, triangles</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            );</font></font></font></font><font></font>
<font></font>
            // down<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            AddTriangle(</font></font></font></font><font></font>
                corners[4], corners[5], corners[7],<font></font>
                down, vertices, normals, triangles<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            );</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            AddTriangle(</font></font></font></font><font></font>
                corners[6], corners[7], corners[5],<font></font>
                down, vertices, normals, triangles<font></font>
            );<font></font>
<font></font>
            // right<font></font>
            AddTriangle(<font></font>
                corners[7], corners[6], corners[3],<font></font>
                right, vertices, normals, triangles<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            );</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            AddTriangle(</font></font></font></font><font></font>
                corners[2], corners[3], corners[6],<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                right, vertices, normals, triangles</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            );</font></font></font></font><font></font>
<font></font>
            // left<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            AddTriangle(</font></font></font></font><font></font>
                corners[5], corners[4], corners[1],<font></font>
                left, vertices, normals, triangles<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            );</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            AddTriangle(</font></font></font></font><font></font>
                corners[0], corners[1], corners[4],<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                left, vertices, normals, triangles</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            );</font></font></font></font><font></font>
<font></font>
            // forward<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            AddTriangle(</font></font></font></font><font></font>
                corners[4], corners[7], corners[0],<font></font>
                forward, vertices, normals, triangles<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            );</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            AddTriangle(</font></font></font></font><font></font>
                corners[3], corners[0], corners[7],<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                forward, vertices, normals, triangles</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            );</font></font></font></font><font></font>
<font></font>
            // back<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            AddTriangle(</font></font></font></font><font></font>
                corners[6], corners[5], corners[2],<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                forward, vertices, normals, triangles</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            );</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            AddTriangle(</font></font></font></font><font></font>
                corners[1], corners[2], corners[5],<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                forward, vertices, normals, triangles</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            );</font></font></font></font><font></font>
        }<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        var mesh = new Mesh ();</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        mesh.SetVertices (vertices);</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Apply 32bit index format if the number of vertices exceeds the number that can be supported by 16bit</font></font><font></font>
        mesh.indexFormat =<font></font>
            (vertices.Count &lt;= 65535)<font></font>
            ? IndexFormat.UInt16 : IndexFormat.UInt32;<font></font>
        mesh.SetNormals(normals);<font></font>
        mesh.SetIndices(triangles.ToArray(), MeshTopology.Triangles, 0);<font></font>
        mesh.RecalculateBounds();<font></font>
        return mesh;<font></font>
    }<font></font>
}<font></font>
</pre>
</div>

<h2><a id="h1-4"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.4　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implementation on GPU</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From here, I will explain how to execute voxelization implemented by CPU Voxelizer faster using GPU.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The voxelization algorithm implemented by CPUVoxelizer can be parallelized for each coordinate in the lattice space separated by the unit length of voxels on the XY plane.</font></font></p>
<div id="id_Nakamura_2FParallelization" class="image">
<img src="./Chapter 1 _ Real-Time GPU-Based Voxelizer_files/Parallelization.png" alt="Lattice space delimited by unit length of voxels on the XY plane GPU implementation is possible because voxelization can be parallelized for each of these lattices.">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.16: Lattice space delimited by unit length of voxels on the XY plane. Voxelization can be parallelized for each lattice, so GPU implementation is possible.
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you allocate each process that can be parallelized to the GPU thread, you can execute the process at high speed thanks to the high-speed parallel computing of the GPU.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The implementation of voxelization on GPU is described in GPU Boxelizer.cs and Voxelizer.compute.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(The basics of Compute Shader, which appears in this section and is indispensable for GPGPU programming in Unity, are explained in Unity Graphics Programming vol.1 "Introduction to Compute Shader")</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voxelization on GPU is a static function of GPUVoxelizer class</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist">public class GPUVoxelizer<font></font>
{<font></font>
    public static GPUVoxelData Voxelize (<font></font>
        ComputeShader voxelizer,<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        Mesh mesh,</font></font></font></font><font></font>
        int resolution<font></font>
    ) {<font></font>
    ...<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Execute by calling. </font><font style="vertical-align: inherit;">When executed with Voxelizer.compute, the mesh to be voxelized, and the resolution specified as arguments, GPUVoxelData indicating voxel data is returned.</font></font></p>

<h3><a id="h1-4-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.4.1 Setting　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> up the data required for voxel generation on the GPU</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Follow the general flow of voxelization (1) to (3) to set up the data required for voxel generation.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist">public static GPUVoxelData Voxelize (<font></font>
    ComputeShader voxelizer,<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    Mesh mesh,</font></font></font></font><font></font>
    int resolution<font></font>
) {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Same process as CPUVoxelizer.Voxelize -------</font></font><font></font>
    mesh.RecalculateBounds();<font></font>
    var bounds = mesh.bounds;<font></font>
<font></font>
    float maxLength = Mathf.Max(<font></font>
        bounds.size.x,<font></font>
        Mathf.Max(bounds.size.y, bounds.size.z)<font></font>
    );<font></font>
    var unit = maxLength / resolution;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    var hunit = unit * 0.5f;</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    var start = bounds.min - new Vector3 (unit, unit, unit);</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    var end = bounds.max + new Vector3 (unit, unit, unit);</font></font><font></font>
    var size = end - start;<font></font>
<font></font>
    int width = Mathf.CeilToInt(size.x / unit);<font></font>
    int height = Mathf.CeilToInt(size.y / unit);<font></font>
    int depth = Mathf.CeilToInt(size.z / unit);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // ------- So far the same as CPUVoxelizer.Voxelize</font></font><font></font>
    ...<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The array of Voxel_t is defined as ComputeBuffer so that it can be handled on the GPU. </font><font style="vertical-align: inherit;">The point to note here is that the Voxel_t array generated as a 3D array is defined as a 1D array in the CPU implementation.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is because it is difficult for GPUs to handle multidimensional arrays, so define it as a one-dimensional array and get the index on the one-dimensional array from the three-dimensional position (x, y, z) in Compute Shader. By doing so, the one-dimensional array is processed like a three-dimensional array.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Generate a ComputeBuffer representing a Voxel_t array</font></font><font></font>
var voxelBuffer = new ComputeBuffer(<font></font>
    width * height * depth,<font></font>
    Marshal.SizeOf(typeof(Voxel_t))<font></font>
);<font></font>
var voxels = new Voxel_t[voxelBuffer.count];<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
voxelBuffer.SetData (voxels); // Initialize</font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transfer these set up data to the GPU side.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Transfer voxel data to GPU side</font></font><font></font>
voxelizer.SetVector("_Start", start);<font></font>
voxelizer.SetVector("_End", end);<font></font>
voxelizer.SetVector("_Size", size);<font></font>
<font></font>
voxelizer.SetFloat("_Unit", unit);<font></font>
voxelizer.SetFloat("_InvUnit", 1f / unit);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
voxelizer.SetFloat ("_ HalfUnit", unit);</font></font><font></font>
voxelizer.SetInt("_Width", width);<font></font>
voxelizer.SetInt("_Height", height);<font></font>
voxelizer.SetInt("_Depth", depth);<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generate a Compute Buffer that represents the mesh in order to determine the intersection of the triangles and voxels that make up the mesh.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Generate a ComputeBuffer that represents the vertex array of the mesh</font></font><font></font>
var vertices = mesh.vertices;<font></font>
var vertBuffer = new ComputeBuffer(<font></font>
    vertices.Length,<font></font>
    Marshal.SizeOf(typeof(Vector3))<font></font>
);<font></font>
vertBuffer.SetData(vertices);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Generate a ComputeBuffer that represents a triangular array of meshes</font></font><font></font>
var triangles = mesh.triangles;<font></font>
var triBuffer = new ComputeBuffer(<font></font>
    triangles.Length,<font></font>
    Marshal.SizeOf(typeof(int))<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
);</font></font></font></font><font></font>
triBuffer.SetData(triangles);<font></font>
</pre>
</div>

<h3><a id="h1-4-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.4.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generate voxels located on the surface of the mesh on the GPU</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the process of generating voxels located on the surface of the mesh on the GPU, after generating voxels that intersect the front-facing triangle, the voxels that intersect the back-facing triangle are generated.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is because the value of the front flag written to the voxel may not be uniquely determined when multiple triangles intersect for the voxel at the same position.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One thing to keep in mind when using GPU parallel computing is the indefiniteness of the results due to multiple threads accessing the same data at the same time.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the process of generating this surface, priority is given to the value of the front flag being the back (false), and voxel generation is executed in the order of front → back to prevent indeterminacy of the result.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transfer the mesh data you just generated to the GPU kernel SurfaceFront, which creates voxels that intersect the front-facing triangles.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Transfer mesh data to GPU kernel SurfaceFront</font></font><font></font>
var surfaceFrontKer = new Kernel(voxelizer, "SurfaceFront");<font></font>
voxelizer.SetBuffer(surfaceFrontKer.Index, "_VoxelBuffer", voxelBuffer);<font></font>
voxelizer.SetBuffer(surfaceFrontKer.Index, "_VertBuffer", vertBuffer);<font></font>
voxelizer.SetBuffer(surfaceFrontKer.Index, "_TriBuffer", triBuffer);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Set the number of triangles that make up the mesh</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
var triangleCount = triBuffer.count / 3; // (the number of vertex indexes that make up the triangle / 3) is the number of triangles</font></font><font></font>
voxelizer.SetInt("_TriangleCount", triangleCount);<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This process is performed in parallel for each triangle that makes up the mesh. </font><font style="vertical-align: inherit;">Set the kernel thread group to (triangleCount / number of kernel threads + 1, 1, 1) so that all triangles are processed and run the kernel.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Build a voxel that intersects a front-facing triangle</font></font><font></font>
voxelizer.Dispatch(<font></font>
    surfaceFrontKer.Index,<font></font>
    triangleCount / (int)surfaceFrontKer.ThreadX + 1,<font></font>
    (int)surfaceFrontKer.ThreadY,<font></font>
    (int)surfaceFrontKer.ThreadZ<font></font>
);<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the SurfaceFront kernel only processes triangles that are facing the front, it checks the front and back of the triangle, returns to finish the process if it is the back, and builds the mesh surface if it is the front. Is running.</font></font></p>
<div class="emlist-code">
<p class="caption">Voxelizer.compute</p>
<pre class="emlist">[numthreads(8, 1, 1)]<font></font>
void SurfaceFront (uint3 id : SV_DispatchThreadID)<font></font>
{<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // return if the number of triangles is exceeded</font></font><font></font>
    int idx = (int)id.x;<font></font>
    if(idx &gt;= _TriangleCount) return;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Get the vertex position of the triangle and the front and back flags</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    float3 va, vb, vc;</font></font></font></font><font></font>
    bool front;<font></font>
    get_triangle(idx, va, vb, vc, front);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // return if it is on the back</font></font><font></font>
    if (!front) return;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Build a mesh surface</font></font><font></font>
    surface(va, vb, vc, front);<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The get_triangle function gets the vertex position and front / back flag of the triangle based on the mesh data (_TriBuffer representing the vertex index that constitutes the triangle and _VertBuffer representing the vertex) passed from the CPU to the GPU side.</font></font></p>
<div class="emlist-code">
<p class="caption">Voxelizer.compute</p>
<pre class="emlist">void get_triangle(<font></font>
    int idx,<font></font>
    out float3 va, out float3 vb, out float3 vc,<font></font>
    out bool front<font></font>
)<font></font>
{<font></font>
    int ia = _TriBuffer[idx * 3];<font></font>
    int ib = _TriBuffer[idx * 3 + 1];<font></font>
    int ic = _TriBuffer[idx * 3 + 2];<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    va = _VertBuffer [ia];</font></font></font></font><font></font>
    vb = _VertBuffer[ib];<font></font>
    vc = _VertBuffer[ic];<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Determine if the triangle is front or back when viewed from the forward (0, 0, 1) direction</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    float3 normal = cross ((vb - va), (vc - vb));</font></font></font></font><font></font>
    front = dot(normal, float3(0, 0, 1)) &lt; 0;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The surface function that determines the intersection of a voxel and a triangle and writes the result to the voxel data takes time to acquire the index of the voxel data generated as a one-dimensional array, but the content of the process is implemented on the CPU Voxelizer. It will be almost the same as.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voxelizer.compute</font></font></font></font></p>
<pre class="emlist">void surface (float3 va, float3 vb, float3 vc, bool front)<font></font>
{<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Calculate the triangle AABB</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    float3 tbmin = min (min (va, vb), vc);</font></font></font></font><font></font>
    float3 tbmax = max(max(va, vb), vc);<font></font>
<font></font>
    float3 bmin = tbmin - _Start;<font></font>
    float3 bmax = tbmax - _Start;<font></font>
    int iminX = round(bmin.x / _Unit);<font></font>
    int iminY = round(bmin.y / _Unit);<font></font>
    int iminZ = round(bmin.z / _Unit);<font></font>
    int imaxX = round(bmax.x / _Unit);<font></font>
    int imaxY = round(bmax.y / _Unit);<font></font>
    int imaxZ = round(bmax.z / _Unit);<font></font>
    iminX = clamp(iminX, 0, _Width - 1);<font></font>
    iminY = clamp(iminY, 0, _Height - 1);<font></font>
    iminZ = clamp(iminZ, 0, _Depth - 1);<font></font>
    imaxX = clamp(imaxX, 0, _Width - 1);<font></font>
    imaxY = clamp(imaxY, 0, _Height - 1);<font></font>
    imaxZ = clamp(imaxZ, 0, _Depth - 1);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Judge the intersection with voxels in the triangular AABB</font></font><font></font>
    for(int x = iminX; x &lt;= imaxX; x++) {<font></font>
        for(int y = iminY; y &lt;= imaxY; y++) {<font></font>
            for(int z = iminZ; z &lt;= imaxZ; z++) {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                // Generate AABB for voxels located at (x, y, z)</font></font><font></font>
                float3 center = float3(x, y, z) * _Unit + _Start;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                AABB aabb;</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                aabb.min = center - _HalfUnit;</font></font></font></font><font></font>
                aabb.center = center;<font></font>
                aabb.max = center + _HalfUnit;<font></font>
                if(intersects_tri_aabb(va, vb, vc, aabb))<font></font>
                {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                    // Get the index of a one-dimensional voxel array from the position of (x, y, z)</font></font><font></font>
                    uint vid = get_voxel_index(x, y, z);<font></font>
                    Voxel voxel = _VoxelBuffer[vid];<font></font>
                    voxel.position = get_voxel_position(x, y, z);<font></font>
                    voxel.front = front;<font></font>
                    voxel.fill = true;<font></font>
                    _VoxelBuffer[vid] = voxel;<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we have generated voxels for the front-facing triangles, let's move on to the back-facing triangles.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transfer the mesh data to the GPU kernel SurfaceBack, which generates voxels that intersect the triangle facing the back, and execute it as before.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist">var surfaceBackKer = new Kernel(voxelizer, "SurfaceBack");<font></font>
voxelizer.SetBuffer(surfaceBackKer.Index, "_VoxelBuffer", voxelBuffer);<font></font>
voxelizer.SetBuffer(surfaceBackKer.Index, "_VertBuffer", vertBuffer);<font></font>
voxelizer.SetBuffer(surfaceBackKer.Index, "_TriBuffer", triBuffer);<font></font>
voxelizer.Dispatch(<font></font>
    surfaceBackKer.Index,<font></font>
    triangleCount / (int)surfaceBackKer.ThreadX + 1,<font></font>
    (int)surfaceBackKer.ThreadY,<font></font>
    (int)surfaceBackKer.ThreadZ<font></font>
);<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The processing of SurfaceBack is the same as SurfaceFront except that it returns a return when the triangle is facing the front. </font><font style="vertical-align: inherit;">By running SurfaceBack after SurfaceFront, the voxel's front flag will be overridden by SurfaceBack, even if there are voxels that intersect both the front-facing triangle and the back-facing triangle. It will be prioritized to face the back.</font></font></p>
<div class="emlist-code">
<p class="caption">Voxelizer.compute</p>
<pre class="emlist">[numthreads(8, 1, 1)]<font></font>
void SurfaceBack (uint3 id : SV_DispatchThreadID)<font></font>
{<font></font>
    int idx = (int)id.x;<font></font>
    if(idx &gt;= _TriangleCount) return;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    float3 va, vb, vc;</font></font></font></font><font></font>
    bool front;<font></font>
    get_triangle(idx, va, vb, vc, front);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // return if front</font></font><font></font>
    if (front) return;<font></font>
<font></font>
    surface(va, vb, vc, front);<font></font>
}<font></font>
</pre>
</div>

<h3><a id="h1-4-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.4.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fill the voxels located inside the mesh from the voxel data representing the surface of the mesh on the GPU.</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The volume kernel is used to fill the inside of the mesh.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Volume kernel prepares and executes a thread for each coordinate in the lattice space separated by the unit length of voxels on the XY plane. </font><font style="vertical-align: inherit;">In other words, in the case of CPU implementation, the place where the double loop was executed for XY coordinates is parallelized by GPU and speeded up.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Transfer voxel data to Volume kernel</font></font><font></font>
var volumeKer = new Kernel(voxelizer, "Volume");<font></font>
voxelizer.SetBuffer(volumeKer.Index, "_VoxelBuffer", voxelBuffer);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Fill the inside of the mesh</font></font><font></font>
voxelizer.Dispatch(<font></font>
    volumeKer.Index,<font></font>
    width / (int)volumeKer.ThreadX + 1,<font></font>
    height / (int)volumeKer.ThreadY + 1,<font></font>
    (int)volumeKer.ThreadZ<font></font>
);<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Volume kernel implementation is similar to the one implemented in GPU Foxelizer.</font></font></p>
<div class="emlist-code">
<p class="caption">Voxelizer.compute</p>
<pre class="emlist">[numthreads(8, 8, 1)]<font></font>
void Volume (uint3 id : SV_DispatchThreadID)<font></font>
{<font></font>
    int x = (int)id.x;<font></font>
    int y = (int)id.y;<font></font>
    if(x &gt;= _Width) return;<font></font>
    if(y &gt;= _Height) return;<font></font>
<font></font>
    for (int z = 0; z &lt; _Depth; z++)<font></font>
    {<font></font>
        Voxel voxel = _VoxelBuffer[get_voxel_index(x, y, z)];<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Almost the same processing as in CPUVoxelizer.Voxelize continues</font></font><font></font>
        ...<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Once the voxel data is obtained in this way, it discards the mesh data that is no longer needed and generates GPUVoxel Data with the data needed to create the voxel visual representation.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUVoxelizer.cs</font></font></font></font></p>
<pre class="emlist"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Discard mesh data that is no longer needed</font></font><font></font>
vertBuffer.Release();<font></font>
triBuffer.Release();<font></font>
<font></font>
return new GPUVoxelData(voxelBuffer, width, height, depth, unit);<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This completes voxelization by GPU implementation. </font><font style="vertical-align: inherit;">Voxel data is actually visualized using GPU VoxelData in GPUVoxelizerTest.cs.</font></font></p>

<h2><a id="h1-5"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.5　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speed ​​difference between CPU implementation and GPU implementation</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the test scene, Voxelizer is executed at the time of Play, so it is difficult to understand the speed difference between CPU implementation and GPU implementation, but GPU implementation has achieved considerable speedup.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance depends greatly on the execution environment, the number of polygons in the mesh to be voxelized, and the resolution of voxelization.</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Execution environment OS: Windows10, CPU: Core i7, Memory: 32GB, GPU: GeForce GTX 980</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesh with 5319 vertices and 9761 triangles</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voxelized resolution 256</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Under these conditions, the GPU implementation is running 50 times faster than the CPU implementation.</font></font></p>

<h2><a id="h1-6"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.6　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Application example</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introducing an application example (GPUVoxelParticleSystem) using the GPU-implemented ParticleSystem.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The GPU Voxel Particle System uses the Compute Buffer, which represents the voxel data obtained from the GPU Voxelizer, to calculate the position of particles in the Compute Shader.</font></font></p>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voxelize animation model every frame with GPU Voxelizer</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pass the ComputeBuffer of GPUVoxelData to the ComputeShader that calculates the position of particles.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Draw particles with GPU instancing</font></font></li>
</ol>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I am creating an effect in the flow.</font></font></p>
<div id="id_Nakamura_2FGPUVoxelParticleSystem3" class="image">
<img src="./Chapter 1 _ Real-Time GPU-Based Voxelizer_files/GPUVoxelParticleSystem3.png" alt="Application example using ParticleSystem of GPU implementation (GPUVoxelParticleSystem)">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.17: Application example using ParticleSystem of GPU implementation (GPUVoxelParticleSystem)
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By making a large number of particles appear from the voxel position, a visual like an animation model composed of particles is realized.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voxels can be applied to the animation model frame by frame only because of the speedup by implementing the GPU, and in order to expand the range of visual expressions that can be used in real time, such speedup on the GPU is indispensable. It has become a thing.</font></font></p>

<h2><a id="h1-7"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.7　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Summary</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this chapter, we introduced the algorithm for voxelizing the mesh model using CPU implementation as an example, and even speeded up voxelization by GPU implementation.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We took the approach of generating voxels using the intersection judgment of triangles and voxels, but there is also a method of constructing voxel data by rendering the model from the XYZ directions into a 3D texture by parallel projection.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The method introduced in this chapter has a problem in how to apply a texture to the voxelized model, but if the method renders the model to a 3D texture, coloring the voxels is easier and more accurate. You may be able to do it.</font></font></p>

<h2><a id="h1-8"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.8　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reference</font></font></h2>
<ul>
<li>http://blog.wolfire.com/2009/11/Triangle-mesh-voxelization</li>
<li>http://www.dyn4j.org/2010/01/sat/</li>
<li>https://gdbooks.gitbooks.io/3dcollisions/content/Chapter4/aabb-triangle.html</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game Engine Architecture 2nd Edition Chapter 12</font></font></li>
<li>https://developer.nvidia.com/content/basics-gpu-voxelization</li>
</ul></body></html>