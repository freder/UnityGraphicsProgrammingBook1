<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="en" class="translated-ltr" style="height: 100%;"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <link rel="stylesheet" type="text/css" href="./Chapter 3 _ Application of Geometry Shader for Line Representation_files/style.scss">
  <meta name="generator" content="Re:VIEW">
  <title>Application of Geometry Shader for line representation</title>

			<style>
				img {
					max-width: 80vw;
					max-height: 80vh;
				}
			</style><style>
					.goog-te-banner-frame {
						display: none;
					}
				</style>
			<script>(function(){(function injection() {
  var pageLang = 'auto';
  var userLang = 'en';

  var uid = '1E07F158C6FA4460B352973E9693B329';
  var teId = 'TE_' + uid;
  var cbId = 'TECB_' + uid;

  function show() {
    window.setTimeout(function() {
      window[teId].showBanner(true);
    }, 10);
  }

  function newElem() {
    
  }

  if (window[teId]) {
    show();
  } else {
    if (!window.google || !google.translate ||
        !google.translate.TranslateElement) {
      if (!window[cbId]) {
        window[cbId] = function() {
          window[teId] = newElem();
          show();
        };
      }
      
    }
  }
})();})();</script><script src="https://translate.google.com/translate_a/element.js?cb=TECB_1E07F158C6FA4460B352973E9693B329&amp;client=tee&amp;hl=en"></script><script src="./Chapter 3 _ Application of Geometry Shader for Line Representation_files/f.txt"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://translate.googleapis.com/translate_static/css/translateelement.css"><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/translate_static/js/element/main.js"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="./Chapter 3 _ Application of Geometry Shader for Line Representation_files/translateelement.css"><script type="text/javascript" charset="UTF-8" src="./Chapter 3 _ Application of Geometry Shader for Line Representation_files/main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script><script type="text/javascript" charset="UTF-8" src="./Chapter 3 _ Application of Geometry Shader for Line Representation_files/element_main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://translate.googleapis.com/translate_static/css/translateelement.css"><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/translate_static/js/element/main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script></head>
		
<body style="position: relative; min-height: 100%; top: 40px;"><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div>
<h1><a id="h3"></a><span class="secno"><font style="vertical-align: inherit;"><font class="" style="vertical-align: inherit;">Chapter 3　</font></font></span><font style="vertical-align: inherit;"><font class="" style="vertical-align: inherit;"> Application of Geometry Shader for Line Representation</font></font></h1>

<h2><a id="h3-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Introduction</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This year, </font><font style="vertical-align: inherit;">I participated in a hackathon called </font><font style="vertical-align: inherit;">Art Hack Day 2018 </font></font><a id="fnb-kaiware_arthackday" href="https://freder.io/files/unity2/kaiware007.html#fn-kaiware_arthackday" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> where I personally </font><font style="vertical-align: inherit;">created a visual work using Unity.</font></font></p>
<div id="id_Kaiware_2Fkaiware__arthackday2018" class="image">
<pre class="dummyimage"></pre>
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.1: Visual part of Already There
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In my work, I used the technique of drawing a wireframe polygon using the Geometry Shader. </font><font style="vertical-align: inherit;">In this chapter, we will explain the method. </font><font style="vertical-align: inherit;">The sample in this chapter is </font><font style="vertical-align: inherit;">"Geometry Wireframe" from </font></font><a href="https://github.com/IndieVisualLab/UnityGraphicsProgramming2" class="link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/IndieVisualLab/UnityGraphicsProgramming2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p>
<div class="footnote" epub:type="footnote" id="fn-kaiware_arthackday"><p class="footnote">[*1] Art Hack Day 2018 http://arthackday.jp/</p></div>

<h2><a id="h3-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Try to draw a line for the time being</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I think that LineRenderer and GL are often used to draw lines in Unity, but this time I will use Graphics.DrawProcedural assuming that the amount of drawing will increase later. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First of all, let's draw a simple sine wave. </font><font style="vertical-align: inherit;">Take a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">look at the</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sample </font><b><font style="vertical-align: inherit;">SampleWaveLine scene</font></b><font style="vertical-align: inherit;"> .</font></font></p>
<div id="id_Kaiware_2Fkaiware__project__sinwave001" class="image">
<img src="./Chapter 3 _ Application of Geometry Shader for Line Representation_files/kaiware_project_sinwave001.png" alt="SampleWaveLine scene">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.2: SampleWaveLine scene
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For now, press the play button and run it, and you should see an orange sine wave in the Game view. </font><font style="vertical-align: inherit;">Select the WabeLine object in the Hierarchy window and move the Vertex Num slider on the RenderWaveLine component in the Inspector window to change the smoothness of the sine wave. </font><font style="vertical-align: inherit;">The implementation of the RenderWaveLine class looks like this:</font></font></p>
<div id="kaiware_render_waveline_cs" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 3.1: RenderWaveLine.cs</font></font></p>
<pre class="list">using UnityEngine;<font></font>
<font></font>
[ExecuteInEditMode]<font></font>
public class RenderWaveLine : MonoBehaviour {<font></font>
    [Range(2,50)]<font></font>
    public int vertexNum = 4;<font></font>
<font></font>
    public Material material;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    private void OnRenderObject ()</font></font></font></font><font></font>
    {<font></font>
        material.SetInt("_VertexNum", vertexNum - 1);<font></font>
        material.SetPass(0);<font></font>
        Graphics.DrawProcedural(MeshTopology.LineStrip, vertexNum);<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Graphics.DrawProcedural runs immediately after the call, so it must be called inside the OnRenderObject. </font><font style="vertical-align: inherit;">OnRenderObject is called after all cameras have rendered the scene. </font><font style="vertical-align: inherit;">The first argument of Graphics.DrawProcedural is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MeshTopology</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">MeshTopology is a specification of how to configure the mesh. </font><font style="vertical-align: inherit;">There are six configurations that can be specified: Triangles (triangle polygon), Quads (square polygon), Lines (line connecting two points), LineStrip (connecting all points continuously), and Points (independent points). </font><font style="vertical-align: inherit;">The second argument is the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">number</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> of </font><b><font style="vertical-align: inherit;">vertices</font></b><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This time, I want to place the vertices on the line of the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wave and connect the lines, so I </font><font style="vertical-align: inherit;">use </font><b><font style="vertical-align: inherit;">MeshTopology.LineStrip</font></b><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The second argument, vertexNum, specifies the number of vertices used to draw the sine wave. </font><font style="vertical-align: inherit;">As you may have noticed here, I haven't passed an array of vertex coordinates to Shader anywhere. </font><font style="vertical-align: inherit;">The vertex coordinates are calculated in the following Shader Vertex Shader (vertex shader). </font><font style="vertical-align: inherit;">Next is WaveLine.shader.</font></font></p>
<div id="kaiware_waveline_shader" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 3.2: WaveLine.shader</font></font></p>
<pre class="list">Shader "Custom/WaveLine"<font></font>
{<font></font>
  Properties<font></font>
  {<font></font>
    _Color ("Color", Color) = (1,1,1,1)<font></font>
    _ScaleX ("Scale X", Float) = 1<font></font>
    _ScaleY ("Scale Y", Float) = 1<font></font>
    _Speed ("Speed",Float) = 1<font></font>
  }<font></font>
  SubShader<font></font>
  {<font></font>
    Tags { "RenderType"="Opaque" }<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    LOD 100</font></font></font></font><font></font>
<font></font>
    Pass<font></font>
    {<font></font>
      CGPROGRAM<font></font>
      #pragma vertex vert<font></font>
      #pragma fragment frag<font></font>
      #pragma target 3.5<font></font>
<font></font>
      #include "UnityCG.cginc"<font></font>
<font></font>
      #define PI  3.14159265359<font></font>
<font></font>
      struct v2f<font></font>
      {<font></font>
        float4 vertex : SV_POSITION;<font></font>
      };<font></font>
<font></font>
      float4 _Color;<font></font>
      int _VertexNum;<font></font>
      float _ScaleX;<font></font>
      float _ScaleY;<font></font>
      float _Speed;<font></font>
<font></font>
      v2f vert (uint id : SV_VertexID)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      {</font></font></font></font><font></font>
        float div = (float)id / _VertexNum;<font></font>
        float4 pos = float4((div - 0.5) * _ScaleX,<font></font>
          sin(div * 2 * PI + _Time.y * _Speed) * _ScaleY, 0, 1);<font></font>
<font></font>
        v2f o;<font></font>
        o.vertex = UnityObjectToClipPos(pos);<font></font>
        return o;<font></font>
      }<font></font>
<font></font>
      fixed4 frag (v2f i) : SV_Target<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      {</font></font></font></font><font></font>
        return _Color;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      }</font></font></font></font><font></font>
      ENDCG<font></font>
    }<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  }</font></font></font></font><font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SV_VertexID (vertex ID) is passed to the argument of the Vertex Shader function vert. </font><font style="vertical-align: inherit;">The vertex ID is a serial number unique to the vertex. </font><font style="vertical-align: inherit;">Feeling that if you pass the number of vertices to be used as the second argument of Graphics.DrawProcedural, Vertex Shader will be called for the number of vertices, and the vertex ID of the argument will be a value from 0 to -1. is. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Vertex Shader, the ratio from 0 to 1 is calculated by dividing the vertex ID by the number of vertices. </font><font style="vertical-align: inherit;">The vertex coordinates (pos) are calculated based on the calculated ratio. </font><font style="vertical-align: inherit;">The coordinates on the sine wave are obtained by giving the ratio obtained earlier in the calculation of the Y coordinate to the sin function. </font><font style="vertical-align: inherit;">By adding _Time.y, we also animate the change in height as time progresses. </font><font style="vertical-align: inherit;">Since the vertex coordinates are calculated in Vertex Shader, there is no need to pass the vertex coordinates from the C # side. </font><font style="vertical-align: inherit;">Then, UnityObjectToClipPos is passing the coordinates converted from the object space to the clip space of the camera to the Fragment Shader.</font></font></p>

<h2><a id="h3-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dynamically draw a two-dimensional polygon with Geometry Shader</font></font></h2>

<h3><a id="h3-3-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Increase vertices with Geometry Shader</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, let's draw a polygon. </font><font style="vertical-align: inherit;">To draw a polygon, you need vertices for each corner. </font><font style="vertical-align: inherit;">It can be done by connecting vertices and closing as in the previous section, but this time I will draw a polygon from one vertex using Geometry Shader. </font><font style="vertical-align: inherit;">For details on Geometry Shader, </font><font style="vertical-align: inherit;">refer to "Chapter 6 Growing Grass with Geometry Shader" in </font><font style="vertical-align: inherit;">UnityGraphicsProgramming vol.1 </font></font><a id="fnb-kaiware_unitygraphicsprograming" href="https://freder.io/files/unity2/kaiware007.html#fn-kaiware_unitygraphicsprograming" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Roughly speaking, the Geometry Shader is a shader that can increase the number of vertices, located between the Vertex Shader and the Fragment Shader.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Take a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">look at the</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sample </font><b><font style="vertical-align: inherit;">SamplePolygonLine scene</font></b><font style="vertical-align: inherit;"> .</font></font></p>
<div id="id_Kaiware_2Fkaiware__project__polygonline001" class="image">
<img src="./Chapter 3 _ Application of Geometry Shader for Line Representation_files/kaiware_project_polygonline001.png" alt="SamplePolygonLine scene">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.3: SamplePolygonLine scene
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When you press the play button and run it, the triangle should rotate in the Game view. </font><font style="vertical-align: inherit;">You can increase or decrease the number of triangle angles by selecting the PolygonLine object in the Hierarchy window and moving the Vertex Num slider on the SinglePolygon2D component in the Inspector window. </font><font style="vertical-align: inherit;">The implementation of the SimglePolygon2D class looks like this:</font></font></p>
<div id="kaiware_single_polygon_2d_cs" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 3.3: SinglePolygon2D.cs</font></font></p>
<pre class="list">  using UnityEngine;<font></font>
<font></font>
[ExecuteInEditMode]<font></font>
public class SinglePolygon2D : MonoBehaviour {<font></font>
<font></font>
    [Range(2, 64)]<font></font>
    public int vertexNum = 3;<font></font>
<font></font>
    public Material material;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    private void OnRenderObject ()</font></font></font></font><font></font>
    {<font></font>
        material.SetInt("_VertexNum", vertexNum);<font></font>
        material.SetMatrix("_TRS", transform.localToWorldMatrix);<font></font>
        material.SetPass(0);<font></font>
        Graphics.DrawProcedural(MeshTopology.Points, 1);<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It has almost the same implementation as the RenderWaveLine class. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are two major differences. </font><font style="vertical-align: inherit;">The first is that the first argument of Graphics.DrawProcedural is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">changed</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MeshTopology.LineStrip</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to </font><b><font style="vertical-align: inherit;">MeshTopology.Points</font></b><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The other is that the second argument of Graphics.DrawProcedural is </font><font style="vertical-align: inherit;">fixed at </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In the RenderWaveLine class in the previous section, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MeshTopology.LineStrip</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> was specified </font><font style="vertical-align: inherit;">because the lines were drawn by connecting </font><font style="vertical-align: inherit;">the vertices, but this time I want to pass only one vertex and draw a polygon, so </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MeshTopology.Points</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is specified. </font><font style="vertical-align: inherit;">This is because the minimum number of vertices required for drawing changes depending on the MeshTopology specification, and if it is less than that, nothing is drawn. </font><font style="vertical-align: inherit;">MeshTopology.Lines and MeshTopology.LineStrip are 2 because they are lines, MeshTopology.Triangles are 3 because they are triangles, and MeshTopology.Points are 1 because they are points. </font><font style="vertical-align: inherit;">By the way, in the part of material.SetMatrix ("_TRS", transform.localToWorldMatrix) ;, the matrix converted from the local coordinate system of the GameObject to which the SinglePolygon2D component is assigned to the world coordinate system is passed to the shader. </font><font style="vertical-align: inherit;">By multiplying this by the vertex coordinates in the shader, the transform of the GameObject, that is, the coordinates (position), orientation (rotation), and size (scale) will be reflected in the drawn figure.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, let's take a look at the implementation of SinglePolygonLine.Shader.</font></font></p>
<div id="kaiware_single_polygon_line_shader" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 3.4: SinglePolygonLine.shader</font></font></p>
<pre class="list">Shader "Custom/Single Polygon Line"<font></font>
{<font></font>
  Properties<font></font>
  {<font></font>
    _Color ("Color", Color) = (1,1,1,1)<font></font>
    _Scale ("Scale", Float) = 1<font></font>
    _Speed ("Speed",Float) = 1<font></font>
  }<font></font>
  SubShader<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  {</font></font></font></font><font></font>
    Tags { "RenderType"="Opaque" }<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    LOD 100</font></font></font></font><font></font>
<font></font>
    Pass<font></font>
    {<font></font>
      CGPROGRAM<font></font>
      #pragma vertex vert<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      #pragma geometry geom // Declaration of Geometry Shader</font></font><font></font>
      #pragma fragment frag<font></font>
      #pragma target 4.0<font></font>
<font></font>
      #include "UnityCG.cginc"<font></font>
<font></font>
      #define PI  3.14159265359<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      // Output structure</font></font><font></font>
      struct Output<font></font>
      {<font></font>
        float4 pos : SV_POSITION;<font></font>
      };<font></font>
<font></font>
      float4 _Color;<font></font>
      int _VertexNum;<font></font>
      float _Scale;<font></font>
      float _Speed;<font></font>
      float4x4 _TRS;<font></font>
<font></font>
      Output vert (uint id : SV_VertexID)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      {</font></font></font></font><font></font>
        Output o;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        o.pos = mul (_TRS, float4 (0, 0, 0, 1));</font></font></font></font><font></font>
        return o;<font></font>
      }<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      // Geometry shader</font></font><font></font>
      [maxvertexcount(65)]<font></font>
      void geom(point Output input[1], inout LineStream&lt;Output&gt; outStream)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      {</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        Output o;</font></font></font></font><font></font>
        float rad = 2.0 * PI / (float)_VertexNum;<font></font>
        float time = _Time.y * _Speed;<font></font>
<font></font>
        float4 pos;<font></font>
<font></font>
        for (int i = 0; i &lt;= _VertexNum; i++) {<font></font>
          pos.x = cos(i * rad + time) * _Scale;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
          pos.y = sin (i * rad + time) * _Scale;</font></font></font></font><font></font>
          pos.z = 0;<font></font>
          pos.w = 1;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
          o.pos = UnityObjectToClipPos (pos);</font></font></font></font><font></font>
<font></font>
          outStream.Append(o);<font></font>
        }<font></font>
        outStream.RestartStrip();<font></font>
      }<font></font>
<font></font>
      fixed4 frag (Output i) : SV_Target<font></font>
      {<font></font>
        return _Color;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      }</font></font></font></font><font></font>
      ENDCG<font></font>
    }<font></font>
  }<font></font>
}<font></font>
</pre>
</div>
<p><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> new </font><b><font style="vertical-align: inherit;">#pragma geometry geom</font></b><font style="vertical-align: inherit;"> declaration has been added </font><font style="vertical-align: inherit;">between the </font><b><font style="vertical-align: inherit;">#pragma vertex vert</font></b><font style="vertical-align: inherit;"> and the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">#pragma fragment frag</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This means declaring a Geometry Shader function named geom. </font><font style="vertical-align: inherit;">Vertex Shader's vert sets the coordinates of the vertices to the origin (0,0,0,1) for the time being, and multiplies it by the _TRS matrix (the matrix that converts from the local coordinate system to the world coordinate system) passed from C #. It has become like. </font><font style="vertical-align: inherit;">The coordinates of each vertex of the polygon are calculated in the following Geometry Shader.</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definition of Geometry Shader</font></font></p>
<pre class="emlist"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">  // Geometry shader</font></font><font></font>
  [maxvertexcount(65)]<font></font>
  void geom(point Output input[1], inout LineStream&lt;Output&gt; outStream)<font></font>
</pre>
</div>

<h4><a id="h3-3-1-1"></a>maxvertexcount</h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The maximum number of vertices output from the Geometry Shader. </font><font style="vertical-align: inherit;">This time, VertexNum of the SinglePolygonLine class is used to increase the number to 64 vertices, but since a line connecting the 64th vertex to the 0th vertex is required, 65 is specified.</font></font></p>

<h4><a id="h3-3-1-2"></a>point Output input[1]</h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Represents the input information from Vertex Shader. </font><font style="vertical-align: inherit;">point is a primitive type and means that one vertex is received, Output is a structure name, and input [1] is an array of length 1. </font><font style="vertical-align: inherit;">Since only one vertex is used this time, I specified point and input [1], but when I want to mess with the vertices of a triangular polygon such as a mesh, I use triangle and input [3].</font></font></p>

<h4><a id="h3-3-1-3"></a>inout LineStream&lt;Output&gt; outStream</h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Represents the output information from the Geometry Shader. </font><font style="vertical-align: inherit;">LineStream &lt;Output&gt; means to output the line of the Output structure. </font><font style="vertical-align: inherit;">There are also PointStream and TriangleStream. </font><font style="vertical-align: inherit;">Next is the explanation inside the function.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementation in function</font></font></p>
<pre class="emlist">Output o;<font></font>
float rad = 2.0 * PI / (float)_VertexNum;<font></font>
float time = _Time.y * _Speed;<font></font>
<font></font>
float4 pos;<font></font>
<font></font>
for (int i = 0; i &lt;= _VertexNum; i++) {<font></font>
  pos.x = cos(i * rad + time) * _Scale;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  pos.y = sin (i * rad + time) * _Scale;</font></font></font></font><font></font>
  pos.z = 0;<font></font>
  pos.w = 1;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  o.pos = UnityObjectToClipPos (pos);</font></font></font></font><font></font>
<font></font>
  outStream.Append(o);<font></font>
}<font></font>
<font></font>
outStream.RestartStrip();<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to calculate the coordinates of each vertex of the polygon, 2π (360 degrees) is divided by the number of vertices to obtain the angle of one corner. </font><font style="vertical-align: inherit;">The vertex coordinates are calculated using trigonometric functions (sin, cos) in the loop. </font><font style="vertical-align: inherit;">Output the calculated coordinates as vertices with outStream.Append (o). </font><font style="vertical-align: inherit;">After looping as many times as _VertexNum to output the vertices, outStream.RestartStrip () ends the current strip and starts the next strip. </font><font style="vertical-align: inherit;">As long as you add it with Append (), the lines will be connected as LineStream. </font><font style="vertical-align: inherit;">Execute RestartStrip () to end the current line once. </font><font style="vertical-align: inherit;">The next time Append () is called, it will not connect to the previous line and a new line will start.</font></font></p>
<div class="footnote" epub:type="footnote" id="fn-kaiware_unitygraphicsprograming"><p class="footnote"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[* 2] UnityGraphicsProgramming vol.1 https://indievisuallab.stores.jp/items/59edf11ac8f22c0152002588</font></font></font></font></p></div>

<h2><a id="h3-4"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.4　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Try to make Octahedron Sphere</font></font></h2>

<h3><a id="h3-4-1"></a><span class="secno">3.4.1　</span>Octahedron Sphereとは？</h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A regular octahedron </font><font style="vertical-align: inherit;">is a polyhedron composed of eight equilateral triangles </font><font style="vertical-align: inherit;">, as </font></font><span class="imgref"><a href="https://freder.io/files/unity2/kaiware007.html#id_Kaiware_2Fkaiware__octahedron001"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shown in Fig. 3.4</font></font></a></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Octahedron Sphere is </font><font style="vertical-align: inherit;">a sphere created by dividing the </font></font><a id="fnb-kaiware_slerp" href="https://freder.io/files/unity2/kaiware007.html#fn-kaiware_slerp" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">three</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vertices of an equilateral triangle that make up a regular octahedron by spherical linear interpolation </font><a id="fnb-kaiware_slerp" href="https://freder.io/files/unity2/kaiware007.html#fn-kaiware_slerp" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;">* 3</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Whereas normal linear interpolation interpolates so that two points are connected by a straight line, spherical linear interpolation interpolates </font><font style="vertical-align: inherit;">so that two points pass on a spherical surface as </font></font><span class="imgref"><a href="https://freder.io/files/unity2/kaiware007.html#id_Kaiware_2Fkaiware__slerp__001"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shown in Fig. 3.5</font></font></a></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p>
<div id="id_Kaiware_2Fkaiware__octahedron001" class="image">
<img src="./Chapter 3 _ Application of Geometry Shader for Line Representation_files/kaiware_octahedron001.png" alt="Octahedron" class="width-100per">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.4: Octahedron
</font></font></p>
</div>
<div id="id_Kaiware_2Fkaiware__slerp__001" class="image">
<img src="./Chapter 3 _ Application of Geometry Shader for Line Representation_files/kaiware_slerp_001.png" alt="Octahedron" class="width-100per">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.5: Octahedron
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Take a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">look at the</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sample </font><b><font style="vertical-align: inherit;">Octahedron</font></b><font style="vertical-align: inherit;"> Sample </font><b><font style="vertical-align: inherit;">scene</font></b><font style="vertical-align: inherit;"> .</font></font></p>
<div id="id_Kaiware_2Fkaiware__project__octahedronsphere001" class="image">
<img src="./Chapter 3 _ Application of Geometry Shader for Line Representation_files/kaiware_project_octahedronsphere001.png" alt="SampleWaveLine scene" class="width-100per">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.6: SampleWaveLine scene
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When you press the run button, you should see a slowly rotating octahedron in the center of the Game view. </font><font style="vertical-align: inherit;">Also, if you change the Level slider of the Geometry Octahedron Sphere component of the Single Octahedron Sphere object in the Hierarchy window, the sides of the octahedron will be split and gradually approach the sphere.</font></font></p>
<div class="footnote" epub:type="footnote" id="fn-kaiware_slerp"><p class="footnote"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[* 3] spherical linear interpolation, slerp for short</font></font></p></div>

<h3><a id="h3-4-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.4.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dividing the octahedron in the Geometry Shader</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, let's take a look at the implementation. </font><font style="vertical-align: inherit;">The implementation on the C # side is almost the same as SinplePolygon2D.cs in the previous section, so it will be omitted. </font><font style="vertical-align: inherit;">OctahedronSphere.shader has a long source, so I will explain only in Geometry Shader.</font></font></p>
<div id="kaiware_octahedron_sphere_1" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 3.5: The beginning of the Gometry Shader in OctahedronSphere.shader</font></font></p>
<pre class="list"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Geometry shader</font></font><font></font>
  float4 init_vectors[24];<font></font>
  // 0 : the triangle vertical to (1,1,1)<font></font>
  init_vectors[0] = float4(0, 1, 0, 0);<font></font>
  init_vectors[1] = float4(0, 0, 1, 0);<font></font>
  init_vectors[2] = float4(1, 0, 0, 0);<font></font>
  // 1 : to (1,-1,1)<font></font>
  init_vectors[3] = float4(0, -1, 0, 0);<font></font>
  init_vectors[4] = float4(1, 0, 0, 0);<font></font>
  init_vectors[5] = float4(0, 0, 1, 0);<font></font>
  // 2 : to (-1,1,1)<font></font>
  init_vectors[6] = float4(0, 1, 0, 0);<font></font>
  init_vectors[7] = float4(-1, 0, 0, 0);<font></font>
  init_vectors[8] = float4(0, 0, 1, 0);<font></font>
  // 3 : to (-1,-1,1)<font></font>
  init_vectors[9] = float4(0, -1, 0, 0);<font></font>
  init_vectors[10] = float4(0, 0, 1, 0);<font></font>
  init_vectors[11] = float4(-1, 0, 0, 0);<font></font>
  // 4 : to (1,1,-1)<font></font>
  init_vectors[12] = float4(0, 1, 0, 0);<font></font>
  init_vectors[13] = float4(1, 0, 0, 0);<font></font>
  init_vectors[14] = float4(0, 0, -1, 0);<font></font>
  // 5 : to (-1,1,-1)<font></font>
  init_vectors[15] = float4(0, 1, 0, 0);<font></font>
  init_vectors[16] = float4(0, 0, -1, 0);<font></font>
  init_vectors[17] = float4(-1, 0, 0, 0);<font></font>
  // 6 : to (-1,-1,-1)<font></font>
  init_vectors[18] = float4(0, -1, 0, 0);<font></font>
  init_vectors[19] = float4(-1, 0, 0, 0);<font></font>
  init_vectors[20] = float4(0, 0, -1, 0);<font></font>
  // 7 : to (1,-1,-1)<font></font>
  init_vectors[21] = float4(0, -1, 0, 0);<font></font>
  init_vectors[22] = float4(0, 0, -1, 0);<font></font>
  init_vectors[23] = float4(1, 0, 0, 0);<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, as </font></font><span class="imgref"><a href="https://freder.io/files/unity2/kaiware007.html#id_Kaiware_2Fkaiware__octahedron__triangle001"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shown in Fig. 3.7</font></font></a></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we define a "normalized" octahedron triangular system that is the initial value.</font></font></p>
<div id="id_Kaiware_2Fkaiware__octahedron__triangle001" class="image">
<img src="./Chapter 3 _ Application of Geometry Shader for Line Representation_files/kaiware_octahedron_triangle001.png" alt="Vertex coordinates and triangle of octahedron" class="width-100per">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.7: Octahedron vertex coordinates and triangles
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is defined in float4 because it is defined as a quaternion.</font></font></p>
<div id="kaiware_octahedron_sphere_2" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 3.6: OctahedronSphere.shader Triangle Spherical Linear Interpolation Split Processing Part</font></font></p>
<pre class="list">for (int i = 0; i &lt; 24; i += 3)<font></font>
{<font></font>
  for (int p = 0; p &lt; n; p++)<font></font>
  {<font></font>
    // edge index 1<font></font>
    float4 edge_p1 = qslerp(init_vectors[i],<font></font>
      init_vectors[i + 2], (float)p / n);<font></font>
    float4 edge_p2 = qslerp(init_vectors[i + 1],<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      init_vectors[i + 2], (float)p / n);</font></font></font></font><font></font>
    float4 edge_p3 = qslerp(init_vectors[i],<font></font>
      init_vectors[i + 2], (float)(p + 1) / n);<font></font>
    float4 edge_p4 = qslerp(init_vectors[i + 1],<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      init_vectors[i + 2], (float)(p + 1) / n);</font></font></font></font><font></font>
<font></font>
    for (int q = 0; q &lt; (n - p); q++)<font></font>
    {<font></font>
      // edge index 2<font></font>
      float4 a = qslerp(edge_p1, edge_p2, (float)q / (n - p));<font></font>
      float4 b = qslerp(edge_p1, edge_p2, (float)(q + 1) / (n - p));<font></font>
      float4 c, d;<font></font>
<font></font>
      if(distance(edge_p3, edge_p4) &lt; 0.00001)<font></font>
      {<font></font>
        c = edge_p3;<font></font>
        d = edge_p3;<font></font>
      }<font></font>
      else {<font></font>
        c = qslerp(edge_p3, edge_p4, (float)q / (n - p - 1));<font></font>
        d = qslerp(edge_p3, edge_p4, (float)(q + 1) / (n - p - 1));<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      }</font></font></font></font><font></font>
<font></font>
      output1.pos = UnityObjectToClipPos(input[0].pos + mul(_TRS, a));<font></font>
      output2.pos = UnityObjectToClipPos(input[0].pos + mul(_TRS, b));<font></font>
      output3.pos = UnityObjectToClipPos(input[0].pos + mul(_TRS, c));<font></font>
<font></font>
      outStream.Append(output1);<font></font>
      outStream.Append(output2);<font></font>
      outStream.Append(output3);<font></font>
      outStream.RestartStrip();<font></font>
<font></font>
      if (q &lt; (n - p - 1))<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      {</font></font></font></font><font></font>
        output1.pos = UnityObjectToClipPos(input[0].pos + mul(_TRS, c));<font></font>
        output2.pos = UnityObjectToClipPos(input[0].pos + mul(_TRS, b));<font></font>
        output3.pos = UnityObjectToClipPos(input[0].pos + mul(_TRS, d));<font></font>
<font></font>
        outStream.Append(output1);<font></font>
        outStream.Append(output2);<font></font>
        outStream.Append(output3);<font></font>
        outStream.RestartStrip();<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the part where the triangle is divided by spherical linear interpolation. </font><font style="vertical-align: inherit;">n is the number of triangle divisions. </font><font style="vertical-align: inherit;">edge_p1 and edge_p2 find the starting point of the triangle, and edge_p3 and ege_p4 find the midpoint of the split edge. </font><font style="vertical-align: inherit;">The qslerp function is a function that finds spherical linear interpolation. </font><font style="vertical-align: inherit;">The definition of qslerp is as follows:</font></font></p>
<div id="kaiware_octahedron_sphere_3" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 3.7: Definition of qslerp in Quaternion.cginc</font></font></p>
<pre class="list"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// a: start Quaternion b: target Quaternion t: ratio</font></font><font></font>
float4 qslerp(float4 a, float4 b, float t)<font></font>
{<font></font>
  float4 r;<font></font>
  float t_ = 1 - t;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  float wa, wb;</font></font></font></font><font></font>
  float theta = acos(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);<font></font>
  float sn = sin(theta);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  wa = sin (t_ * theta) / sn;</font></font></font></font><font></font>
  wb = sin(t * theta) / sn;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  rx = wa * ax + wb * bx;</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  ry = wa * ay + wb * by;</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  rz = wa * az + wb * bz;</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  rw = wa * aw + wb * bw;</font></font></font></font><font></font>
  normalize(r);<font></font>
  return r;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
</pre>
</div>

<h4><a id="h3-4-2-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flow of triangle division 1</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, I will explain the flow of the triangle division process. </font><font style="vertical-align: inherit;">As an example, it is the flow when the number of divisions is 2 (n = 2).</font></font></p>
<div id="id_Kaiware_2Fkaiware__triangle__div__001" class="image">
<img src="./Chapter 3 _ Application of Geometry Shader for Line Representation_files/kaiware_triangle_div_001.png" alt="Flow of triangle division process 1, calculation of edge_p1 to p4" class="width-100per">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.8: Triangle division process flow 1, calculation of edges_p1 to p4
</font></font></p>
</div>
<p><span class="imgref"><a href="https://freder.io/files/unity2/kaiware007.html#id_Kaiware_2Fkaiware__triangle__div__001"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 3.8</font></font></a></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shows the following code.</font></font></p>
<div id="kaiware_octahedron_sphere_4" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 3.8: Calculation of edge_p1 to p4</font></font></p>
<pre class="list">for (int p = 0; p &lt; n; p++)<font></font>
{<font></font>
  // edge index 1<font></font>
  float4 edge_p1 = qslerp(init_vectors[i],<font></font>
    init_vectors[i + 2], (float)p / n);<font></font>
  float4 edge_p2 = qslerp(init_vectors[i + 1],<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    init_vectors[i + 2], (float)p / n);</font></font></font></font><font></font>
  float4 edge_p3 = qslerp(init_vectors[i],<font></font>
    init_vectors[i + 2], (float)(p + 1) / n);<font></font>
  float4 edge_p4 = qslerp(init_vectors[i + 1],<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    init_vectors[i + 2], (float)(p + 1) / n);</font></font></font></font><font></font>
</pre>
</div>
<p><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The coordinates of edge_p1 to edge_p4 are obtained from the three points in the </font><b><font style="vertical-align: inherit;">init_vectors</font></b><font style="vertical-align: inherit;"> array. </font><font style="vertical-align: inherit;">When p = 0, p / n = 0/2 = 0 and edge_p1 = init_vectors [0], edge_p2 = init_vectors [1]. </font><font style="vertical-align: inherit;">edge_p3 and edge_p4 are between init_vectors [0] and init_vectors [2] and between init_vectors [1] and init_vectors [2] at (p + 1) / n = (0 + 1) / 2 = 0.5, respectively. .. </font><font style="vertical-align: inherit;">It is a flow that mainly divides the right side of the triangle.</font></font></p>

<h4><a id="h3-4-2-2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flow of triangle division 2</font></font></h4>
<div id="id_Kaiware_2Fkaiware__triangle__div__002" class="image">
<img src="./Chapter 3 _ Application of Geometry Shader for Line Representation_files/kaiware_triangle_div_002.png" alt="Triangle division process flow 2, abcd calculation" class="width-100per">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.9: Triangle division process flow 2, abcd calculation
</font></font></p>
</div>
<p><span class="imgref"><a href="https://freder.io/files/unity2/kaiware007.html#id_Kaiware_2Fkaiware__triangle__div__002"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 3.9</font></font></a></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shows the following code.</font></font></p>
<div id="kaiware_octahedron_sphere_5" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 3.9: Calculation of coordinates a, b, c, d</font></font></p>
<pre class="list">for (int q = 0; q &lt; (n - p); q++)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{</font></font></font></font><font></font>
  // edge index 2<font></font>
  float4 a = qslerp(edge_p1, edge_p2, (float)q / (n - p));<font></font>
  float4 b = qslerp(edge_p1, edge_p2, (float)(q + 1) / (n - p));<font></font>
  float4 c, d;<font></font>
<font></font>
  if(distance(edge_p3, edge_p4) &lt; 0.00001)<font></font>
  {<font></font>
    c = edge_p3;<font></font>
    d = edge_p3;<font></font>
  }<font></font>
  else {<font></font>
    c = qslerp(edge_p3, edge_p4, (float)q / (n - p - 1));<font></font>
    d = qslerp(edge_p3, edge_p4, (float)(q + 1) / (n - p - 1));<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  }</font></font></font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The coordinates of the vertex abcd are calculated using edge_p1 to p4 obtained in the previous section. </font><font style="vertical-align: inherit;">It is a flow that mainly divides the left side of the triangle. </font><font style="vertical-align: inherit;">Depending on the conditions, the coordinates of edge_p3 and edge_p4 will be the same. </font><font style="vertical-align: inherit;">This happens when the right side of the triangle reaches a stage where it can no longer be divided. </font><font style="vertical-align: inherit;">In that case, both c and d take the lower right coordinates of the triangle.</font></font></p>

<h4><a id="h3-4-2-3"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flow of triangle division 3</font></font></h4>
<div id="id_Kaiware_2Fkaiware__triangle__div__003" class="image">
<img src="./Chapter 3 _ Application of Geometry Shader for Line Representation_files/kaiware_triangle_div_003.png" alt="Flow of triangle division process 3, output triangle abc, triangle cbd" class="width-100per">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.10: Flow of triangle division processing 3, output triangle abc, triangle cbd
</font></font></p>
</div>
<p><span class="imgref"><a href="https://freder.io/files/unity2/kaiware007.html#id_Kaiware_2Fkaiware__triangle__div__003"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 3.10</font></font></a></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shows the following code.</font></font></p>
<div id="kaiware_octahedron_sphere_6" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 3.10: Output the triangle connecting the coordinates a, b, c &amp; the triangle connecting the coordinates c, b, d</font></font></p>
<pre class="list">output1.pos = UnityObjectToClipPos(input[0].pos + mul(_TRS, a));<font></font>
output2.pos = UnityObjectToClipPos(input[0].pos + mul(_TRS, b));<font></font>
output3.pos = UnityObjectToClipPos(input[0].pos + mul(_TRS, c));<font></font>
<font></font>
outStream.Append(output1);<font></font>
outStream.Append(output2);<font></font>
outStream.Append(output3);<font></font>
outStream.RestartStrip();<font></font>
<font></font>
if (q &lt; (n - p - 1))<font></font>
{<font></font>
  output1.pos = UnityObjectToClipPos(input[0].pos + mul(_TRS, c));<font></font>
  output2.pos = UnityObjectToClipPos(input[0].pos + mul(_TRS, b));<font></font>
  output3.pos = UnityObjectToClipPos(input[0].pos + mul(_TRS, d));<font></font>
  outStream.Append(output1);<font></font>
  outStream.Append(output2);<font></font>
  outStream.Append(output3);<font></font>
  outStream.RestartStrip();<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Convert the calculated coordinates of a, b, c, d to the coordinates for the screen by multiplying by UnityObjectToClipPos or the world coordinate transformation matrix. </font><font style="vertical-align: inherit;">After that, outStream.Append and outStream.RestartStrip output two triangles connecting a, b, c and c, b, d.</font></font></p>

<h4><a id="h3-4-2-4"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flow of triangle division 4</font></font></h4>
<div id="id_Kaiware_2Fkaiware__triangle__div__004" class="image">
<img src="./Chapter 3 _ Application of Geometry Shader for Line Representation_files/kaiware_triangle_div_004.png" alt="Flow of triangle division processing 4, when q = 1" class="width-100per">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.11: Flow of triangle division processing 4, when q = 1
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When q = 1, a is 1/2 = 0.5, so it is in the middle of edge_p1 and edge_p2, and b is 1/1 = 1, so it is in the position of edge_p2. </font><font style="vertical-align: inherit;">Since c is 1/1 = 1, edge_p4 is calculated, and d is calculated for the time being, but it is not used because it does not fall under the condition of if (q &lt;(n --p -1)). </font><font style="vertical-align: inherit;">Outputs a triangle connecting a, b, and c.</font></font></p>

<h4><a id="h3-4-2-5"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flow of triangle division 5</font></font></h4>
<div id="id_Kaiware_2Fkaiware__triangle__div__005" class="image">
<img src="./Chapter 3 _ Application of Geometry Shader for Line Representation_files/kaiware_triangle_div_005.png" alt="Triangle division process flow 5, when p = 1" class="width-100per">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.12: Triangle division process flow 5, when p = 1
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the flow when the for statement of q ends and p = 1. </font><font style="vertical-align: inherit;">Since p / n = 1/2 = 0.5, edge_p1 is between init_vectors [0] and init_vectors [2], and edge_p2 is between init_vectors [1] and init_vectors [2]. </font><font style="vertical-align: inherit;">The subsequent coordinate calculation of a, b, c, d and the output of the triangles a, b, c are the same as the above processing. </font><font style="vertical-align: inherit;">You have now divided one triangle into four. </font><font style="vertical-align: inherit;">All the triangles of the octahedron are processed up to the above.</font></font></p>

<h3><a id="h3-4-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.4.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bonus</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to this, we have prepared three samples that cannot be introduced due to space limitations, so please take a look if you are interested.</font></font></p>
<ul>
<li>OctahedronSphereのGPUInstancing版（SampleOctahedronSphereInstancingシーン）</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OctahedronSphere standalone version that can be divided into 9 stages (SampleOctahedronSphereMultiVertex scene)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU Instancing version of OctahedronSphere that can be divided up to 9 stages (SampleOctahedronSphereMultiVertexInstancing scene)</font></font></li>
</ul>
<div id="id_Kaiware_2Fkaiware__project__omake001" class="image">
<img src="./Chapter 3 _ Application of Geometry Shader for Line Representation_files/kaiware_project_omake001.png" alt="SampleOctahedronSphereMultiVertexInstancingシーン" class="width-080per">
<p class="caption">
図3.13: SampleOctahedronSphereMultiVertexInstancingシーン
</p>
</div>

<h2><a id="h3-5"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.5　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Summary</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this chapter, we explained the application of Geometry Shader for line representation. </font><font style="vertical-align: inherit;">Geometry Shader usually divides polygons and creates plate polygons of particles, but you should also try to find interesting expressions by using the property of dynamically increasing the number of vertices.</font></font></p></body></html>