<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="en" class="translated-ltr" style="height: 100%;"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <link rel="stylesheet" type="text/css" href="./Chapter 2 _ GPU-Based Trail_files/style.scss">
  <meta name="generator" content="Re:VIEW">
  <title>GPU-Based Trail</title>

			<style>
				img {
					max-width: 80vw;
					max-height: 80vh;
				}
			</style><style>
					.goog-te-banner-frame {
						display: none;
					}
				</style>
			<script>(function(){(function injection() {
  var pageLang = 'ja';
  var userLang = 'en';

  var uid = '1E07F158C6FA4460B352973E9693B329';
  var teId = 'TE_' + uid;
  var cbId = 'TECB_' + uid;

  function show() {
    window.setTimeout(function() {
      window[teId].showBanner(true);
    }, 10);
  }

  function newElem() {
    
  }

  if (window[teId]) {
    show();
  } else {
    if (!window.google || !google.translate ||
        !google.translate.TranslateElement) {
      if (!window[cbId]) {
        window[cbId] = function() {
          window[teId] = newElem();
          show();
        };
      }
      
    }
  }
})();})();</script><script src="https://translate.google.com/translate_a/element.js?cb=TECB_1E07F158C6FA4460B352973E9693B329&amp;client=tee&amp;hl=en"></script><script src="./Chapter 2 _ GPU-Based Trail_files/f.txt"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://translate.googleapis.com/translate_static/css/translateelement.css"><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/translate_static/js/element/main.js"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="./Chapter 2 _ GPU-Based Trail_files/translateelement.css"><script type="text/javascript" charset="UTF-8" src="./Chapter 2 _ GPU-Based Trail_files/main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script><script type="text/javascript" charset="UTF-8" src="./Chapter 2 _ GPU-Based Trail_files/element_main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://translate.googleapis.com/translate_static/css/translateelement.css"><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/translate_static/js/element/main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script></head>
		
<body style="position: relative; min-height: 100%; top: 40px;"><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div>
<h1><a id="h2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chapter 2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GPU-Based Trail</font></font></h1>

<h2><a id="h2-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Introduction</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this chapter, we will show you how to use GPU to create a trail. </font><font style="vertical-align: inherit;">The sample in this chapter is </font><font style="vertical-align: inherit;">"GPU Based Trail" from </font></font><a href="https://github.com/IndieVisualLab/UnityGraphicsProgramming2" class="link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/IndieVisualLab/UnityGraphicsProgramming2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p>

<h3><a id="h2-1-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1.1 What is　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trail?</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The trajectory of a moving object is called a trail. </font><font style="vertical-align: inherit;">In a broad sense, it includes car ruts, ship tracks, ski spurs, etc., but what is impressive in CG is a light trail expression that draws a curve like a car tail lamp or a homing laser in a shooting game. ..</font></font></p>

<h3><a id="h2-1-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unity standard Trail</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Two types of trails are provided as standard in Unity.</font></font></p>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TrailRenderer </font></font></b><a id="fnb-trailrenderer" href="https://freder.io/files/unity2/fuqunaga.html#fn-trailrenderer" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Used to draw the trajectory of GameObject</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trails module </font></font></b><a id="fnb-trailmodule" href="https://freder.io/files/unity2/fuqunaga.html#fn-trailmodule" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">   Used to draw the trajectory of Particles</font></font></li>
</ul>
<div class="footnote" epub:type="footnote" id="fn-trailrenderer"><p class="footnote">[*1] https://docs.unity3d.com/ja/current/Manual/class-TrailRenderer.html</p></div>
<div class="footnote" epub:type="footnote" id="fn-trailmodule"><p class="footnote">[*2] https://docs.unity3d.com/Manual/PartSysTrailsModule.html</p></div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since this chapter focuses on how to create the Trail itself, we will not use these functions, and by implementing it on the GPU, it will be possible to express more than the Trails module.</font></font></p>
<div id="id_fuqunaga_2Fsample__image" class="image">
<img src="./Chapter 2 _ GPU-Based Trail_files/sample_image.png" alt="Sample code execution screen.  Show 10000 Trails">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 2.1: Sample code execution screen. </font><font style="vertical-align: inherit;">Show 10000 Trails
</font></font></p>
</div>

<h2><a id="h2-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creating data</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's create a Trail.</font></font></p>

<h3><a id="h2-2-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Data definition</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are three main structures used.</font></font></p>
<div class="emlist-code">
<p class="caption">GPUTrails.cs</p>
<pre class="emlist">public struct Trail<font></font>
{<font></font>
  public int currentNodeIdx;<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each Trail structure corresponds to one Trail. </font><font style="vertical-align: inherit;">currentNodeIdx Stores the index of the last written Node buffer.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUTrails.cs</font></font></font></font></p>
<pre class="emlist">public struct Node<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{</font></font><font></font>
  public float time;<font></font>
  public Vector3 pos;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Node structures are control points in the Trail. </font><font style="vertical-align: inherit;">It stores the location of the Node and the time it was updated.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUTrails.cs</font></font></p>
<pre class="emlist">public struct Input<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  public Vector3 pos;</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Input structure is the input for one frame from the emitter (the one that leaves the trajectory). </font><font style="vertical-align: inherit;">Here, it's just the position, but I think it would be interesting to add colors and so on.</font></font></p>

<h3><a id="h2-2-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Initialization</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialize the buffer used by GPUTrails.Start ()</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUTrails.cs</font></font></font></font></p>
<pre class="emlist">trailBuffer = new ComputeBuffer(trailNum, Marshal.SizeOf(typeof(Trail)));<font></font>
nodeBuffer = new ComputeBuffer(totalNodeNum, Marshal.SizeOf(typeof(Node)));<font></font>
inputBuffer = new ComputeBuffer(trailNum, Marshal.SizeOf(typeof(Input)));<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initializing trailBuffers for trailNum. </font><font style="vertical-align: inherit;">In other words, this program processes multiple Trails at once. </font><font style="vertical-align: inherit;">In nodeBuffer, Nodes for all Trails are handled together in one buffer. </font><font style="vertical-align: inherit;">Indexes 0 to nodeNum-1 are the first, nodeNum to 2 * nodeNum-1 are the second, and so on. </font><font style="vertical-align: inherit;">The inputBuffer also holds trailNums and manages the input of all trails.</font></font></p>
<div class="emlist-code">
<p class="caption">GPUTrails.cs</p>
<pre class="emlist">var initTrail = new Trail() { currentNodeIdx = -1 };<font></font>
var initNode = new Node() { time = -1 };<font></font>
<font></font>
trailBuffer.SetData(Enumerable.Repeat(initTrail, trailNum).ToArray());<font></font>
nodeBuffer.SetData(Enumerable.Repeat(initNode, totalNodeNum).ToArray());<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The initial value is put in each buffer. </font><font style="vertical-align: inherit;">Set Trail.currentNodeIdx and Node.time to negative numbers, and use them later to determine whether they are unused. </font><font style="vertical-align: inherit;">Since all values ​​of inputBuffer are written in the first update, there is no need to initialize and there is no touch.</font></font></p>

<h3><a id="h2-2-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> How to use Node buffer</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here's how to use the Node buffer.</font></font></p>

<h4><a id="h2-2-3-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initial state</font></font></h4>
<div id="id_fuqunaga_2Fnode0" class="image">
<img src="./Chapter 2 _ GPU-Based Trail_files/node0.png" alt="initial state" class="width-050per">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 2.2: Initial state
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nothing has been entered yet.</font></font></p>

<h4><a id="h2-2-3-2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entering</font></font></h4>
<div id="id_fuqunaga_2Fnode__update" class="image">
<img src="./Chapter 2 _ GPU-Based Trail_files/node_update.png" alt="Entering" class="width-050per">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 2.3: Input
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It will be input one node at a time. </font><font style="vertical-align: inherit;">I have an unused Node.</font></font></p>

<h4><a id="h2-2-3-3"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">loop</font></font></font></font></h4>
<div id="id_fuqunaga_2Fnode__loop" class="image">
<img src="./Chapter 2 _ GPU-Based Trail_files/node_loop.png" alt="loop" class="width-050per">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 2.4: Loop
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When all the Nodes are exhausted, the returning Nodes will be overwritten at the beginning. </font><font style="vertical-align: inherit;">It is used like a ring buffer.</font></font></p>

<h3><a id="h2-2-4"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.4　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Input</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From here, it will be called every frame. </font><font style="vertical-align: inherit;">Enter the position of the emitter to add and update Nodes.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, update the inputBuffer externally. </font><font style="vertical-align: inherit;">This can be any process. </font><font style="vertical-align: inherit;">At first </font></font><code class="inline-code tt">ComputeBuffer.SetData()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it may be easier and better to </font><font style="vertical-align: inherit;">calculate with the CPU </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The sample code moves particles in a simple GPU implementation and treats them as emitters.</font></font></p>
<div class="column">

<h3><a id="column-1"></a>Curl Noise</h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The particles in the sample code move in search of the force received by Curl Noise. </font><font style="vertical-align: inherit;">As you can see, Curl Noise is very convenient because you can easily create pseudo-fluid-like movements. </font><font style="vertical-align: inherit;">Of this book </font></font><a href="https://freder.io/files/unity2/sakota.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- "Neuss' s Arco 's squirrel' s-time commentary for the pseudo-fluid Curl Noise" Chapter 6</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@sakope</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> See all means because I have been described in detail.</font></font></p>
</div>

<h4><a id="h2-2-4-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Emitter update</font></font></h4>
<div class="emlist-code">
<p class="caption">GPUTrailParticles.cs</p>
<pre class="emlist">void Update()<font></font>
{<font></font>
 cs.SetInt(CSPARAM.PARTICLE_NUM, particleNum);<font></font>
 cs.SetFloat(CSPARAM.TIME, Time.time);<font></font>
 cs.SetFloat(CSPARAM.TIME_SCALE, _timeScale);<font></font>
 cs.SetFloat(CSPARAM.POSITION_SCALE, _positionScale);<font></font>
 cs.SetFloat(CSPARAM.NOISE_SCALE, _noiseScale);<font></font>
<font></font>
 var kernelUpdate = cs.FindKernel(CSPARAM.UPDATE);<font></font>
 cs.SetBuffer(kernelUpdate, CSPARAM.PARTICLE_BUFFER_WRITE, _particleBuffer);<font></font>
<font></font>
 var updateThureadNum = new Vector3(particleNum, 1f, 1f);<font></font>
 ComputeShaderUtil.Dispatch(cs, kernelUpdate, updateThureadNum);<font></font>
<font></font>
<font></font>
 var kernelInput = cs.FindKernel(CSPARAM.WRITE_TO_INPUT);<font></font>
 cs.SetBuffer(kernelInput, CSPARAM.PARTICLE_BUFFER_READ, _particleBuffer);<font></font>
 cs.SetBuffer(kernelInput, CSPARAM.INPUT_BUFFER, trails.inputBuffer);<font></font>
<font></font>
 var inputThreadNum = new Vector3(particleNum, 1f, 1f);<font></font>
 ComputeShaderUtil.Dispatch(cs, kernelInput, inputThreadNum);<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I'm running two kernels.</font></font></p>
<dl>
<dt>CSPARAM.UPDATE</dt>
<dd><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I'm updating the particles used as emitters.</font></font></dd>
<dt>CSPARAM.WRITE_TO_INPUT</dt>
<dd><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The current position of the emitter is written to inputBuffer. </font><font style="vertical-align: inherit;">Use this as a Trail entry.</font></font></dd>
</dl>

<h4><a id="h2-2-4-2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Input to Trail</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, let's update nodeBuffer by referring to inputBuffer.</font></font></p>
<div class="emlist-code">
<p class="caption">GPUTrailParticles.cs</p>
<pre class="emlist">void LateUpdate()<font></font>
{<font></font>
  cs.SetFloat(CSPARAM.TIME, Time.time);<font></font>
  cs.SetFloat(CSPARAM.UPDATE_DISTANCE_MIN, updateDistaceMin);<font></font>
  cs.SetInt(CSPARAM.TRAIL_NUM, trailNum);<font></font>
  cs.SetInt(CSPARAM.NODE_NUM_PER_TRAIL, nodeNum);<font></font>
<font></font>
  var kernel = cs.FindKernel(CSPARAM.CALC_INPUT);<font></font>
  cs.SetBuffer(kernel, CSPARAM.TRAIL_BUFFER, trailBuffer);<font></font>
  cs.SetBuffer(kernel, CSPARAM.NODE_BUFFER, nodeBuffer);<font></font>
  cs.SetBuffer(kernel, CSPARAM.INPUT_BUFFER, inputBuffer);<font></font>
<font></font>
  ComputeShaderUtil.Dispatch(cs, kernel, new Vector3(trailNum, 1f, 1f));<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the CPU side, all you have to do is Dispatch () ComputeShader, passing the required parameters. </font><font style="vertical-align: inherit;">The processing on the main ComputeShader side is as follows.</font></font></p>
<div class="emlist-code">
<p class="caption">GPUTrail.compute</p>
<pre class="emlist">[numthreads(256,1,1)]<font></font>
void CalcInput (uint3 id : SV_DispatchThreadID)<font></font>
{<font></font>
  uint trailIdx = id.x;<font></font>
  if ( trailIdx &lt; _TrailNum)<font></font>
  {<font></font>
        Trail trail = _TrailBuffer[trailIdx];<font></font>
        Input input = _InputBuffer[trailIdx];<font></font>
        int currentNodeIdx = trail.currentNodeIdx;<font></font>
<font></font>
        bool update = true;<font></font>
        if ( trail.currentNodeIdx &gt;= 0 )<font></font>
        {<font></font>
          Node node = GetNode(trailIdx, currentNodeIdx);<font></font>
          float dist = distance(input.position, node.position);<font></font>
          update = dist &gt; _UpdateDistanceMin;<font></font>
        }<font></font>
<font></font>
        if ( update )<font></font>
        {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
          Node node;</font></font><font></font>
          node.time = _Time;<font></font>
          node.position = input.position;<font></font>
<font></font>
          currentNodeIdx++;<font></font>
          currentNodeIdx %= _NodeNumPerTrail;<font></font>
<font></font>
          // write new node<font></font>
          SetNode(node, trailIdx, currentNodeIdx);<font></font>
<font></font>
          // update trail<font></font>
          trail.currentNodeIdx = currentNodeIdx;<font></font>
          _TrailBuffer[trailIdx] = trail;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        }</font></font><font></font>
  }<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's take a closer look.</font></font></p>
<div class="emlist-code">
<pre class="emlist">uint trailIdx = id.x;<font></font>
if ( trailIdx &lt; _TrailNum)<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, I'm using the argument id as the Trail index. </font><font style="vertical-align: inherit;">Due to the number of threads, it may be called with ids equal to or greater than the number of Trails, so I play something outside the range with an if statement.</font></font></p>
<div class="emlist-code">
<pre class="emlist">int currentNodeIdx = trail.currentNodeIdx;<font></font>
<font></font>
bool update = true;<font></font>
if ( trail.currentNodeIdx &gt;= 0 )<font></font>
{<font></font>
    Node node = GetNode(trailIdx, currentNodeIdx);<font></font>
    update = distance(input.position, node.position) &gt; _UpdateDistanceMin;<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"></font><code class="inline-code tt">Trail.currentNodeIdx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I am checking </font><font style="vertical-align: inherit;">next </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If it is negative, it is an unused Trail.</font></font></p>
<p><code class="inline-code tt"> GetNode() </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is a function that gets the specified Node from _NodeBuffer. </font><font style="vertical-align: inherit;">Since the index calculation is the source of mistakes, it is functionalized.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Trail, which is already in use, compares the distance between the latest Node and the input position and states that </font></font><code class="inline-code tt">_UpdateDistanceMin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it will be updated if it is farther away and will not be updated if it is closer. </font><font style="vertical-align: inherit;">Although it depends on the behavior of the emitter, the input at almost the same position as the previous Node is usually in a state of being almost stopped and moving with a slight error, so if you try to generate a Trail by converting these into Nodes in a lawful manner, between consecutive Nodes The direction is very different and it is often quite dirty. </font><font style="vertical-align: inherit;">Therefore, at a very short distance, I dare to skip without adding Node.</font></font></p>
<div class="emlist-code">
<p class="caption">GPUTrail.compute</p>
<pre class="emlist">if ( update )<font></font>
{<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  Node node;</font></font><font></font>
  node.time = _Time;<font></font>
  node.position = input.position;<font></font>
<font></font>
  currentNodeIdx++;<font></font>
  currentNodeIdx %= _NodeNumPerTrail;<font></font>
<font></font>
  // write new node<font></font>
  SetNode(node, trailIdx, currentNodeIdx);<font></font>
<font></font>
  // update trail<font></font>
  trail.currentNodeIdx = currentNodeIdx;<font></font>
  _TrailBuffer[trailIdx] = trail;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, I'm updating _NodeBuffer and _TrailBuffer. </font><font style="vertical-align: inherit;">The Trail stores the index of the entered Node as currentNodeIdx. </font><font style="vertical-align: inherit;">When the number of Nodes per Trail is exceeded, it is returned to zero so that it becomes a ring buffer. </font><font style="vertical-align: inherit;">Node stores the time and position of the input.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, this completes the logical processing of Trail. </font><font style="vertical-align: inherit;">Next, let's look at the process of drawing from this information.</font></font></p>

<h2><a id="h2-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Drawing</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drawing a Trail is basically a process of connecting Nodes with a line. </font><font style="vertical-align: inherit;">Here, I will try to keep the individual trails as simple as possible and focus on quantity. </font><font style="vertical-align: inherit;">Therefore, we want to reduce the number of polygons as much as possible, so we will generate the line as a plate polygon facing the camera.</font></font></p>

<h3><a id="h2-3-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.3.1</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generation of plate polygons </font><span class="secno"><font style="vertical-align: inherit;">facing the　</font></span><font style="vertical-align: inherit;"> camera</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The method to generate the plate polygon facing the camera is as follows.</font></font></p>
<div id="id_fuqunaga_2Fpolygon0" class="image">
<img src="./Chapter 2 _ GPU-Based Trail_files/polygon0.png" alt="Node column" class="width-070per">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 2.5: Node column
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From a Node column like this</font></font></p>
<div id="id_fuqunaga_2Fpolygon1" class="image">
<img src="./Chapter 2 _ GPU-Based Trail_files/polygon1.png" alt="Vertices generated from Node" class="width-070per">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 2.6: Vertices generated from Node
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finds the vertices that are moved from each node by the specified width in the direction perpendicular to the line of sight.</font></font></p>
<div id="id_fuqunaga_2Fpolygon2" class="image">
<img src="./Chapter 2 _ GPU-Based Trail_files/polygon2.png" alt="Polygonization" class="width-070per">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 2.7: Polygonization
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connect the generated vertices to make a polygon. </font><font style="vertical-align: inherit;">Let's take a look at the actual code.</font></font></p>

<h3><a id="h2-3-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.3.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CPU side</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the CPU side, the process is simply to pass the parameters to the material and perform DrawProcedual ().</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUTrailRenderer.cs</font></font></font></font></p>
<pre class="emlist"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void OnRenderObject ()</font></font></font></font><font></font>
{<font></font>
  _material.SetInt(GPUTrails.CSPARAM.NODE_NUM_PER_TRAIL, trails.nodeNum);<font></font>
  _material.SetFloat(GPUTrails.CSPARAM.LIFE, trails._life);<font></font>
  _material.SetBuffer(GPUTrails.CSPARAM.TRAIL_BUFFER, trails.trailBuffer);<font></font>
  _material.SetBuffer(GPUTrails.CSPARAM.NODE_BUFFER, trails.nodeBuffer);<font></font>
  _material.SetPass(0);<font></font>
<font></font>
  var nodeNum = trails.nodeNum;<font></font>
  var trailNum = trails.trailNum;<font></font>
  Graphics.DrawProcedural(MeshTopology.Points, nodeNum, trailNum);<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameters </font></font><code class="inline-code tt">trails._life</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that </font><font style="vertical-align: inherit;">have not appeared until now </font><font style="vertical-align: inherit;">have appeared. </font><font style="vertical-align: inherit;">This is used for processing that compares the lifetime of the Node with the generation time that the Node itself has, and makes it transparent after this amount of time. </font><font style="vertical-align: inherit;">By doing this, you can express that the end of the trail disappears smoothly.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since there are no meshes or polygons to input, </font></font><code class="inline-code tt">Graphics.DrawProcedural()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we issue a command to draw a model with trails.nodeNum vertices in batches of trails.trailNum instances.</font></font></p>

<h3><a id="h2-3-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.3.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GPU side</font></font></h3>

<h4><a id="h2-3-3-1"></a>vertex shader</h4>
<div class="emlist-code">
<p class="caption">GPUTrails.shader</p>
<pre class="emlist">vs_out vert (uint id : SV_VertexID, uint instanceId : SV_InstanceID)<font></font>
{<font></font>
  vs_out Out;<font></font>
  Trail trail = _TrailBuffer[instanceId];<font></font>
  int currentNodeIdx = trail.currentNodeIdx;<font></font>
<font></font>
  Node node0 = GetNode(instanceId, id-1);<font></font>
  Node node1 = GetNode(instanceId, id); // current<font></font>
  Node node2 = GetNode(instanceId, id+1);<font></font>
  Node node3 = GetNode(instanceId, id+2);<font></font>
<font></font>
  bool isLastNode = (currentNodeIdx == (int)id);<font></font>
<font></font>
  if ( isLastNode || !IsValid(node1))<font></font>
  {<font></font>
        node0 = node1 = node2 = node3 = GetNode(instanceId, currentNodeIdx);<font></font>
  }<font></font>
<font></font>
  float3 pos1 = node1.position;<font></font>
  float3 pos0 = IsValid(node0) ? node0.position : pos1;<font></font>
  float3 pos2 = IsValid(node2) ? node2.position : pos1;<font></font>
  float3 pos3 = IsValid(node3) ? node3.position : pos2;<font></font>
<font></font>
  Out.pos = float4(pos1, 1);<font></font>
  Out.posNext = float4(pos2, 1);<font></font>
<font></font>
  Out.dir = normalize(pos2 - pos0);<font></font>
  Out.dirNext = normalize(pos3 - pos1);<font></font>
<font></font>
  float ageRate = saturate((_Time.y - node1.time) / _Life);<font></font>
  float ageRateNext = saturate((_Time.y - node2.time) / _Life);<font></font>
  Out.col = lerp(_StartColor, _EndColor, ageRate);<font></font>
  Out.colNext = lerp(_StartColor, _EndColor, ageRateNext);<font></font>
<font></font>
  return Out;<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First is the processing of vertex shader. </font><font style="vertical-align: inherit;">Outputs information about the current Node and the next Node corresponding to this thread.</font></font></p>
<div class="emlist-code">
<p class="caption">GPUTrails.shader</p>
<pre class="emlist">Node node0 = GetNode(instanceId, id-1);<font></font>
Node node1 = GetNode(instanceId, id); // current<font></font>
Node node2 = GetNode(instanceId, id+1);<font></font>
Node node3 = GetNode(instanceId, id+2);<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The current node is set to node1, and a total of four nodes are referenced, including the previous node0, the previous node2, and the second node3.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUTrails.shader</font></font></font></font></p>
<pre class="emlist">bool isLastNode = (currentNodeIdx == (int)id);<font></font>
<font></font>
if ( isLastNode || !IsValid(node1))<font></font>
{<font></font>
  node0 = node1 = node2 = node3 = GetNode(instanceId, currentNodeIdx);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the current Node is terminal or has not yet been entered, treat nodes 0-3 as a copy of the terminal Node. </font><font style="vertical-align: inherit;">In other words, all Nodes beyond the end that have no information yet are treated as "folded" to the end. </font><font style="vertical-align: inherit;">By doing this, it can be sent as it is to the subsequent polygon generation processing.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUTrails.shader</font></font></font></font></p>
<pre class="emlist">float3 pos1 = node1.position;<font></font>
float3 pos0 = IsValid(node0) ? node0.position : pos1;<font></font>
float3 pos2 = IsValid(node2) ? node2.position : pos1;<font></font>
float3 pos3 = IsValid(node3) ? node3.position : pos2;<font></font>
<font></font>
Out.pos = float4(pos1, 1);<font></font>
Out.posNext = float4(pos2, 1);<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, extract the location information from the four Nodes. </font><font style="vertical-align: inherit;">Please note that all but the current Node (node1) may be blank. </font><font style="vertical-align: inherit;">It may be a little surprising that node0 is not entered, but this is possible because node0 points to the last node in the buffer going back in the ring buffer when currentNodeIdx == 0. </font><font style="vertical-align: inherit;">Again, copy the location of node1 to fold it to the same location. </font><font style="vertical-align: inherit;">The same applies to nodes2 and 3. </font><font style="vertical-align: inherit;">Of these, pos1 and pos2 are output toward the geometry shader.</font></font></p>
<div class="emlist-code">
<p class="caption">GPUTrails.shader</p>
<pre class="emlist">Out.dir = normalize(pos2 - pos0);<font></font>
Out.dirNext = normalize(pos3 - pos1);<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Furthermore, the direction vector of pos0 → pos2 is output as the tangent at pos1, and the direction vector of pos1 → pos3 is output as the tangent at pos2.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUTrails.shader</font></font></font></font></p>
<pre class="emlist">float ageRate = saturate((_Time.y - node1.time) / _Life);<font></font>
float ageRateNext = saturate((_Time.y - node2.time) / _Life);<font></font>
Out.col = lerp(_StartColor, _EndColor, ageRate);<font></font>
Out.colNext = lerp(_StartColor, _EndColor, ageRateNext);<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, the color is calculated by comparing the write time of node1 and node2 with the current time.</font></font></p>

<h4><a id="h2-3-3-2"></a>geometry shader</h4>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUTrails.shader</font></font></font></font></p>
<pre class="emlist">[maxvertexcount(4)]<font></font>
void geom (point vs_out input[1], inout TriangleStream&lt;gs_out&gt; outStream)<font></font>
{<font></font>
  gs_out output0, output1, output2, output3;<font></font>
  float3 pos = input[0].pos;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  float3 dir = input [0] .dir;</font></font></font></font><font></font>
  float3 posNext = input[0].posNext;<font></font>
  float3 dirNext = input[0].dirNext;<font></font>
<font></font>
  float3 camPos = _WorldSpaceCameraPos;<font></font>
  float3 toCamDir = normalize(camPos - pos);<font></font>
  float3 sideDir = normalize(cross(toCamDir, dir));<font></font>
<font></font>
  float3 toCamDirNext = normalize(camPos - posNext);<font></font>
  float3 sideDirNext = normalize(cross(toCamDirNext, dirNext));<font></font>
  float width = _Width * 0.5;<font></font>
<font></font>
  output0.pos = UnityWorldToClipPos(pos + (sideDir * width));<font></font>
  output1.pos = UnityWorldToClipPos(pos - (sideDir * width));<font></font>
  output2.pos = UnityWorldToClipPos(posNext + (sideDirNext * width));<font></font>
  output3.pos = UnityWorldToClipPos(posNext - (sideDirNext * width));<font></font>
<font></font>
  output0.col =<font></font>
  output1.col = input[0].col;<font></font>
  output2.col =<font></font>
  output3.col = input[0].colNext;<font></font>
<font></font>
  outStream.Append (output0);<font></font>
  outStream.Append (output1);<font></font>
  outStream.Append (output2);<font></font>
  outStream.Append (output3);<font></font>
<font></font>
  outStream.RestartStrip();<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next is the processing of geometry shader. </font><font style="vertical-align: inherit;">The polygon is finally generated from the information for two Nodes passed from the vertex shader. </font><font style="vertical-align: inherit;">From 2 pos and dir, 4 positions = quadrangle are obtained and output as TriangleStream.</font></font></p>
<div class="emlist-code">
<p class="caption">GPUTrails.shader</p>
<pre class="emlist">float3 camPos = _WorldSpaceCameraPos;<font></font>
float3 toCamDir = normalize(camPos - pos);<font></font>
float3 sideDir = normalize(cross(toCamDir, dir));<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The outer product of the direction vector (toCameraDir) from pos to the camera and the tangent vector (dir) is obtained, and this is set as the width of the line (sideDir).</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUTrails.shader</font></font></font></font></p>
<pre class="emlist">output0.pos = UnityWorldToClipPos(pos + (sideDir * width));<font></font>
output1.pos = UnityWorldToClipPos(pos - (sideDir * width));<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Find the vertices that have moved in the positive and negative sideDir directions. </font><font style="vertical-align: inherit;">Here, we have completed the coordinate transformation to make it a Clip coordinate system and pass it to the fragment shader. </font><font style="vertical-align: inherit;">By performing the same processing for posNext, a total of four vertices were obtained.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUTrails.shader</font></font></font></font></p>
<pre class="emlist">output0.col =<font></font>
output1.col = input[0].col;<font></font>
output2.col =<font></font>
output3.col = input[0].colNext;<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add color to each vertex to complete.</font></font></p>

<h4><a id="h2-3-3-3"></a>fragment shader</h4>
<div class="emlist-code">
<p class="caption">GPUTrails.shader</p>
<pre class="emlist">fixed4 frag (gs_out In) : COLOR<font></font>
{<font></font>
  return In.col;<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, the fragment shader. </font><font style="vertical-align: inherit;">It's as simple as it gets. </font><font style="vertical-align: inherit;">It just outputs the color (laughs)</font></font></p>

<h2><a id="h2-4"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.4　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Application</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I think that the Trail has been generated. </font><font style="vertical-align: inherit;">This time, the processing was only for colors, but I think that it can be applied in various ways, such as adding textures and changing the width. </font><font style="vertical-align: inherit;">Also, as the source code is separated from GPUTrails.cs and GPUTRailsRenderer.cs, the GPUTrails.shader side is just a process of drawing by looking at the buffer, so if you prepare _TrailBuffer and _NodeBuffer, it is not limited to Trail but actually line-shaped. It can be used for display. </font><font style="vertical-align: inherit;">This time it was just a trail added to _NodeBuffer, but I think that by updating all Nodes every frame, it is possible to express something like a tentacle.</font></font></p>

<h2><a id="h2-5"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.5　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Summary</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This chapter has provided the simplest possible example of Trail's GPU implementation. </font><font style="vertical-align: inherit;">While debugging becomes difficult with the GPU, it enables overwhelming physical expression that cannot be done with the CPU. </font><font style="vertical-align: inherit;">I hope that as many people as possible can experience that "Uhyo!" Feeling through this book. </font><font style="vertical-align: inherit;">Also, I think Trail is an expression of an interesting area with a wide range of applications, such as "displaying a model" and "drawing with an algorithm in screen space". </font><font style="vertical-align: inherit;">I think that the understanding gained in this process will be useful when programming various video expressions, not limited to Trail.</font></font></p><div id="goog-gt-tt" class="skiptranslate" dir="ltr"><div style="padding: 8px;"><div><div class="logo"><img src="./Chapter 2 _ GPU-Based Trail_files/translate_24dp.png" width="20" height="20" alt="Google Translate"></div></div></div><div class="top" style="padding: 8px; float: left; width: 100%;"><h1 class="title gray">Original text</h1></div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">Contribute a better translation</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>


<div class="goog-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div><iframe frameborder="0" class="goog-te-menu-frame skiptranslate" title="Language Translate Widget" style="visibility: visible; box-sizing: content-box; width: 1001px; height: 263px; display: none;" src="./Chapter 2 _ GPU-Based Trail_files/saved_resource(1).html"></iframe><div id="goog-gt-tt" class="skiptranslate" dir="ltr"><div style="padding: 8px;"><div><div class="logo"><img src="https://www.gstatic.com/images/branding/product/1x/translate_24dp.png" width="20" height="20" alt="Google Translate"></div></div></div><div class="top" style="padding: 8px; float: left; width: 100%;"><h1 class="title gray">Original text</h1></div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">Contribute a better translation</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div><iframe frameborder="0" class="goog-te-menu-frame skiptranslate" title="Language Translate Widget" style="visibility: visible; box-sizing: content-box; width: 197px; height: 69px; display: none;" src="./Chapter 2 _ GPU-Based Trail_files/saved_resource(2).html"></iframe><div id="goog-gt-tt" class="skiptranslate" dir="ltr"><div style="padding: 8px;"><div><div class="logo"><img src="https://www.gstatic.com/images/branding/product/1x/translate_24dp.png" width="20" height="20" alt="Google Translate"></div></div></div><div class="top" style="padding: 8px; float: left; width: 100%;"><h1 class="title gray">Original text</h1></div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">Contribute a better translation</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div><div class="goog-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div><div id="goog-gt-tt" class="skiptranslate" dir="ltr"><div style="padding: 8px;"><div><div class="logo"><img src="https://www.gstatic.com/images/branding/product/1x/translate_24dp.png" width="20" height="20" alt="Google Translate"></div></div></div><div class="top" style="padding: 8px; float: left; width: 100%;"><h1 class="title gray">Original text</h1></div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">Contribute a better translation</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div><div class="goog-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div><div class="goog-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div><iframe frameborder="0" class="goog-te-menu-frame skiptranslate" title="Language Translate Widget" style="visibility: visible; box-sizing: content-box; width: 1001px; height: 263px; display: none;"></iframe><iframe frameborder="0" class="goog-te-menu-frame skiptranslate" title="Language Translate Widget" style="visibility: visible; box-sizing: content-box; width: 197px; height: 69px; display: none;"></iframe><iframe frameborder="0" class="goog-te-menu-frame skiptranslate" title="Language Translate Widget" style="visibility: visible; box-sizing: content-box; width: 1001px; height: 263px; display: none;"></iframe><iframe frameborder="0" class="goog-te-menu-frame skiptranslate" title="Language Translate Widget" style="visibility: visible; box-sizing: content-box; width: 197px; height: 69px; display: none;"></iframe></body></html>