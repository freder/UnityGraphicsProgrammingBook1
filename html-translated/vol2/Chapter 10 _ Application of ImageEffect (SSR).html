<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="en" class="translated-ltr" style="height: 100%;"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <link rel="stylesheet" type="text/css" href="./Chapter 10 _ Application of ImageEffect (SSR)_files/style.scss">
  <meta name="generator" content="Re:VIEW">
  <title>ImageEffect application (SSR)</title>

			<style>
				img {
					max-width: 80vw;
					max-height: 80vh;
				}
			</style><style>
					.goog-te-banner-frame {
						display: none;
					}
				</style>
			<script>(function(){(function injection() {
  var pageLang = 'ja';
  var userLang = 'en';

  var uid = '1E07F158C6FA4460B352973E9693B329';
  var teId = 'TE_' + uid;
  var cbId = 'TECB_' + uid;

  function show() {
    window.setTimeout(function() {
      window[teId].showBanner(true);
    }, 10);
  }

  function newElem() {
    
  }

  if (window[teId]) {
    show();
  } else {
    if (!window.google || !google.translate ||
        !google.translate.TranslateElement) {
      if (!window[cbId]) {
        window[cbId] = function() {
          window[teId] = newElem();
          show();
        };
      }
      
    }
  }
})();})();</script><script src="https://translate.google.com/translate_a/element.js?cb=TECB_1E07F158C6FA4460B352973E9693B329&amp;client=tee&amp;hl=en"></script><script src="./Chapter 10 _ Application of ImageEffect (SSR)_files/f.txt"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://translate.googleapis.com/translate_static/css/translateelement.css"><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/translate_static/js/element/main.js"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="./Chapter 10 _ Application of ImageEffect (SSR)_files/translateelement.css"><script type="text/javascript" charset="UTF-8" src="./Chapter 10 _ Application of ImageEffect (SSR)_files/main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script><script type="text/javascript" charset="UTF-8" src="./Chapter 10 _ Application of ImageEffect (SSR)_files/element_main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://translate.googleapis.com/translate_static/css/translateelement.css"><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/translate_static/js/element/main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script></head>
		
<body style="position: relative; min-height: 100%; top: 40px;"><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div>
<h1><a id="h10"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chapter 10 Application of　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ImageEffect (SSR)</font></font></h1>

<h2><a id="h10-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Introduction</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This chapter describes the theory and implementation of Screen Space Reflection as an application of ImageEffect. </font><font style="vertical-align: inherit;">When constructing a three-dimensional space, reflections and reflections are useful for expressing reality along with shadows. </font><font style="vertical-align: inherit;">However, despite the simplicity of the phenomena we see in our daily lives, reflections and reflections are enormous calculations when trying to faithfully reproduce physical phenomena using ray tracing (described later) in the world of 3DCG. It is also an expression that requires quantity. </font><font style="vertical-align: inherit;">Recently, Octan Renderer has become available in Unity, and when producing as a video work, it has become possible to produce quite photorealistic effects in Unity, but in real-time rendering it is still necessary to devise a pseudo reproduction. There is.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are several techniques for expressing reflections with real-time rendering, but in this chapter we will introduce a technique called Screen Space Reflection (SSR) that belongs to the post-effects.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As for the structure of this chapter, we will first explain the blur processing used in the sample program in advance as a shoulder break-in for post effects. </font><font style="vertical-align: inherit;">After that, I will explain SSR while breaking it down into the smallest possible processing units.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, the sample of this chapter is </font><font style="vertical-align: inherit;">in "SSR" of </font></font><br><a href="https://github.com/IndieVisualLab/UnityGraphicsProgramming2" class="link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/IndieVisualLab/UnityGraphicsProgramming2</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p>

<h2><a id="h10-2"></a><span class="secno">10.2　</span>Blur</h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this section, we will explain the blur processing. </font><font style="vertical-align: inherit;">If you include anti-aliasing, you need to understand the procedure that blurring is very complicated, but this time it is a basic process because it is a shoulder break-in. </font><font style="vertical-align: inherit;">The basis of blur processing is </font><font style="vertical-align: inherit;">to homogenize the color of texels by multiplying </font><font style="vertical-align: inherit;">each texel (pixels after rasterization </font></font><a id="fnb-texel" href="https://freder.io/files/unity2/komietty.html#fn-texel" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) of the </font><font style="vertical-align: inherit;">image to be processed by </font><font style="vertical-align: inherit;">a matrix that refers to the texels around it. I will continue. </font><font style="vertical-align: inherit;">The matrix that references the texels around this is called the kernel. </font><font style="vertical-align: inherit;">The kernel is a matrix that determines the proportion of texel colors mixed.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gaussian blur is the most commonly used blur treatment. </font><font style="vertical-align: inherit;">As the name implies, this refers to the process of using a Gaussian distribution in the kernel. </font><font style="vertical-align: inherit;">Read the Gaussian Blur implementation diagonally to get a feel for how it works in post-effects.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Gaussian kernel mixes the brightness around the pixel to be processed at a rate that follows a Gaussian distribution. </font><font style="vertical-align: inherit;">By doing this, it is possible to suppress the blurring of the contour part where the brightness changes non-linearly.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a review of mathematics, the Gaussian distribution can be expressed by the following formula.</font></font></p>
<div class="equation">
<pre>G\left( x\right) =\dfrac {1}{\sqrt {2 \pi \sigma ^{2}}}\exp \left( -\dfrac {x^{2}}{2\sigma ^{2}}\right)
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the Gaussian distribution can be approximated to the binomial distribution here, the Gaussian distribution can be substituted by the combination of weighting according to the binomial distribution as shown below (see footnote </font></font><a id="fnb-binomial" href="https://freder.io/files/unity2/komietty.html#fn-binomial" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for the approximation of the Gaussian and binomial distributions </font><font style="vertical-align: inherit;">).</font></font></p>
<div class="emlist-code">
<p class="caption">GaussianBlur.shader</p>
<pre class="emlist">float4 x_blur (v2f i) : SV_Target<font></font>
{<font></font>
  float weight [5] = { 0.2270270, 0.1945945, 0.1216216, 0.0540540, 0.0162162 };<font></font>
  float offset [5] = { 0.0, 1.0, 2.0, 3.0, 4.0 };<font></font>
  float2 size = _MainTex_TexelSize;<font></font>
  fixed4 col = tex2D(_MainTex, i.uv) * weight[0];<font></font>
  for(int j=1; j&lt;5; j++)<font></font>
  {<font></font>
    col += tex2D(_MainTex, i.uv + float2(offset[j], 0) * size) * weight[j];<font></font>
    col += tex2D(_MainTex, i.uv - float2(offset[j], 0) * size) * weight[j];<font></font>
  }<font></font>
  return col;<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The above code is only in the x direction, but the processing is almost the same in the y direction. </font><font style="vertical-align: inherit;">Here, the blur in the x and y directions is divided into two directions, and the number of brightness acquisitions </font><font style="vertical-align: inherit;">is reduced </font><font style="vertical-align: inherit;">from </font><span class="equation"><font style="vertical-align: inherit;">n * </font></span></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = n ^ 2</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> times to </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n * 2 + 1 = 2n + 1</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> times. Because you can.</font></font></p>
<div id="id_komietty_2Fssr__blur" class="image">
<img src="./Chapter 10 _ Application of ImageEffect (SSR)_files/ssr_blur.png" alt="Confirmation that blur is applied correctly by synthesizing Blur in each direction">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 10.1: Confirmation that Blur composition in each direction correctly blurs
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the script side, </font></font><code class="inline-code tt">OnRenderImage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blit alternately between src and temporary RenderTexture in each direction of xy, and finally Blit from src to dst and output. </font><font style="vertical-align: inherit;">On MacOS, Blitt was possible only with src, but on Windows, the result was not output, so </font></font><code class="inline-code tt">RenderTexture.GetTemporary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I am using. </font><font style="vertical-align: inherit;">(For OnRenderImage and Blit, refer to the introduction to ImageEffect in the previous chapter.)</font></font></p>
<div class="emlist-code">
<p class="caption">GaussianBlur.cs</p>
<pre class="emlist"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void OnRenderImage (RenderTexture src, RenderTexture dst)</font></font></font></font><font></font>
{<font></font>
  var rt = RenderTexture.GetTemporary(src.width, src.height, 0, src.format);<font></font>
<font></font>
  for (int i = 0; i &lt; blurNum; i++)<font></font>
  {<font></font>
    Graphics.Blit(src, rt, mat, 0);<font></font>
    Graphics.Blit(rt, src, mat, 1);<font></font>
  }<font></font>
  Graphics.Blit(src, dst);<font></font>
<font></font>
  RenderTexture.ReleaseTemporary(rt);<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the end of the explanation of Gaussian blur. </font><font style="vertical-align: inherit;">Now that you have a sense of how post-effects are performed, I will explain SSR from the next section.</font></font></p>

<h2><a id="h10-3"></a><span class="secno">10.3　</span>SSR</h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSR is a technique that attempts to reproduce reflections and reflections within the range of post effects. </font><font style="vertical-align: inherit;">All that is required for SSR is the image itself taken by the camera, the depth buffer in which the depth information is written, and the normal buffer in which the normal information is written. </font><font style="vertical-align: inherit;">Depth buffer and normal buffer are collectively called G-buffer and are indispensable for Deferred rendering such as SSR. </font><font style="vertical-align: inherit;">(For Deferred Rendering, there is a great explanation in the introduction to ImageEffect in the previous chapter, so please refer to that.)</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a premise when reading this section, but in this section, we will proceed with the explanation on the premise of basic knowledge about ray tracing. </font><font style="vertical-align: inherit;">Ray tracing is a big theme that I can write another chapter even at the introductory level, so unfortunately I will omit the explanation here. </font><font style="vertical-align: inherit;">However, if you do not understand what ray tracing is, you can not understand the following contents, so if you do not understand it, there is a good introduction book "Ray Tracing in One Weekend" </font></font><a id="fnb-shirley" href="https://freder.io/files/unity2/komietty.html#fn-shirley" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> by </font><font style="vertical-align: inherit;">Peter Shirley, </font><font style="vertical-align: inherit;">so it is recommended that you read that first. I will.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, kode80's "Screen Space Reflections in Unity 5 </font></font><a id="fnb-kode80" href="https://freder.io/files/unity2/komietty.html#fn-kode80" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 6</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " is famous </font><font style="vertical-align: inherit;">as a commentary text for the Unity implementation of SSR </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Also, in Japanese text, there is "I tried to implement Screen Space Reflection in Unity </font></font><a id="fnb-hecomi" href="https://freder.io/files/unity2/komietty.html#fn-hecomi" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 8</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font><font style="vertical-align: inherit;">In this section, what is explained in the above text is simplified as much as possible, and explanation of branch and leaf techniques is omitted. </font><font style="vertical-align: inherit;">If you read the source code and find any questions, try to hit them.</font></font></p>

<h3><a id="h10-3-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.3.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Overview of Theory</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The basic idea of ​​SSR is to use ray tracing techniques to simulate the relationship between a camera, a reflective surface, and an object (light source).</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unlike ordinary optics, SSR reproduces reflections on the reflecting surface by fetching the color on the reflecting surface after identifying the light source by calculating back from the path of light incident on the camera.</font></font></p>
<div id="id_komietty_2Fssr__idea" class="image">
<img src="./Chapter 10 _ Application of ImageEffect (SSR)_files/ssr_idea.png" alt="Difference between real optics and SSR light thinking">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 10.2: Differences between real-life optics and SSR light thinking
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSR does this for each pixel of the camera.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The outline of the process can be summarized as follows.</font></font></p>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Return the screen coordinate system to the world coordinate system by using depth information</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Find the reflection vector from the line-of-sight vector and normal information</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extend the reflection vector a little and return the position of its tip (= ray) to the screen coordinate system again.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compare the depth of the ray with the depth written in the depth buffer for the position of the ray in the screen coordinate system.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the ray is less deep, the ray is still wandering in the air. </font><font style="vertical-align: inherit;">Go back to 3 and move Ray a little further</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the ray is deeper, it means that the ray has passed some object and you can get the reflected color.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Return to the original pixel and reflect the acquired color</font></font></li>
</ol>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The procedure is difficult to explain in the figure, but it is complicated to explain in words. </font><font style="vertical-align: inherit;">Let's disassemble it.</font></font></p>

<h3><a id="h10-3-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.3.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coordinate transformation</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, pass the matrix for converting the screen coordinate system and the world coordinate system to the shader. </font></font><code class="inline-code tt">_ViewProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is the transformation matrix from the world coordinate system to the screen coordinate system, and </font></font><code class="inline-code tt">_InvViewProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is the inverse matrix.</font></font></p>
<div class="emlist-code">
<p class="caption">SSR.cs</p>
<pre class="emlist"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void OnRenderImage (RenderTexture src, RenderTexture dst)</font></font></font></font><font></font>
{<font></font>
<font></font>
  ....<font></font>
<font></font>
  // world &lt;-&gt; screen matrix<font></font>
  var view = cam.worldToCameraMatrix;<font></font>
  var proj = GL.GetGPUProjectionMatrix(cam.projectionMatrix, false);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  var viewProj = proj * view;</font></font></font></font><font></font>
  mat.SetMatrix("_ViewProj", viewProj);<font></font>
  mat.SetMatrix("_InvViewProj", viewProj.inverse);<font></font>
<font></font>
  ....<font></font>
<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, using the transformation matrix passed, the normal vector and the reflection vector can be obtained. </font><font style="vertical-align: inherit;">Let's take a look at the processing of the corresponding shader.</font></font></p>
<div class="emlist-code">
<p class="caption">SSR.shader</p>
<pre class="emlist">float4 reflection (v2f i) : SV_Target<font></font>
{<font></font>
  float2 uv = i.screen.xy / i.screen.w;<font></font>
  float depth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv);<font></font>
<font></font>
  ...<font></font>
<font></font>
  float2 screenpos = 2.0 * uv - 1.0;<font></font>
  float4 pos = mul(_InvViewProj, float4(screenpos, depth, 1.0));<font></font>
  pos /= pos.w;<font></font>
  float3 camDir = normalize(pos - _WorldSpaceCameraPos);<font></font>
  float3 normal = tex2D(_CameraGBufferTexture2, uv) * 2.0 - 1.0;<font></font>
  float3 refDir = reflect(camDir, normal);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  ....</font></font></font></font><font></font>
<font></font>
  if (_ViewMode == 1) col = float4((normal.xyz * 0.5 + 0.5), 1);<font></font>
  if (_ViewMode == 2) col = float4((refDir.xyz * 0.5 + 0.5), 1);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  ....</font></font></font></font><font></font>
<font></font>
  return col;<font></font>
  }<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, the depth of the corresponding pixel is </font></font><code class="inline-code tt">_CameraDepthTexture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">written in, and this is used. </font><font style="vertical-align: inherit;">Next, from the position information and seismic intensity information on the screen, the position of the polygon in the corresponding pixel in the world coordinate system can be found, so </font></font><code class="inline-code tt">pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hold it in. </font></font><code class="inline-code tt">pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then, </font></font><code class="inline-code tt">_WorldSpaceCameraPos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">since the vector toward the camera is known, the reflection vector can be known from this and the normal information.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the script attached to the main camera, you can see where the normal and reflection vectors are facing. </font><font style="vertical-align: inherit;">Since each vector is standardized between -1 and 1, color information with a value less than or equal to 0 is not displayed. </font><font style="vertical-align: inherit;">When the x-axis component is large, the vector is displayed in reddish, when the y-axis component is large, it is displayed in greenish, and when the z-axis component is large, it is displayed in bluish. </font><font style="vertical-align: inherit;">Please set </font><font style="vertical-align: inherit;">ViewMode to </font></font><code class="inline-code tt">Normal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or　</font></font><code class="inline-code tt">Reflection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and check.</font></font></p>

<h3><a id="h10-3-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.3.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ray tracing</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's look at the process of performing ray tracing.</font></font></p>
<div class="emlist-code">
<p class="caption">SSR.shader</p>
<pre class="emlist">float4 reflection(v2f i) : SV_Target<font></font>
{<font></font>
<font></font>
  ...<font></font>
<font></font>
  [loop]<font></font>
  for (int n = 1; n &lt;= _MaxLoop; n++)<font></font>
  {<font></font>
    float3 step = refDir * _RayLenCoeff * (lod + 1);<font></font>
    ray += step * (1 + rand(uv + _Time.x) * (1 - smooth));<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    float4 rayScreen = mul (_ViewProj, float4 (ray, 1.0));</font></font></font></font><font></font>
    float2 rayUV      = rayScreen.xy / rayScreen.w * 0.5 + 0.5;<font></font>
    float  rayDepth   = ComputeDepth(rayScreen);<font></font>
    float  worldDepth = (lod == 0)?<font></font>
           SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, rayUV) :<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
           tex2Dlod (_CameraDepthMipmap, float4 (rayUV, 0, lod))</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
           + _BaseRaise * lod;</font></font></font></font><font></font>
<font></font>
    ...<font></font>
<font></font>
    if(rayDepth &lt; worldDepth)<font></font>
    {<font></font>
<font></font>
      ....<font></font>
<font></font>
      return outcol;<font></font>
    }<font></font>
  }<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variables related to the processing explained later are also mixed, but please read it without worrying about it. </font><font style="vertical-align: inherit;">Inside the loop, first stretch the ray by a step and then put it back in the screen coordinate system. </font><font style="vertical-align: inherit;">We will compare the depth of the ray in the screen coordinate system with the depth written to the depth buffer and return the color if the ray is deeper. </font><font style="vertical-align: inherit;">(1.0 when the depth is the closest, because the smaller the further away, </font></font><code class="inline-code tt">rayDepth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">but </font></font><code class="inline-code tt">worldDepth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is smaller than the will to a determination that Ray is in the back.)</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, if the number of loops is undecided, HLSL will throw an error, so if you want to pass the number of loops from the script </font></font><code class="inline-code tt">[loop]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, you need to write the attribute at the beginning.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The skeleton of ray tracing is now complete. </font><font style="vertical-align: inherit;">The basic processing is not so difficult once you have an image. </font><font style="vertical-align: inherit;">However, in order to reproduce beautiful reflections, it is necessary to add some processing from now on. </font><font style="vertical-align: inherit;">Are the following four points that need to be improved?</font></font></p>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Due to the limited number of loops, the distance traveled by the ray is not large enough to reproduce the reflection of distant objects.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the number of steps of the ray is large, it will pass through the reflected object and sample the wrong color.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the loop is performed many times, the processing is simply heavy.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Not taking into account material differences</font></font></li>
</ol>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For post-effects, including antialiasing, techniques for efficient processing are rather essential. </font><font style="vertical-align: inherit;">Now that you understand the gist of the process, let's look at the technique for establishing SSR as a video.</font></font></p>

<h3><a id="h10-3-4"></a><span class="secno">10.3.4　</span>Mipmap</h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below, </font><font style="vertical-align: inherit;">we will explain how to improve processing efficiency by using Mipmap, referring to </font><font style="vertical-align: inherit;">the article </font></font><a id="fnb-chalmers" href="https://freder.io/files/unity2/komietty.html#fn-chalmers" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 7</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> of Chalmers University of Technology </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">(See footnote for what Mipmap is </font></font><a id="fnb-mipmap" href="https://freder.io/files/unity2/komietty.html#fn-mipmap" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 9</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) Ray tracing basically determines the step width of the ray and gradually advances the ray, but by using Mipmap, the step of the ray until the intersection with the object is judged. The width can be variable. </font><font style="vertical-align: inherit;">By doing this, you will be able to fly rays far away even with a limited number of loops, and processing efficiency will also increase.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have prepared a demoscene that uses Mipmap from RenderTexture, so let's check it from there.</font></font></p>
<div class="emlist-code">
<p class="caption">Mipmap.cs</p>
<pre class="emlist">public class Mipmap : MonoBehaviour<font></font>
{<font></font>
  Material mat;<font></font>
  RenderTexture rt;<font></font>
  [SerializeField] Shader shader;<font></font>
  [SerializeField] int lod;<font></font>
<font></font>
  void OnEnable()<font></font>
  {<font></font>
    mat = new Material(shader);<font></font>
    rt = new RenderTexture(Screen.width, Screen.height, 24);<font></font>
    rt.useMipMap = true;<font></font>
  }<font></font>
<font></font>
  void OnDisable()<font></font>
  {<font></font>
    Destroy(mat);<font></font>
    rt.Release();<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  }</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  void OnRenderImage (RenderTexture src, RenderTexture dst)</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  {</font></font></font></font><font></font>
    mat.SetInt("_LOD", lod);<font></font>
    Graphics.Blit(src, rt);<font></font>
    Graphics.Blit(rt, dst, mat);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  }</font></font></font></font><font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since mipmap cannot be set for ready-made RenderTexture, here, </font></font><code class="inline-code tt">src</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">after </font><font style="vertical-align: inherit;">creating a new RenderTexture </font><font style="vertical-align: inherit;">and copying it, processing is added.</font></font></p>
<div class="emlist-code">
<p class="caption">Mipmap.shader</p>
<pre class="emlist">sampler2D _MainTex;<font></font>
float4 _MainTex_ST;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int _LOD;</font></font></font></font><font></font>
<font></font>
....<font></font>
<font></font>
fixed4 frag (v2f i) : SV_Target<font></font>
{<font></font>
        return tex2Dlod(_MainTex, float4(i.uv, 0, _LOD));<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
</pre>
</div>
<p><code class="inline-code tt">tex2Dlod(_MainTex, float4(i.uv, 0, _LOD))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can get the Mipmap according to the LOD with.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you raise the LOD from the script attached to the camera on the scene, you can see that the image becomes grainy.</font></font></p>
<div id="id_komietty_2Fssr__mipmap__demo" class="image">
<img src="./Chapter 10 _ Application of ImageEffect (SSR)_files/ssr_mipmap_demo.png" alt="Comparison of LOD rise and Mipmap image quality">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 10.3: Comparison of increased LOD and Mipmap image quality
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that you have confirmed how to use Mipmap, let's see how Mipmap is used in the SSR scene.</font></font></p>
<div class="emlist-code">
<p class="caption">SSR.shader</p>
<pre class="emlist">[loop]<font></font>
for (int n = 1; n &lt;= _MaxLoop; n++)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{</font></font></font></font><font></font>
  float3 step = refDir * _RayLenCoeff * (lod + 1);<font></font>
  ray += step;<font></font>
<font></font>
  ....<font></font>
<font></font>
  if(rayDepth &lt; worldDepth)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  {</font></font></font></font><font></font>
    if(lod == 0)<font></font>
    {<font></font>
      if (rayDepth + _Thickness &gt; worldDepth)<font></font>
      {<font></font>
        float sign = -1.0;<font></font>
        for (int m = 1; m &lt;= 8; ++m)<font></font>
        {<font></font>
          ray += sign * pow(0.5, m) * step;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
          rayScreen = mul (_ViewProj, float4 (ray, 1.0));</font></font></font></font><font></font>
          rayUV = rayScreen.xy / rayScreen.w * 0.5 + 0.5;<font></font>
          rayDepth = ComputeDepth(rayScreen);<font></font>
          worldDepth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, rayUV);<font></font>
          sign = (rayDepth &lt; worldDepth) ? -1 : 1;<font></font>
        }<font></font>
        refcol = tex2D(_MainTex, rayUV);<font></font>
      }<font></font>
      break;<font></font>
    }<font></font>
    else<font></font>
    {<font></font>
      ray -= step;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      lod--;</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font>
  }<font></font>
  else if(n &lt;= _MaxLOD)<font></font>
  {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    lod ++;</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  }</font></font></font></font><font></font>
  calcTimes = n;<font></font>
}<font></font>
if (_ViewMode == 3) return float4(1, 1, 1, 1) * calc / _MaxLoop;<font></font>
<font></font>
....<font></font>
<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will proceed with the explanation using the figure in the article of Chalmers.</font></font></p>
<div id="id_komietty_2Fssr__mipmap__logic" class="image">
<img src="./Chapter 10 _ Application of ImageEffect (SSR)_files/ssr_mipmap_logic.png" alt="Calculation method using Mipmap">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 10.4: Calculation method using Mipmap
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As shown in the figure, the LOD is raised while carefully judging the intersection for the first few times. </font><font style="vertical-align: inherit;">As long as there is no intersection with other meshes, we will proceed with large steps. </font><font style="vertical-align: inherit;">If there is an intersection, Unity's MipMap will roughen the pixels while taking the average value, so unlike the case of the article, the ray may go too far. </font><font style="vertical-align: inherit;">Therefore, move back by one unit step and advance the ray again with one smaller LOD. </font><font style="vertical-align: inherit;">Finally, by making an intersection judgment on the image with LOD = 0, the moving distance of the ray can be extended and the processing can be made more efficient.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the script attached to the main camera, you can see how much the amount of calculation changes when you raise the LOD. </font><font style="vertical-align: inherit;">The larger the amount of calculation, the whiter it looks, and the smaller the amount of calculation, the darker it looks. </font><font style="vertical-align: inherit;">Set ViewMode and </font></font><code class="inline-code tt">CalcCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">change the LOD to check the change in the amount of calculation.</font></font></p>
<div id="id_komietty_2Fssr__lod" class="image">
<img src="./Chapter 10 _ Application of ImageEffect (SSR)_files/ssr_lod.png" alt="Difference in calculation amount due to change in LOD (the closer to black, the smaller the amount of calculation)">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 10.5: Difference in computational complexity due to changes in LOD (closer to black, smaller computational complexity)
</font></font></p>
</div>

<h3><a id="h10-3-5"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.3.5　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dichotomous exploration</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's see how to improve the accuracy near the intersection by binary tree search. </font><font style="vertical-align: inherit;">Check from the code immediately.</font></font></p>
<div class="emlist-code">
<p class="caption">SSR.shader</p>
<pre class="emlist">if (lod == 0)<font></font>
{<font></font>
  if (rayDepth + _Thickness &gt; worldDepth)<font></font>
  {<font></font>
    float sign = -1.0;<font></font>
    for (int m = 1; m &lt;= 8; ++m)<font></font>
    {<font></font>
      ray += sign * pow(0.5, m) * step;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      rayScreen = mul (_ViewProj, float4 (ray, 1.0));</font></font></font></font><font></font>
      rayUV = rayScreen.xy / rayScreen.w * 0.5 + 0.5;<font></font>
      rayDepth = ComputeDepth(rayScreen);<font></font>
      worldDepth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, rayUV);<font></font>
      sign = (rayDepth &lt; worldDepth) ? -1 : 1;<font></font>
    }<font></font>
    refcol = tex2D(_MainTex, rayUV);<font></font>
  }<font></font>
  break;<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immediately after the intersection, it is behind the intersected object, so first retract the ray. </font><font style="vertical-align: inherit;">After that, while checking the context of the ray and the mesh, change the direction of travel of the ray either forward or backward. </font><font style="vertical-align: inherit;">At the same time, by shortening the step width of the ray, it is possible to identify the intersection with the mesh with less error.</font></font></p>

<h3><a id="h10-3-6"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.3.6　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reflects material differences</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The methods so far have not taken into account the differences in the materials of the objects in the screen. </font><font style="vertical-align: inherit;">Therefore, there is a problem that all objects are reflected to the same extent. </font><font style="vertical-align: inherit;">Therefore, use G-buffer again. </font></font><code class="inline-code tt">_CameraGBufferTexture1.w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the smoothness of the material is stored in, use this.</font></font></p>
<div class="emlist-code">
<p class="caption">SSR.shader</p>
<pre class="emlist">if (_ViewMode == 8)<font></font>
  return float4(1, 1, 1, 1) * tex2D(_CameraGBufferTexture1, uv).w;<font></font>
<font></font>
....<font></font>
<font></font>
return<font></font>
  (col * (1 - smooth) + refcol * smooth) * _ReflectionRate<font></font>
　+ col * (1 - _ReflectionRate);<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you change the smoothness value of the material attached to an object in the scene, you can see that only that object changes the degree of reflection. </font></font><code class="inline-code tt">Smoothness</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also list the smoothness in the scene by </font><font style="vertical-align: inherit;">setting the ViewMode of the script attached to the main camera </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The whitish, the greater the smoothness.</font></font></p>

<h3><a id="h10-3-7"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.3.7　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Blur processing</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the part using the Gaussian blur explained in the first section. </font><font style="vertical-align: inherit;">If the step width of the ray is not small enough, you may not be able to get the reflection well even if you perform a binary tree search. </font><font style="vertical-align: inherit;">If the step width of the ray is reduced, the total length of the ray will be shortened and the amount of calculation will increase, so it is not enough to just reduce the step width, but it should be kept to an appropriate size. </font><font style="vertical-align: inherit;">The part where the reflection could not be obtained well is blurred to make it look like it.</font></font></p>
<div class="emlist-code">
<p class="caption">SSR.shader</p>
<pre class="emlist">float4 xblur(v2f i) : SV_Target<font></font>
{<font></font>
  float2 uv = i.screen.xy / i.screen.w;<font></font>
  float2 size = _ReflectionTexture_TexelSize;<font></font>
  float smooth = tex2D(_CameraGBufferTexture1, uv).w;<font></font>
<font></font>
  // compare depth<font></font>
  float depth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv);<font></font>
  float depthR =<font></font>
        SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv + float2(1, 0) * size);<font></font>
  float depthL =<font></font>
        SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv - float2(1, 0) * size);<font></font>
<font></font>
  if (depth &lt;= 0) return tex2D(_ReflectionTexture, uv);<font></font>
<font></font>
  float weight[5] = { 0.2270270, 0.1945945, 0.1216216, 0.0540540, 0.0162162 };<font></font>
  float offset[5] = { 0.0, 1.0, 2.0, 3.0, 4.0 };<font></font>
<font></font>
  float4 originalColor = tex2D(_ReflectionTexture, uv);<font></font>
  float4 blurredColor = tex2D(_ReflectionTexture, uv) * weight[0];<font></font>
<font></font>
  for (int j = 1; j &lt; 5; ++j)<font></font>
  {<font></font>
    blurredColor<font></font>
        += tex2D(_ReflectionTexture, uv + float2(offset[j], 0) * size)<font></font>
           * weight[j];<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    blurredColor</font></font></font></font><font></font>
        += tex2D(_ReflectionTexture, uv - float2(offset[j], 0) * size)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
           * weight[j];</font></font></font></font><font></font>
  }<font></font>
<font></font>
  float4 o = (abs(depthR - depthL) &gt; _BlurThreshold) ? originalColor<font></font>
  　　　　　　　: blurredColor * smooth + originalColor * (1 - smooth);<font></font>
  return o;<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Again, from the reason described above </font></font><code class="inline-code tt">xblur</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code class="inline-code tt">yblur</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">have divided the processing out. </font><font style="vertical-align: inherit;">Also, since we only want to blur the contours within the same reflective surface, we try not to blur the contours. </font><font style="vertical-align: inherit;">If the difference between the left and right depths is large, it is judged to be the contour part. </font><font style="vertical-align: inherit;">(Then </font></font><code class="inline-code tt">yblur</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">evaluates the difference between the top and bottom.)</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result of adding the processing up to this point is as follows.</font></font></p>
<div id="id_komietty_2Fssr__result" class="image">
<img src="./Chapter 10 _ Application of ImageEffect (SSR)_files/ssr_result.png" alt="result">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 10.6: Results
</font></font></p>
</div>

<h3><a id="h10-3-8"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.3.8　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bonus</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a bonus, I will introduce a technique that makes it look as if a non-existent object is reflected using two cameras, a main camera and a sub camera.</font></font></p>
<div class="emlist-code">
<p class="caption">SSRMainCamera.shader</p>
<pre class="emlist">float4 reflection(v2f i) : SV_Target<font></font>
{<font></font>
<font></font>
  ....<font></font>
<font></font>
  for (int n = 1; n &lt;= 100; ++n)<font></font>
  {<font></font>
    float3 ray = n * step;<font></font>
    float3 rayPos = pos + ray;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    float4 vpPos = mul (_ViewProj, float4 (rayPos, 1.0));</font></font></font></font><font></font>
    float2 rayUv = vpPos.xy / vpPos.w * 0.5 + 0.5;<font></font>
    float rayDepth = vpPos.z / vpPos.w;<font></font>
    float subCameraDepth = SAMPLE_DEPTH_TEXTURE(_SubCameraDepthTex, rayUv);<font></font>
<font></font>
    if (rayDepth &lt; subCameraDepth &amp;&amp; rayDepth + thickness &gt; subCameraDepth)<font></font>
    {<font></font>
      float sign = -1.0;<font></font>
      for (int m = 1; m &lt;= 4; ++m)<font></font>
      {<font></font>
        rayPos += sign * pow(0.5, m) * step;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        vpPos = mul (_ViewProj, float4 (rayPos, 1.0));</font></font></font></font><font></font>
        rayUv = vpPos.xy / vpPos.w * 0.5 + 0.5;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        rayDepth = vpPos.z / vpPos.w;</font></font></font></font><font></font>
        subCameraDepth = SAMPLE_DEPTH_TEXTURE(_SubCameraDepthTex, rayUv);<font></font>
        sign = rayDepth - subCameraDepth &lt; 0 ? -1 : 1;<font></font>
      }<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      col = tex2D (_SubCameraMainTex, rayUv);</font></font></font></font><font></font>
    }<font></font>
  }<font></font>
  return col * smooth + tex2D(_MainTex, uv) * (1 - smooth);<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is made simple with as little extra processing as possible. </font><font style="vertical-align: inherit;">The point is that </font></font><code class="inline-code tt">SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it </font></font><code class="inline-code tt">SAMPLE_DEPTH_TEXTURE(_SubCameraDepthTex, rayUv)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is used </font><font style="vertical-align: inherit;">instead </font><font style="vertical-align: inherit;">of for depth evaluation, and </font><font style="vertical-align: inherit;">the </font><font style="vertical-align: inherit;">object information to be referenced </font></font><code class="inline-code tt">_SubCameraMainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is </font><font style="vertical-align: inherit;">also </font><font style="vertical-align: inherit;">obtained from. </font></font><code class="inline-code tt">_CameraDepthTexture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code class="inline-code tt">_SubCameraDepthTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is set as a global texture from the sub camera.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The downside is that each camera casts shadows on objects that shouldn't be visible. </font><font style="vertical-align: inherit;">It may not be very practical, but it's a little interesting effect.</font></font></p>
<div id="id_komietty_2Fssr__twocam" class="image">
<img src="./Chapter 10 _ Application of ImageEffect (SSR)_files/ssr_twocam.png" alt="Method using two cameras">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 10.7: Method using two cameras
</font></font></p>
</div>

<h2><a id="h10-4"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.4　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Summary</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the end of the explanation of SSR.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since SSR is a technique that requires a large amount of processing capacity, it is not realistic to reflect objects in all positions cleanly. </font><font style="vertical-align: inherit;">Therefore, the point is to improve the appearance of the reflection of the object of interest and to make the trivial reflection look like it with less processing. </font><font style="vertical-align: inherit;">In addition, the screen size to be rendered is directly linked to the amount of calculation, so it is important to search for the points that will be established as an image while considering the expected screen size and GPU performance. </font><font style="vertical-align: inherit;">Check the role and trade-offs of each parameter by adjusting the parameters while moving the objects in the scene.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, the Mipmap, binary tree search, how to use the camera buffer, and many other detailed techniques mentioned above can be applied not only to SSR but also to various places. </font><font style="vertical-align: inherit;">I would be happy if there is some content that is helpful to the readers.</font></font></p>
<div class="footnote" epub:type="footnote" id="fn-gaussian"><p class="footnote">[*1] http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/</p></div>
<div class="footnote" epub:type="footnote" id="fn-binomial"><p class="footnote">[*2] https://ja.wikipedia.org/wiki/%E4%BA%8C%E9%A0%85%E5%88%86%E5%B8%83</p></div>
<div class="footnote" epub:type="footnote" id="fn-shirley"><p class="footnote">[*3] https://www.amazon.co.jp/gp/product/B01B5AODD8</p></div>
<div class="footnote" epub:type="footnote" id="fn-texel"><p class="footnote">[*4] https://msdn.microsoft.com/ja-jp/library/bb219690(v=vs.85).aspx</p></div>
<div class="footnote" epub:type="footnote" id="fn-reflection"><p class="footnote">[*5] https://www.sciencelearn.org.nz/resources/48-reflection-of-light</p></div>
<div class="footnote" epub:type="footnote" id="fn-kode80"><p class="footnote">[*6] http://www.kode80.com/blog/2015/03/11/screen-space-reflections-in-unity-5/</p></div>
<div class="footnote" epub:type="footnote" id="fn-chalmers"><p class="footnote">[*7] http://www.cse.chalmers.se/edu/year/2017/course/TDA361/　　　　　　Advanced%20Computer%20Graphics/Screen-space%20reflections.pdf</p></div>
<div class="footnote" epub:type="footnote" id="fn-hecomi"><p class="footnote">[*8] http://tips.hecomi.com/entry/2016/04/04/022550</p></div>
<div class="footnote" epub:type="footnote" id="fn-mipmap"><p class="footnote">[*9] https://answers.unity.com/questions/441984/what-is-mip-maps-pictures.html</p></div>
<div class="footnote" epub:type="footnote" id="fn-gbuffer"><p class="footnote">[*10] https://docs.unity3d.com/Manual/RenderTech-DeferredShading.html</p></div></body></html>