<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="en" style="height: 100%;" class="translated-ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <link rel="stylesheet" type="text/css" href="./Chapter 1 _ Procedural Modeling Beginning with Unity_files/style.scss">
  <meta name="generator" content="Re:VIEW">
  <title>Procedural modeling starting with Unity</title>

			<style>
				img {
					max-width: 80vw;
					max-height: 80vh;
				}
			</style><style>
					.goog-te-banner-frame {
						display: none;
					}
				</style>
			<script>(function(){(function injection() {
  var pageLang = 'ja';
  var userLang = 'en';

  var uid = '1E07F158C6FA4460B352973E9693B329';
  var teId = 'TE_' + uid;
  var cbId = 'TECB_' + uid;

  function show() {
    window.setTimeout(function() {
      window[teId].showBanner(true);
    }, 10);
  }

  function newElem() {
    
  }

  if (window[teId]) {
    show();
  } else {
    if (!window.google || !google.translate ||
        !google.translate.TranslateElement) {
      if (!window[cbId]) {
        window[cbId] = function() {
          window[teId] = newElem();
          show();
        };
      }
      
    }
  }
})();})();</script><script src="https://translate.google.com/translate_a/element.js?cb=TECB_1E07F158C6FA4460B352973E9693B329&amp;client=tee&amp;hl=en"></script><script src="./Chapter 1 _ Procedural Modeling Beginning with Unity_files/f.txt"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://translate.googleapis.com/translate_static/css/translateelement.css"><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/translate_static/js/element/main.js"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="./Chapter 1 _ Procedural Modeling Beginning with Unity_files/translateelement.css"><script type="text/javascript" charset="UTF-8" src="./Chapter 1 _ Procedural Modeling Beginning with Unity_files/main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script><script type="text/javascript" charset="UTF-8" src="./Chapter 1 _ Procedural Modeling Beginning with Unity_files/element_main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://translate.googleapis.com/translate_static/css/translateelement.css"><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/translate_static/js/element/main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script></head>
		
<body style="position: relative; min-height: 100%; top: 40px;"><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div>
<h1><a id="h1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chapter 1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Procedural Modeling Beginning with Unity</font></font></h1>

<h2><a id="h1-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Introduction</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Procedural Modeling is a technique for building 3D models using rules. </font><font style="vertical-align: inherit;">Modeling generally refers to using modeling software such as Blender or 3ds Max to manually operate to obtain the target shape while moving the vertices and line segments. In contrast, the approach of writing rules and obtaining shape as a result of a series of automated processes is called procedural modeling.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Procedural modeling is applied in various fields. For example, in games, there are examples of being used for terrain generation, plant modeling, city construction, etc. By using this technology, each time you play, you will be staged. Content design such as changing the structure becomes possible.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, in the fields of architecture and product design, </font><font style="vertical-align: inherit;">the method of procedurally designing shapes using </font><font style="vertical-align: inherit;">Grasshopper </font><a id="fnb-grasshopper" href="https://freder.github.io/UnityGraphicsProgrammingBook1/articles/Nakamura.html#fn-grasshopper" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;">* 2</font></a><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">which is a CAD software plug-in called </font><font style="vertical-align: inherit;">Rhinoceros </font></font><a id="fnb-rhinoceros" href="https://freder.github.io/UnityGraphicsProgrammingBook1/articles/Nakamura.html#fn-rhinoceros" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , is </font><font style="vertical-align: inherit;">being actively used.</font></font><a id="fnb-grasshopper" href="https://freder.github.io/UnityGraphicsProgrammingBook1/articles/Nakamura.html#fn-grasshopper" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font></p>
<div class="footnote" epub:type="footnote" id="fn-rhinoceros"><p class="footnote">[*1] http://www.rhino3d.co.jp/</p></div>
<div class="footnote" epub:type="footnote" id="fn-grasshopper"><p class="footnote">[*2] http://www.grasshopper3d.com/</p></div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With procedural modeling, you can:</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Can create parametric structures</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flexible models can be incorporated into the content</font></font></li>
</ul>

<h3><a id="h1-1-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.1.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Can create parametric structures</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A parametric structure is a structure in which the elements of the structure can be deformed according to a certain parameter. For example, in the case of a sphere model, the radius representing the size and the smoothness of the sphere are calculated. You can define parameters such as the number of segments to represent, and by changing those values, you can obtain a sphere with the desired size and smoothness.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Once you have implemented a program that defines a parametric structure, you can get a model with a specific structure in various situations, which is convenient.</font></font></p>

<h3><a id="h1-1-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.1.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flexible models can be incorporated into content</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As mentioned above, in fields such as games, there are many examples where procedural modeling is used to generate terrain and trees, and it is generated in real time in the content instead of incorporating what was once written as a model. Sometimes. </font><font style="vertical-align: inherit;">Using procedural modeling techniques for real-time content, for example, you can create a tree that grows toward the sun at any position, or build a city where buildings line up from the clicked position. It can be realized.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, incorporating models of various patterns into the content will increase the data size, but if you use procedural modeling to increase the variation of the model, you can reduce the data size.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you learn procedural modeling techniques and build models programmatically, you will be able to develop your own modeling tools.</font></font></p>

<h2><a id="h1-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Model representation in Unity</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Unity, the geometry data that represents the shape of the model is managed by the Mesh class.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The shape of the model consists of triangles arranged in 3D space, and one triangle is defined by three vertices. </font><font style="vertical-align: inherit;">The official Unity documentation explains how to manage the vertex and triangle data of the model in the Mesh class as follows.</font></font></p>
<blockquote><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the Mesh class, all vertices are stored in one array, and each triangle is specified by three integers that are the indexes of the vertex array. </font><font style="vertical-align: inherit;">The triangles are further collected as an array of integers. </font><font style="vertical-align: inherit;">This integer is grouped every three from the beginning of the array, so elements 0, 1, and 2 define the first triangle, followed by the second triangles 3, 4, 5. </font></font><a id="fnb-mesh" href="https://freder.github.io/UnityGraphicsProgrammingBook1/articles/Nakamura.html#fn-mesh" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 3</font></font></a></p>
<p></p></blockquote>
<div class="footnote" epub:type="footnote" id="fn-mesh"><p class="footnote">[*3] https://docs.unity3d.com/jp/540/Manual/AnatomyofaMesh.html</p></div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The model has uv coordinates that represent the coordinates on the texture required for texture mapping to correspond to each vertex, and normal vectors (also called normal) required to calculate the influence of the light source during lighting. Can be included).</font></font></p>

<h4><a id="h1-2-0-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sample repository</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this chapter, the following Assets / ProceduralModeling in the https://github.com/IndieVisualLab/UnityGraphicsProgramming repository are prepared as sample programs.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since model generation by C # script is the main content of the explanation, we will proceed with the explanation while referring to the C # script under Assets / ProceduralModeling / Scripts.</font></font></p>

<h5><a id="h1-2-0-1-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Execution environment</font></font></h5>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The sample code in this chapter has been confirmed to work with Unity 5.0 and above.</font></font></p>

<h3><a id="h1-2-1"></a><span class="secno">1.2.1　</span>Quad</h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taking Quad, which is a basic model, as an example, we will explain how to build a model programmatically. </font><font style="vertical-align: inherit;">Quad is a square model that combines two triangles consisting of four vertices, which is provided by default as Primitive Mesh in Unity, but since it is the most basic shape, it is an example to understand the structure of the model. Useful.</font></font></p>
<div id="ProceduralModeling_quad" class="image">
<img src="./Chapter 1 _ Procedural Modeling Beginning with Unity_files/ProceduralModeling_quad.png" alt="Quad model structure Black circles represent the vertices of the model, and the numbers 0 to 3 in the black circles indicate the indexes of the vertices. Triangles specified in the order of, lower left is triangles specified in the order of 2,3,0)">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.1: Quad model structure Black circles represent the vertices of the model, and the numbers 0 to 3 in the black circles indicate the index of the vertices. Triangles specified in the order of 1,2, lower left is triangles specified in the order of 2,3,0)
</font></font></p>
</div>

<h4><a id="h1-2-1-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sample program Quad.cs</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, create an instance of the Mesh class.</font></font></p>
<div class="emlist-code">
<pre class="emlist language-cs"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Create an instance of Mesh</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
var mesh = new Mesh ();</font></font></font></font></font></font></font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, generate a Vector3 array that represents the four vertices located at the four corners of the Quad. </font><font style="vertical-align: inherit;">Also, prepare the uv coordinate and normal data so that they correspond to each of the four vertices.</font></font></p>
<div class="emlist-code">
<pre class="emlist language-cs"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Find half the length so that the width and height of the Quad are the length of size respectively.</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
var hsize = size * 0.5f;</font></font></font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Quad vertex data</font></font><font></font>
var vertices = new Vector3[] {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    new Vector3 (-hsize, hsize, 0f), // Upper left position of the first vertex Quad</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    new Vector3 (hsize, hsize, 0f), // Upper right position of the second vertex Quad</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    new Vector3 (hsize, -hsize, 0f), // Lower right position of the third vertex Quad</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    new Vector3 (-hsize, -hsize, 0f) // Lower left position of the 4th vertex Quad</font></font><font></font>
};<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Quad uv coordinate data</font></font><font></font>
var uv = new Vector2[] {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    new Vector2 (0f, 0f), // uv coordinates of the first vertex</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    new Vector2 (1f, 0f), // uv coordinates of the second vertex</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    new Vector2 (1f, 1f), // uv coordinates of the third vertex</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    new Vector2 (0f, 1f) // uv coordinates of the 4th vertex</font></font><font></font>
};<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Quad normal data</font></font><font></font>
var normals = new Vector3[] {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    new Vector3 (0f, 0f, -1f), // normal of the first vertex</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    new Vector3 (0f, 0f, -1f), // Normal of the second vertex</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    new Vector3 (0f, 0f, -1f), // normal of the third vertex</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    new Vector3 (0f, 0f, -1f) // Normal of the 4th vertex</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
};</font></font></font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, generate triangular data that represents the faces of the model. </font><font style="vertical-align: inherit;">The triangle data is specified by an array of integers, and each integer corresponds to the index of the vertex array.</font></font></p>
<div class="emlist-code">
<pre class="emlist language-cs"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Quad face data Recognize as one face (triangle) by arranging three indexes of vertices</font></font><font></font>
var triangles = new int[] {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    0, 1, 2, // 1st triangle</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    2, 3, 0 // Second triangle</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
};</font></font></font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Set the last generated data to the Mesh instance.</font></font></p>
<div class="emlist-code">
<pre class="emlist language-cs">mesh.vertices = vertices;<font></font>
mesh.uv = uv;<font></font>
mesh.normals = normals;<font></font>
mesh.triangles = triangles;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Calculate the boundary area occupied by Mesh (required for culling)</font></font><font></font>
mesh.RecalculateBounds();<font></font>
<font></font>
return mesh;<font></font>
</pre>
</div>

<h3><a id="h1-2-2"></a><span class="secno">1.2.2　</span>ProceduralModelingBase</h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The sample code used in this chapter uses a base class called ProceduralModelingBase. </font><font style="vertical-align: inherit;">In the inherited class of this class, every time you change a model parameter (for example, size that represents width and height in Quad), a new Mesh instance is created and applied to MeshFilter to check the change result immediately. I can. </font><font style="vertical-align: inherit;">(This function is realized by using the Editor script. ProceduralModelingEditor.cs)</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also visualize the UV coordinates and normal direction of the model by changing the enum type parameter called ProceduralModelingMaterial.</font></font></p>
<div id="ProceduralModeling_materials" class="image">
<img src="./Chapter 1 _ Procedural Modeling Beginning with Unity_files/ProceduralModeling_materials.png" alt="From the left, the model to which ProceduralModelingMaterial.Standard, ProceduralModelingMaterial.UV, and ProceduralModelingMaterial.Normal are applied.">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.2: From the left, the model to which ProcedureModelingMaterial.Standard, ProcedureModelingMaterial.UV, and ProcedureModelingMaterial.Normal are applied.
</font></font></p>
</div>

<h2><a id="h1-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Primitive shape</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that you understand the structure of your model, let's create some primitive shapes.</font></font></p>

<h3><a id="h1-3-1"></a><span class="secno">1.3.1　</span>Plane</h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plane is shaped like a grid of Quads.</font></font></p>
<div id="ProceduralModeling_plane" class="image">
<img src="./Chapter 1 _ Procedural Modeling Beginning with Unity_files/ProceduralModeling_plane.png" alt="Plane model">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.3: Plane model
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Determine the number of rows and columns of the grid, place vertices at the intersections of each grid, build a Quad to fill each cell of the grid, and combine them to generate one Plane model.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the sample program Plane.cs, the number of vertices arranged vertically in the Plane, heightSegments, the number of vertices arranged horizontally widthSegments, and the parameters of vertical length height and horizontal length width are prepared. </font><font style="vertical-align: inherit;">Each parameter affects the shape of the Plane as shown in the following figure.</font></font></p>
<div id="ProceduralModeling_plane_parameters" class="image">
<img src="./Chapter 1 _ Procedural Modeling Beginning with Unity_files/ProceduralModeling_plane_parameters.png" alt="Plane parameters">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.4: Plane parameters
</font></font></p>
</div>

<h4><a id="h1-3-1-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sample program Plane.cs</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, we will generate vertex data to be placed at the intersections of the grid.</font></font></p>
<div class="emlist-code">
<pre class="emlist language-cs">var vertices = new List&lt;Vector3&gt;();<font></font>
var uv = new List&lt;Vector2&gt;();<font></font>
var normals = new List&lt;Vector3&gt;();<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// The reciprocal of the number of matrices to calculate the percentage of vertices on the grid (0.0 to 1.0)</font></font><font></font>
var winv = 1f / (widthSegments - 1);<font></font>
var hinv = 1f / (heightSegments - 1);<font></font>
<font></font>
for(int y = 0; y &lt; heightSegments; y++) {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Row position percentage (0.0 ~ 1.0)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    var ry = y * hinv;</font></font></font></font></font></font><font></font>
<font></font>
    for(int x = 0; x &lt; widthSegments; x++) {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Percentage of column positions (0.0 ~ 1.0)</font></font><font></font>
        var rx = x * winv;<font></font>
<font></font>
        vertices.Add(new Vector3(<font></font>
            (rx - 0.5f) * width,<font></font>
            0f,<font></font>
            (0.5f - ry) * height<font></font>
        ));<font></font>
        uv.Add(new Vector2(rx, ry));<font></font>
        normals.Add(new Vector3(0f, 1f, 0f));<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, regarding triangle data, the vertex index set for each triangle is referenced as shown below in the loop that follows the rows and columns.</font></font></p>
<div class="emlist-code">
<pre class="emlist language-cs">var triangles = new List&lt;int&gt;();<font></font>
<font></font>
for(int y = 0; y &lt; heightSegments - 1; y++) {<font></font>
    for(int x = 0; x &lt; widthSegments - 1; x++) {<font></font>
        int index = y * widthSegments + x;<font></font>
        var a = index;<font></font>
        var b = index + 1;<font></font>
        var c = index + 1 + widthSegments;<font></font>
        var d = index + widthSegments;<font></font>
<font></font>
        triangles.Add(a);<font></font>
        triangles.Add(b);<font></font>
        triangles.Add(c);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        triangles.Add(c);</font></font></font></font></font></font><font></font>
        triangles.Add(d);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        triangles.Add(a);</font></font></font></font></font></font><font></font>
    }<font></font>
}<font></font>
</pre>
</div>

<h4><a id="h1-3-1-2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ParametricPlaneBase</font></font></font></font></font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The height (y coordinate) value of each vertex of Plane was set to 0, but by manipulating this height, it is not just a horizontal surface, but an uneven terrain or a shape like a small mountain. Can be obtained.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ParametricPlaneBase class inherits from the Plane class and overrides the Build function that creates the mesh. </font><font style="vertical-align: inherit;">First, generate the original Plane model, call the Depth (float u, float v) function to find the height by inputting the uv coordinates of each vertex, and reset the height to flexibly shape it. Transforms.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By implementing a class that inherits this ParametricPlaneBase class, you can generate a Plane model whose height changes depending on the vertices.</font></font></p>

<h4><a id="h1-3-1-3"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sample program ParametricPlaneBase.cs</font></font></h4>
<div class="emlist-code">
<pre class="emlist language-cs">protected override Mesh Build() {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Generate the original Plane model</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    var mesh = base.Build ();</font></font></font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Reset the height of the vertices of the Plane model</font></font><font></font>
    var vertices = mesh.vertices;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // The reciprocal of the number of matrices to calculate the percentage of vertices on the grid (0.0 to 1.0)</font></font><font></font>
    var winv = 1f / (widthSegments - 1);<font></font>
    var hinv = 1f / (heightSegments - 1);<font></font>
<font></font>
    for(int y = 0; y &lt; heightSegments; y++) {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Row position percentage (0.0 ~ 1.0)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        var ry = y * hinv;</font></font></font></font><font></font>
        for(int x = 0; x &lt; widthSegments; x++) {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // Percentage of column positions (0.0 ~ 1.0)</font></font><font></font>
            var rx = x * winv;<font></font>
<font></font>
            int index = y * widthSegments + x;<font></font>
            vertices[index].y = Depth(rx, ry);<font></font>
        }<font></font>
    }<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Reset the vertex position</font></font><font></font>
    mesh.vertices = vertices;<font></font>
    mesh.RecalculateBounds();<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Automatically calculate normal direction</font></font><font></font>
    mesh.RecalculateNormals();<font></font>
<font></font>
    return mesh;<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the sample scene ParametricPlane.scene, GameObject using the class (MountainPlane, TerrainPlane class) that inherits this ParametricPlaneBase is placed. </font><font style="vertical-align: inherit;">Try changing each parameter and see how the shape changes.</font></font></p>
<div id="ProceduralModeling_parametric_planes" class="image">
<img src="./Chapter 1 _ Procedural Modeling Beginning with Unity_files/ProceduralModeling_parametric_planes.png" alt="ParametricPlane.scene The model generated by the MountainPlane class on the left and the TerrainPlane class on the right">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.5: ParametricPlane.scene Model generated by the MountainPlane class on the left and the TerrainPlane class on the right
</font></font></p>
</div>

<h3><a id="h1-3-2"></a><span class="secno">1.3.2　</span>Cylinder</h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Cylinder is a cylindrical model that looks like the following figure.</font></font></p>
<div id="ProceduralModeling_cylinder" class="image">
<img src="./Chapter 1 _ Procedural Modeling Beginning with Unity_files/ProceduralModeling_cylinder.png" alt="Structure of Cylinder">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.6: Structure of Cylinder
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The smoothness of the cylindrical circle can be controlled by the segments, and the vertical length and thickness can be controlled by the height and radius parameters, respectively. </font><font style="vertical-align: inherit;">As shown in the example above, if you specify 7 for segments, the cylinder will look like a regular heptagon stretched vertically, and the larger the value of segments, the closer it will be to a circle.</font></font></p>

<h4><a id="h1-3-2-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vertices evenly aligned along the circumference</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The vertices of the Cylinder should be evenly aligned around the circle located at the end of the cylinder.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use trigonometric functions (Mathf.Sin, Mathf.Cos) to place evenly aligned vertices along the circumference. </font><font style="vertical-align: inherit;">The details of trigonometric functions are omitted here, but these functions can be used to obtain the position on the circumference based on the angle.</font></font></p>
<div id="ProceduralModeling_cylinder_trigonometry" class="image">
<img src="./Chapter 1 _ Procedural Modeling Beginning with Unity_files/ProceduralModeling_cylinder_trigonometry.png" alt="Get the position of a point on the circumference from a trigonometric function">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.7: Obtaining the position of a point on the circumference from a trigonometric function
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As shown in this figure, the points located on the circle of radius radius from the angle θ (theta) are acquired by (x, y) = (Mathf.Cos (θ) * radius, Mathf.Sin (θ) * radius). can do.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Based on this, perform the following processing to obtain the vertex positions of segments evenly arranged on the circumference of the radius radius.</font></font></p>
<div class="emlist-code">
<pre class="emlist language-cs">for (int i = 0; i &lt; segments; i++) {<font></font>
    // 0.0 ~ 1.0<font></font>
    float ratio = (float)i / (segments - 1);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Convert [0.0 ~ 1.0] to [0.0 ~ 2π]</font></font><font></font>
    float rad = ratio * PI2;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Get a position on the circumference</font></font><font></font>
    float cos = Mathf.Cos(rad), sin = Mathf.Sin(rad);<font></font>
    float x = cos * radius, y = sin * radius;<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Cylinder modeling, vertices are evenly placed along the circumference of the end of the cylinder, and the vertices are joined together to form a side surface. </font><font style="vertical-align: inherit;">For each side, just as you would build a Quad, take two corresponding vertices from the top and bottom and place the triangles facing each other to build one side, a rectangle. </font><font style="vertical-align: inherit;">The sides of the Cylinder can be imagined as the Quads arranged along a circle.</font></font></p>
<div id="ProceduralModeling_cylinder_sides" class="image">
<img src="./Chapter 1 _ Procedural Modeling Beginning with Unity_files/ProceduralModeling_cylinder_sides.png" alt="Modeling the sides of a cylinder Black circles are vertices evenly distributed along the circumference at the edge a to d in the vertices are index variables assigned to the vertices when constructing a triangle in the Cylinder.cs program.">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.8: Modeling the sides of a cylinder Black circles are evenly distributed vertices along the circumference at the edges a to d in the vertices are index variables assigned to the vertices when constructing a triangle in the Cylinder.cs program.
</font></font></p>
</div>

<h4><a id="h1-3-2-2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sample program Cylinder.cs</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First of all, we will build the side, but in the Cylinder class, we have prepared a function GenerateCap to generate the data of the vertices arranged around the circumference located at the upper end and the lower end.</font></font></p>
<div class="emlist-code">
<pre class="emlist language-cs">var vertices = new List&lt;Vector3&gt;();<font></font>
var normals = new List&lt;Vector3&gt;();<font></font>
var uvs = new List&lt;Vector2&gt;();<font></font>
var triangles = new List&lt;int&gt;();<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Top height and bottom height</font></font><font></font>
float top = height * 0.5f, bottom = -height * 0.5f;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Generate vertex data that makes up the side</font></font><font></font>
GenerateCap(segments + 1, top, bottom, radius, vertices, uvs, normals, true);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// To refer to the vertices on the circle when constructing the side triangles</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Divine for index to go around the circle</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
var len = (segments + 1) * 2;</font></font></font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Build the sides by connecting the top and bottom</font></font><font></font>
for (int i = 0; i &lt; segments + 1; i++) {<font></font>
    int idx = i * 2;<font></font>
    int a = idx, b = idx + 1, c = (idx + 2) % len, d = (idx + 3) % len;<font></font>
    triangles.Add(a);<font></font>
    triangles.Add(c);<font></font>
    triangles.Add(b);<font></font>
<font></font>
    triangles.Add(d);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    triangles.Add(b);</font></font></font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    triangles.Add(c);</font></font></font></font></font></font><font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the GenerateCap function, the vertex and normal data are set in the variable passed as List type.</font></font></p>
<div class="emlist-code">
<pre class="emlist language-cs">void GenerateCap(<font></font>
    int segments,<font></font>
    float top,<font></font>
    float bottom,<font></font>
    float radius,<font></font>
    List&lt;Vector3&gt; vertices,<font></font>
    List&lt;Vector2&gt; uvs,<font></font>
    List&lt;Vector3&gt; normals,<font></font>
    bool side<font></font>
) {<font></font>
    for (int i = 0; i &lt; segments; i++) {<font></font>
        // 0.0 ~ 1.0<font></font>
        float ratio = (float)i / (segments - 1);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // 0.0 ~ 2π</font></font></font></font></font></font><font></font>
        float rad = ratio * PI2;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Place vertices evenly at the top and bottom along the circumference</font></font><font></font>
        float cos = Mathf.Cos(rad), sin = Mathf.Sin(rad);<font></font>
        float x = cos * radius, z = sin * radius;<font></font>
        Vector3 tp = new Vector3(x, top, z), bp = new Vector3(x, bottom, z);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // upper end</font></font><font></font>
        vertices.Add(tp);<font></font>
        uvs.Add(new Vector2(ratio, 1f));<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Bottom edge</font></font><font></font>
        vertices.Add(bp);<font></font>
        uvs.Add(new Vector2(ratio, 0f));<font></font>
<font></font>
        if(side) {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // Normal to the outside of the side</font></font><font></font>
            var normal = new Vector3(cos, 0f, sin);<font></font>
            normals.Add(normal);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            normals.Add(normal);</font></font></font></font></font></font><font></font>
        } else {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            normals.Add (new Vector3 (0f, 1f, 0f)); // Normals pointing up the lid</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            normals.Add (new Vector3 (0f, -1f, 0f)); // Normals pointing down the lid</font></font><font></font>
        }<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the Cylinder class, you can set with the openEnded flag whether to make the model with the top and bottom closed. </font><font style="vertical-align: inherit;">If you want to close the top and bottom, form a circular "lid" and plug the ends.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The vertices that make up the surface of the lid do not use the vertices that make up the side, but create a new vertex at the same position as the side. </font><font style="vertical-align: inherit;">This is to separate the normals on the sides and the lid for natural lighting. </font><font style="vertical-align: inherit;">(When constructing the vertex data of the side, specify true in the side variable of the argument of GenerateCap, and when constructing the lid, specify false so that the appropriate normal direction is set.)</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the side and lid share the same vertex, the side and lid will refer to the same normal, which makes lighting unnatural.</font></font></p>
<div id="ProceduralModeling_cylinder_lighting" class="image">
<img src="./Chapter 1 _ Procedural Modeling Beginning with Unity_files/ProceduralModeling_cylinder_lighting.png" alt="When the side of the Cylinder and the apex of the lid are shared (left: BadCylinder.cs) and when another apex is prepared like the sample program (right: Cylinder.cs) The lighting is unnatural on the left.">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.9: When the side of Cylinder and the top of the lid are shared (left: BadCylinder.cs) and when another vertex is prepared as in the sample program (right: Cylinder.cs) The lighting on the left becomes unnatural. ing
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To model a circular lid, prepare vertices that are evenly arranged on the circumference (generated from the GenerateCap function) and vertices that are located in the middle of the circle, and the vertices along the circumference from the middle vertex. Join together to form a circular lid by building a triangle that resembles an evenly divided pizza.</font></font></p>
<div id="ProceduralModeling_cylinder_end" class="image">
<img src="./Chapter 1 _ Procedural Modeling Beginning with Unity_files/ProceduralModeling_cylinder_end.png" alt="Cylinder lid modeling example with segments parameter of 6">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.10: Cylinder lid modeling example with segments parameter of 6.
</font></font></p>
</div>
<div class="emlist-code">
<pre class="emlist language-cs"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Generate top and bottom lids</font></font><font></font>
if(openEnded) {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Add new vertices for lid model, not shared with sides, to use different normals when lighting</font></font><font></font>
    GenerateCap(<font></font>
        segments + 1,<font></font>
        top,<font></font>
        bottom,<font></font>
        radius,<font></font>
        vertices,<font></font>
        uvs,<font></font>
        normals,<font></font>
        false<font></font>
    );<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // The apex in the middle of the top lid</font></font><font></font>
    vertices.Add(new Vector3(0f, top, 0f));<font></font>
    uvs.Add(new Vector2(0.5f, 1f));<font></font>
    normals.Add(new Vector3(0f, 1f, 0f));<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // The apex in the middle of the bottom lid</font></font><font></font>
    vertices.Add(new Vector3(0f, bottom, 0f)); // bottom<font></font>
    uvs.Add(new Vector2(0.5f, 0f));<font></font>
    normals.Add(new Vector3(0f, -1f, 0f));<font></font>
<font></font>
    var it = vertices.Count - 2;<font></font>
    var ib = vertices.Count - 1;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // offset to avoid referencing the vertex index for the side</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    var offset = len;</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Top lid surface</font></font><font></font>
    for (int i = 0; i &lt; len; i += 2) {<font></font>
        triangles.Add(it);<font></font>
        triangles.Add((i + 2) % len + offset);<font></font>
        triangles.Add(i + offset);<font></font>
    }<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Bottom lid surface</font></font><font></font>
    for (int i = 1; i &lt; len; i += 2) {<font></font>
        triangles.Add(ib);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        triangles.Add(i + offset);</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        triangles.Add((i + 2) % len + offset);</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font>
}<font></font>
</pre>
</div>

<h3><a id="h1-3-3"></a><span class="secno">1.3.3　</span>Tubular</h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tubular is a tubular model that looks like the following figure.</font></font></p>
<div id="ProceduralModeling_tubular" class="image">
<img src="./Chapter 1 _ Procedural Modeling Beginning with Unity_files/ProceduralModeling_tubular.png" alt="Tubular model">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.11: Tubular model
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Cylinder model has a straight cylindrical shape, while the Tubular has a curved, untwisted cylinder. </font><font style="vertical-align: inherit;">In the example of the tree model described later, one branch is represented by Tubular, and a method of constructing one tree by combining them is adopted, but Tubular is used in situations where a tubular shape that bends smoothly is required. I will play an active part.</font></font></p>

<h4><a id="h1-3-3-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cylindrical structure</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The structure of the tubular model is as shown in the following figure.</font></font></p>
<div id="ProceduralModeling_tubular_structure" class="image">
<img src="./Chapter 1 _ Procedural Modeling Beginning with Unity_files/ProceduralModeling_tubular_structure.png" alt="Cylindrical structure Tubular visualizes the points that divide the curve along with a sphere, and the nodes that make up the sides with a hexagon.">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.12: Cylindrical structure Tubular visualizes the points that divide the curve along with a sphere and the nodes that make up the sides with a hexagon.
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Divide the curve, build sides for each node separated by the division points, and combine them to generate one Tubular model.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The sides of each node are similar to the sides of a cylinder, with the top and bottom vertices of the sides evenly arranged along a circle, and the cylinders are connected along a curve to build them together. You can think of things as Tubular types.</font></font></p>

<h4><a id="h1-3-3-2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">About curves</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the sample program, the base class CurveBase that represents a curve is prepared. </font><font style="vertical-align: inherit;">Various algorithms have been devised for drawing curves in three-dimensional space, and it is necessary to select an easy-to-use method according to the application. </font><font style="vertical-align: inherit;">In the sample program, the class CatmullRomCurve, which inherits the CurveBase class, is used.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will omit the details here, but CatmullRomCurve has the feature of forming a curve while interpolating between points so that it passes through all the passed control points, and it is easy to use because you can specify the points you want to pass through the curve. Has a good reputation for its goodness.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The CurveBase class that represents a curve provides GetPointAt (float) and GetTangentAt (float) functions to obtain the position and slope (tangent vector) of a point on the curve, and specify a value of [0.0 to 1.0] as an argument. By doing so, you can get the position and slope of the point between the start point (0.0) and the end point (1.0).</font></font></p>

<h4><a id="h1-3-3-3"></a>Frenet frame</h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To create a twist-free cylinder along a curve, three orthogonal vectors "tangent vector, normal vector, binormal vector" that change smoothly along the curve You will need an array. </font><font style="vertical-align: inherit;">The tangent vector is a unit vector that represents the slope at one point on the curve, and the normal vector and the normal vector are obtained as vectors that are orthogonal to each other.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With these orthogonal vectors, you can get "coordinates on the circumference orthogonal to the curve" at a point on the curve.</font></font></p>
<div id="ProceduralModeling_tubular_trigonometry" class="image">
<img src="./Chapter 1 _ Procedural Modeling Beginning with Unity_files/ProceduralModeling_tubular_trigonometry.png" alt="Find the unit vector (v) that points to the coordinates on the circumference from the normal and binormal. By multiplying this unit vector (v) by the radius radius, the radius radius orthogonal to the curve You can get the coordinates on the circumference">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.13: Find the unit vector (v) that points to the coordinates on the circumference from the normal and binormal. Multiply this unit vector (v) by the radius radius to make it orthogonal to the curve. You can get the coordinates on the circumference of the radius radius
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A set of three orthogonal vectors at a point on this curve is called a Frenet frame.</font></font></p>
<div id="ProceduralModeling_tubular_frenet_frame" class="image">
<img src="./Chapter 1 _ Procedural Modeling Beginning with Unity_files/ProceduralModeling_tubular_frenet_frame.png" alt="Visualization of the Frenet frame array that makes up Tubular The frame represents one Frenet frame, and the three arrows indicate the tangent vector, the normal vector, and the binormal vector.">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.14: Visualization of the Frenet frame array that makes up Tubular The frame represents one Frenet frame, and the three arrows indicate the tangent vector, the normal vector, and the binormal vector.
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tubular modeling is performed by finding the vertex data for each clause based on the normals and binormals obtained from this Frenet frame, and connecting them together.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the sample program, the CurveBase class has a function ComputeFrenetFrames to generate this Frenet frame array.</font></font></p>

<h4><a id="h1-3-3-4"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sample program Tubular.cs</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Tubular class has a CatmullRomCurve class that represents a curve, and forms a cylinder along the curve drawn by this CatmullRomCurve.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The CatmullRomCurve class requires four or more control points, and when you manipulate the control points, the shape of the curve changes, and the shape of the Tubular model changes accordingly.</font></font></p>
<div class="emlist-code">
<pre class="emlist language-cs">var vertices = new List&lt;Vector3&gt;();<font></font>
var normals = new List&lt;Vector3&gt;();<font></font>
var tangents = new List&lt;Vector4&gt;();<font></font>
var uvs = new List&lt;Vector2&gt;();<font></font>
var triangles = new List&lt;int&gt;();<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Get the Frenet frame from the curve</font></font><font></font>
var frames = curve.ComputeFrenetFrames(tubularSegments, closed);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Generate Tubular vertex data</font></font><font></font>
for(int i = 0; i &lt; tubularSegments; i++) {<font></font>
    GenerateSegment(curve, frames, vertices, normals, tangents, i);<font></font>
}<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Place the last vertex at the start of the curve if you want to generate a closed cylinder, or at the end of the curve if it is not closed</font></font><font></font>
GenerateSegment(<font></font>
    curve,<font></font>
    frames,<font></font>
    vertices,<font></font>
    normals,<font></font>
    tangents,<font></font>
    (!closed) ? tubularSegments : 0<font></font>
);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Set the uv coordinates from the start point of the curve to the end point</font></font><font></font>
for (int i = 0; i &lt;= tubularSegments; i++) {<font></font>
    for (int j = 0; j &lt;= radialSegments; j++) {<font></font>
        float u = 1f * j / radialSegments;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        float v = 1f * i / tubularSegments;</font></font></font></font></font></font><font></font>
        uvs.Add(new Vector2(u, v));<font></font>
    }<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Build the side</font></font><font></font>
for (int j = 1; j &lt;= tubularSegments; j++) {<font></font>
    for (int i = 1; i &lt;= radialSegments; i++) {<font></font>
        int a = (radialSegments + 1) * (j - 1) + (i - 1);<font></font>
        int b = (radialSegments + 1) * j + (i - 1);<font></font>
        int c = (radialSegments + 1) * j + i;<font></font>
        int d = (radialSegments + 1) * (j - 1) + i;<font></font>
<font></font>
        triangles.Add(a); triangles.Add(d); triangles.Add(b);<font></font>
        triangles.Add(b); triangles.Add(d); triangles.Add(c);<font></font>
    }<font></font>
}<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
var mesh = new Mesh ();</font></font></font></font></font></font><font></font>
mesh.vertices = vertices.ToArray();<font></font>
mesh.normals = normals.ToArray();<font></font>
mesh.tangents = tangents.ToArray();<font></font>
mesh.uv = uvs.ToArray();<font></font>
mesh.triangles = triangles.ToArray();<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function GenerateSegment calculates the vertex data of the specified clause based on the normal and binormal extracted from the Frenet frame mentioned above, and sets it in the variable passed in List type.</font></font></p>
<div class="emlist-code">
<pre class="emlist language-cs">void GenerateSegment(<font></font>
    CurveBase curve,<font></font>
    List&lt;FrenetFrame&gt; frames,<font></font>
    List&lt;Vector3&gt; vertices,<font></font>
    List&lt;Vector3&gt; normals,<font></font>
    List&lt;Vector4&gt; tangents,<font></font>
    int index<font></font>
) {<font></font>
    // 0.0 ~ 1.0<font></font>
    var u = 1f * index / tubularSegments;<font></font>
<font></font>
    var p = curve.GetPointAt(u);<font></font>
    var fr = frames[index];<font></font>
<font></font>
    var N = fr.Normal;<font></font>
    var B = fr.Binormal;<font></font>
<font></font>
    for(int j = 0; j &lt;= radialSegments; j++) {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // 0.0 ~ 2π</font></font></font></font></font></font><font></font>
        float rad = 1f * j / radialSegments * PI2;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Arrange the vertices evenly along the circumference</font></font><font></font>
        float cos = Mathf.Cos(rad), sin = Mathf.Sin(rad);<font></font>
        var v = (cos * N + sin * B).normalized;<font></font>
        vertices.Add(p + radius * v);<font></font>
        normals.Add(v);<font></font>
<font></font>
        var tangent = fr.Tangent;<font></font>
        tangents.Add(new Vector4(tangent.x, tangent.y, tangent.z, 0f));<font></font>
    }<font></font>
}<font></font>
</pre>
</div>

<h2><a id="h1-4"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.4　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Complex shape</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This section introduces techniques for generating more complex models using the Procedural Modeling techniques described so far.</font></font></p>

<h3><a id="h1-4-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.4.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plants</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plant modeling is often mentioned as an application of the Procedural Modeling technique. </font><font style="vertical-align: inherit;">The Tree API </font></font><a id="fnb-tree" href="https://freder.github.io/UnityGraphicsProgrammingBook1/articles/Nakamura.html#fn-tree" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for modeling trees in the Editor is also provided in Unity, </font><font style="vertical-align: inherit;">and there is </font><font style="vertical-align: inherit;">software dedicated to plant modeling called </font><font style="vertical-align: inherit;">Speed ​​Tree </font></font><a id="fnb-speedtree" href="https://freder.github.io/UnityGraphicsProgrammingBook1/articles/Nakamura.html#fn-speedtree" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p>
<div class="footnote" epub:type="footnote" id="fn-tree"><p class="footnote">[*4] https://docs.unity3d.com/ja/540/Manual/tree-FirstTree.html</p></div>
<div class="footnote" epub:type="footnote" id="fn-speedtree"><p class="footnote">[*5] http://www.speedtree.com/</p></div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this section, we will focus on modeling trees, which are relatively simple modeling methods among plants.</font></font></p>

<h3><a id="h1-4-2"></a><span class="secno">1.4.2　</span>L-System</h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is L-System as an algorithm that can describe and express the structure of plants. </font><font style="vertical-align: inherit;">The L-System was proposed by botanist Aristid Lindenmayer in 1968, and the L-System L comes from his name.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L-System can be used to express the self-similarity found in the shape of plants.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Self-similarity means that when you magnify the shape of the details of an object, it matches the shape of the object as seen on a large scale. For example, when observing the branching of a tree, the branching of the part near the trunk And, there is a similarity in the way the branches are divided near the tip.</font></font></p>
<div id="ProceduralModeling_tree_lsystem" class="image">
<img src="./Chapter 1 _ Procedural Modeling Beginning with Unity_files/ProceduralModeling_tree_lsystem.png" alt="A figure in which each branch is branched by changing by 30 degrees It can be seen that the root part and the branch tip part are similar, but even such a simple figure looks like a tree (sample program LSystem). .scene)">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.15: A figure in which each branch is branched by changing by 30 degrees. It can be seen that the root part and the branch tip part are similar, but even such a simple figure looks like a tree ( Sample program LSystem.scene)
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The L-System provides a mechanism for developing complex sequences of symbols by representing elements with symbols, defining rules to replace the symbols, and repeatedly applying the rules to the symbols.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, to give a simple example</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initial character string: a</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rewrite Rule 1: a-&gt; ab</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rewrite Rule 2: b-&gt; a</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you rewrite according to</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a -&gt; ab -&gt; aba -&gt; organize -&gt; organize -&gt; ...</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each step produces complex results.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of using this L-System for graphic generation is the LSystem class of the sample program.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the LSystem class, the following operations</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Draw: Draw a line in the direction you are facing</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Turn Left: Turn left by θ degrees</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Turn Right: Turn right by θ degrees</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is available,</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initial operation: Draw</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rewrite Rule 1: Draw-&gt; Turn Left | Turn Right</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rewrite Rule 2: Turn Left-&gt; Draw</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rewrite Rule 3: Turn Right-&gt; Draw</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">According to this, the rule is applied repeatedly a fixed number of times.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, you can draw a self-similar figure, as shown in the sample LSystem.scene. </font><font style="vertical-align: inherit;">The property of "recursively rewriting the state" of this L-System creates self-similarity. </font><font style="vertical-align: inherit;">Self-similarity is also called Fractal and is also a research area.</font></font></p>

<h3><a id="h1-4-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.4.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sample program ProceduralTree.cs</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As an example of actually applying L-System to a program that generates a tree model, we prepared a class called ProceduralTree.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In ProceduralTree, like the LSystem class explained in the previous section, the tree shape is generated by recursively calling the routine "advance branches, branch, and advance branches".</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the LSystem class in the previous section, the simple rule for branching was "branch in two directions, left and right at a fixed angle", but in ProceduralTree, random numbers are used, and the number of branches and the branching direction have randomness. However, we have set rules so that the branches branch in a complicated manner.</font></font></p>
<div id="ProceduralModeling_tree_ProceduralTree" class="image">
<img src="./Chapter 1 _ Procedural Modeling Beginning with Unity_files/ProceduralModeling_tree_ProceduralTree.png" alt="ProceduralTree.scene">
<p class="caption">
図1.16: ProceduralTree.scene
</p>
</div>

<h4><a id="h1-4-3-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TreeData class</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The TreeData class is a class that includes parameters that determine the degree of branching of branches and parameters that determine the size of the tree and the fineness of the mesh of the model. </font><font style="vertical-align: inherit;">You can design a tree shape by adjusting the parameters of an instance of this class.</font></font></p>

<h4><a id="h1-4-3-2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Branching</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use some parameters in the TreeData class to adjust the degree of branching.</font></font></p>

<h5><a id="h1-4-3-2-1"></a>branchesMin, branchesMax</h5>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The number of branches branching from one branch is adjusted by the branchesMin / branchesMax parameters. </font><font style="vertical-align: inherit;">branchesMin represents the minimum number of branches, branchesMax represents the maximum number of branches, and the number between branchesMin and branchesMax is randomly selected to determine the number of branches.</font></font></p>

<h5><a id="h1-4-3-2-2"></a>growthAngleMin, growthAngleMax, growthAngleScale</h5>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The direction in which the branching branches grow is adjusted with the growthAngleMin and growthAngleMax parameters. </font><font style="vertical-align: inherit;">GrowthAngleMin represents the minimum angle in the branching direction, and growthAngleMax represents the maximum angle. The number between growthAngleMin and growthAngleMax is randomly selected to determine the branching direction.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each branch has a tangent vector that represents the direction of extension, and a normal vector and a binormal vector as vectors that are orthogonal to it.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The value randomly obtained from the growthAngleMin / growAngleMax parameters is rotated in the direction of the normal vector and the direction of the binormal vector with respect to the tangent vector in the direction extending from the branch point.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By applying a random rotation to the tangent vector in the direction extending from the branch point, the direction in which the branch at the branch destination grows is changed, and the branching is changed in a complicated manner.</font></font></p>
<div id="ProceduralModeling_tree_branches" class="image">
<img src="./Chapter 1 _ Procedural Modeling Beginning with Unity_files/ProceduralModeling_tree_branches.png" alt="Random rotation applied in the direction extending from the branch point The T arrow at the branch point is the extending direction (tangent vector), the N arrow is the normal vector, and the B arrow is the binormal vector. Is expressed, and random rotation is applied in the direction of the normal and the normal with respect to the extending direction.">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.17: Random rotation applied in the direction extending from the branch point The T arrow at the branch point is the extending direction (tangent vector), the N arrow is the normal vector, and the B arrow is the normal line (normal vector). Binormal vector), and random rotation is applied in the direction of the normal and the normal with respect to the extending direction.
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The growthAngleScale parameter is provided so that the angle of rotation randomly applied in the direction in which the branch grows increases toward the tip of the branch. </font><font style="vertical-align: inherit;">This growthAngleScale parameter has a stronger effect on the rotation angle and increases the rotation angle as the generation parameter representing the generation of the branch instance approaches 0, that is, as it approaches the tip of the branch.</font></font></p>
<div class="emlist-code">
<pre class="emlist language-cs"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// The branching angle increases as the branch tip increases</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
var scale = Mathf.Lerp (</font></font></font></font></font></font><font></font>
    1f,<font></font>
    data.growthAngleScale,<font></font>
    1f - 1f * generation / generations<font></font>
);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Rotation in the normal direction</font></font><font></font>
var qn = Quaternion.AngleAxis(scale * data.GetRandomGrowthAngle(), normal);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Rotation in the binormal direction</font></font><font></font>
var qb = Quaternion.AngleAxis(scale * data.GetRandomGrowthAngle(), binormal);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Determine the position of the branch tip while rotating qn * qb in the tangent direction where the branch tip is facing</font></font><font></font>
this.to = from + (qn * qb) * tangent * length;<font></font>
</pre>
</div>

<h4><a id="h1-4-3-3"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TreeBranch class</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Branches are represented by the TreeBranch class.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you call the constructor with TreeData for setting the branch pattern as an argument in addition to the parameters of the number of generations (generations) and the basic length (length) and thickness (radius), it will recursively internally. An instance of TreeBranch will be created.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A TreeBranch that branches from one TreeBranch is stored in a children variable of type List &lt;TreeBranch&gt; in the original TreeBranch so that all branches can be traced from the root TreeBranch.</font></font></p>

<h4><a id="h1-4-3-4"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TreeSegment class</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Like Tubular, the model of one branch divides one curve, models the divided nodes as one Cylinder, and builds them so that they are connected.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The TreeSegment class is a class that expresses a clause that divides a single curve.</font></font></p>
<div class="emlist-code">
<pre class="emlist language-cs">public class TreeSegment {<font></font>
    public FrenetFrame Frame { get { return frame; } }<font></font>
    public Vector3 Position { get { return position; } }<font></font>
    public float Radius { get { return radius; } }<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Direction vector tangent, which Tree Segment is facing,</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // FrenetFrame with vectors normal and binormal orthogonal to it</font></font><font></font>
    FrenetFrame frame;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Position of Tree Segment</font></font><font></font>
    Vector3 position;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Tree Segment width (radius)</font></font><font></font>
    float radius;<font></font>
<font></font>
    public TreeSegment(FrenetFrame frame, Vector3 position, float radius) {<font></font>
        this.frame = frame;<font></font>
        this.position = position;<font></font>
        this.radius = radius;<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One TreeSegment has a FrenetFrame, which is a set of a vector in the direction in which the node is facing and an orthogonal vector, and variables that represent the position and width, and holds the necessary information at the top and bottom when building a Cylinder.</font></font></p>

<h4><a id="h1-4-3-5"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Procedural Tree model generation</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The model generation logic of Procedural Tree is an application of Tubular, which generates a Tubular model from the array of Tree Segments of one branch Tree Branch and aggregates them into one model to form the whole tree. Modeling with an approach.</font></font></p>
<div class="emlist-code">
<pre class="emlist language-cs"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">var root = new TreeBranch (</font></font></font></font></font></font><font></font>
    generations,<font></font>
    length,<font></font>
    radius,<font></font>
    data<font></font>
);<font></font>
<font></font>
var vertices = new List&lt;Vector3&gt;();<font></font>
var normals = new List&lt;Vector3&gt;();<font></font>
var tangents = new List&lt;Vector4&gt;();<font></font>
var uvs = new List&lt;Vector2&gt;();<font></font>
var triangles = new List&lt;int&gt;();<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Get the total length of the tree</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Divide the length of the branch by the total length to get the height of the uv coordinates (uv.y)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Set to change from the root to the tip of the branch with [0.0 ~ 1.0]</font></font><font></font>
float maxLength = TraverseMaxLength(root);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Recursively follow all branches and generate a mesh corresponding to each branch</font></font><font></font>
Traverse(root, (branch) =&gt; {<font></font>
    var offset = vertices.Count;<font></font>
<font></font>
    var vOffset = branch.Offset / maxLength;<font></font>
    var vLength = branch.Length / maxLength;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Generate vertex data from a single branch</font></font><font></font>
    for(int i = 0, n = branch.Segments.Count; i &lt; n; i++) {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        var t = 1f * i / (n - 1);</font></font></font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        var v = vOffset + vLength * t;</font></font></font></font></font></font><font></font>
<font></font>
        var segment = branch.Segments[i];<font></font>
        var N = segment.Frame.Normal;<font></font>
        var B = segment.Frame.Binormal;<font></font>
        for(int j = 0; j &lt;= data.radialSegments; j++) {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // 0.0 ~ 2π</font></font></font></font></font></font><font></font>
            var u = 1f * j / data.radialSegments;<font></font>
            float rad = u * PI2;<font></font>
<font></font>
            float cos = Mathf.Cos(rad), sin = Mathf.Sin(rad);<font></font>
            var normal = (cos * N + sin * B).normalized;<font></font>
            vertices.Add(segment.Position + segment.Radius * normal);<font></font>
            normals.Add(normal);<font></font>
<font></font>
            var tangent = segment.Frame.Tangent;<font></font>
            tangents.Add(new Vector4(tangent.x, tangent.y, tangent.z, 0f));<font></font>
<font></font>
            uvs.Add(new Vector2(u, v));<font></font>
        }<font></font>
    }<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Build a one-branch triangle</font></font><font></font>
    for (int j = 1; j &lt;= data.heightSegments; j++) {<font></font>
        for (int i = 1; i &lt;= data.radialSegments; i++) {<font></font>
            int a = (data.radialSegments + 1) * (j - 1) + (i - 1);<font></font>
            int b = (data.radialSegments + 1) * j + (i - 1);<font></font>
            int c = (data.radialSegments + 1) * j + i;<font></font>
            int d = (data.radialSegments + 1) * (j - 1) + i;<font></font>
<font></font>
            a += offset;<font></font>
            b += offset;<font></font>
            c += offset;<font></font>
            d += offset;<font></font>
<font></font>
            triangles.Add(a); triangles.Add(d); triangles.Add(b);<font></font>
            triangles.Add(b); triangles.Add(d); triangles.Add(c);<font></font>
        }<font></font>
    }<font></font>
});<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
var mesh = new Mesh ();</font></font></font></font></font></font><font></font>
mesh.vertices = vertices.ToArray();<font></font>
mesh.normals = normals.ToArray();<font></font>
mesh.tangents = tangents.ToArray();<font></font>
mesh.uv = uvs.ToArray();<font></font>
mesh.triangles = triangles.ToArray();<font></font>
mesh.RecalculateBounds();<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Procedural modeling of plants is deep even with trees alone, and methods such as obtaining a model of a natural tree by branching so that the irradiation rate of sunlight is high have been devised.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you are interested in modeling such plants, please refer to The Algorithmic Beauty of Plants </font></font><a id="fnb-abop" href="https://freder.github.io/UnityGraphicsProgrammingBook1/articles/Nakamura.html#fn-abop" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 6</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">which was written by Aristid Lindenmayer, who invented the L-System, </font><font style="vertical-align: inherit;">for various methods.</font></font></p>
<div class="footnote" epub:type="footnote" id="fn-abop"><p class="footnote">[*6] http://algorithmicbotany.org/papers/#abop</p></div>

<h2><a id="h1-5"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.5　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Application example of procedural modeling</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the procedural modeling examples introduced so far, we have learned the advantages of the technique of "dynamically generating a model while changing it according to parameters". </font><font style="vertical-align: inherit;">You may get the impression that it is a technology for improving the efficiency of content development because you can efficiently create models of various variations.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, like modeling tools and sculpting tools out there, procedural modeling techniques can also be applied to "interactively generate models in response to user input."</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As an application example, we will introduce "Teddy," a technology that generates a three-dimensional model from contour lines created by handwritten sketches, devised by Takeo Igarashi of the Department of Computer Science, the University of Tokyo.</font></font></p>
<div id="ProceduralModeling_teddy" class="image">
<img src="./Chapter 1 _ Procedural Modeling Beginning with Unity_files/ProceduralModeling_teddy.png" alt="Unity assets of &quot;Teddy&quot;, a technology for 3D modeling by hand-drawn sketches http://uniteddy.info/ja">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.18: Unity assets of "Teddy", a technology for 3D modeling by hand-drawn sketches http://uniteddy.info/ja
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This technology was actually used in the game </font><font style="vertical-align: inherit;">"Junk Masterpiece Theater Rakugaki Kingdom" </font></font><a id="fnb-rakugaki" href="https://freder.github.io/UnityGraphicsProgrammingBook1/articles/Nakamura.html#fn-rakugaki" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 7,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> which was released as software for PlayStation 2 in 2002, and </font><font style="vertical-align: inherit;">it is said that "the picture you drew is converted to 3D and moved as an in-game character". The application has been realized.</font></font></p>
<div class="footnote" epub:type="footnote" id="fn-rakugaki"><p class="footnote"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[* 7] https://ja.wikipedia.org/wiki/Kingdom of Rakugaki</font></font></font></font></p></div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With this technology</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Define a line drawn on a two-dimensional plane as an outline</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A meshing process called </font><font style="vertical-align: inherit;">Delaunay Triangulation </font></font><a id="fnb-delaunay" href="https://freder.github.io/UnityGraphicsProgrammingBook1/articles/Nakamura.html#fn-delaunay" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 8</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is applied </font><font style="vertical-align: inherit;">to the point array that constitutes the contour line.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apply the algorithm to inflate the mesh on the obtained 2D plane into a solid.</font></font></li>
</ul>
<div class="footnote" epub:type="footnote" id="fn-delaunay"><p class="footnote">[*8] https://en.wikipedia.org/wiki/Delaunay_triangulation</p></div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The 3D model is generated by the procedure. </font><font style="vertical-align: inherit;">Regarding the details of the algorithm, a paper presented at SIGGRAPH, an international conference dealing with computer graphics, has been published. </font></font><a id="fnb-teddy" href="https://freder.github.io/UnityGraphicsProgrammingBook1/articles/Nakamura.html#fn-teddy" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 9</font></font></a></p>
<div class="footnote" epub:type="footnote" id="fn-teddy"><p class="footnote">[*9] http://www-ui.is.s.u-tokyo.ac.jp/~takeo/papers/siggraph99.pdf</p></div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The version of Teddy ported to Unity is published in the Asset Store, so anyone can incorporate this technology into their content. </font></font><a id="fnb-uniteddy" href="https://freder.github.io/UnityGraphicsProgrammingBook1/articles/Nakamura.html#fn-uniteddy" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*Ten</font></font></a></p>
<div class="footnote" epub:type="footnote" id="fn-uniteddy"><p class="footnote">[*10] http://uniteddy.info/ja/</p></div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By using procedural modeling techniques in this way, it is possible to develop unique modeling tools and create content that develops according to the user's creation.</font></font></p>

<h2><a id="h1-6"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.6　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Summary</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With procedural modeling techniques</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Streamlining model generation (under certain conditions)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Development of tools and contents that interactively generate models according to user operations</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I have seen that can be achieved.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since Unity itself is a game engine, you can imagine its application in games and video content from the examples introduced in this chapter.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, just as computer graphics technology itself has a wide range of applications, it can be considered that the range of applications for model generation technology is also wide. </font><font style="vertical-align: inherit;">As I mentioned at the beginning, procedural modeling techniques are also used in the fields of architecture and product design, and with the development of digital fabrication such as 3D printer technology, there are opportunities to use the designed shapes in real life. Is also increasing at the individual level.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this way, if you think about the fields in which you will use the designed shapes from a broad perspective, you may find various situations where you can apply procedural modeling techniques.</font></font></p>

<h2><a id="h1-7"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.7　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reference</font></font></h2>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CEDEC2008 Computer automatically generates content with intelligence --What is procedural technology?-Http://news.mynavi.jp/articles/2008/10/08/cedec03/</font></font></li>
<li>The Algorithmic Beauty of Plants - http://algorithmicbotany.org/papers</li>
<li>nervous system - http://n-e-r-v-o-u-s.com/</li>
</ul></body></html>