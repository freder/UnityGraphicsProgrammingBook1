<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="en" style="height: 100%;" class="translated-ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <link rel="stylesheet" type="text/css" href="./Chapter 6 _ Growing grass with geometry shaders_files/style.scss">
  <meta name="generator" content="Re:VIEW">
  <title>Grow grass with geometry shaders</title>

			<style>
				img {
					max-width: 80vw;
					max-height: 80vh;
				}
			</style><style>
					.goog-te-banner-frame {
						display: none;
					}
				</style>
			<script>(function(){(function injection() {
  var pageLang = 'ja';
  var userLang = 'en';

  var uid = '1E07F158C6FA4460B352973E9693B329';
  var teId = 'TE_' + uid;
  var cbId = 'TECB_' + uid;

  function show() {
    window.setTimeout(function() {
      window[teId].showBanner(true);
    }, 10);
  }

  function newElem() {
    
  }

  if (window[teId]) {
    show();
  } else {
    if (!window.google || !google.translate ||
        !google.translate.TranslateElement) {
      if (!window[cbId]) {
        window[cbId] = function() {
          window[teId] = newElem();
          show();
        };
      }
      
    }
  }
})();})();</script><script src="https://translate.google.com/translate_a/element.js?cb=TECB_1E07F158C6FA4460B352973E9693B329&amp;client=tee&amp;hl=en"></script><script src="./Chapter 6 _ Growing grass with geometry shaders_files/f.txt"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://translate.googleapis.com/translate_static/css/translateelement.css"><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/translate_static/js/element/main.js"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="./Chapter 6 _ Growing grass with geometry shaders_files/translateelement.css"><script type="text/javascript" charset="UTF-8" src="./Chapter 6 _ Growing grass with geometry shaders_files/main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script><script type="text/javascript" charset="UTF-8" src="./Chapter 6 _ Growing grass with geometry shaders_files/element_main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://translate.googleapis.com/translate_static/css/translateelement.css"><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/translate_static/js/element/main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script></head>
		
<body style="position: relative; min-height: 100%; top: 40px;"><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div>
<h1><a id="h6"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chapter 6　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Growing grass with geometry shaders</font></font></h1>

<h2><a id="h6-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Introduction</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This chapter mainly describes Geometry Shader, which is one of the stages of the rendering pipeline, and explains the dynamic grass-generating shader (commonly known as Grass Shader) using Geometry Shader.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I've used some technical terms to describe the Geometry Shader, but if you're just trying to use the Geometry Shader, it's a good idea to take a look at the sample code.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Unity project in this chapter has been uploaded to the following Github repository.</font></font></p>
<p><a href="https://github.com/IndieVisualLab/UnityGraphicsProgramming/" class="link">https://github.com/IndieVisualLab/UnityGraphicsProgramming/</a></p>

<h2><a id="h6-2"></a><span class="secno">6.2　</span>Geometry Shaderとは？</h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geometry Shader is one of the programmable shaders that can dynamically convert, generate, and delete primitives (basic shapes that make up a mesh) on the GPU.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Until now, if you try to change the mesh shape dynamically, such as by converting primitives, you need to take measures such as processing on the CPU or giving meta information to the vertices in advance and converting with Vertex Shader. did. </font><font style="vertical-align: inherit;">However, Vertex Shader cannot acquire information about adjacent vertices, and there are strong restrictions such as not being able to create new vertices based on the vertices being processed and vice versa. .. </font><font style="vertical-align: inherit;">However, processing with a CPU would take an unrealistically huge amount of time from the perspective of real-time processing. </font><font style="vertical-align: inherit;">As you can see, there have been some problems with changing the shape of the mesh in real time.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, Geometry Shader is installed as standard in DirectX 10 and OpenGL 3.2 as a function to solve these problems and enable free conversion processing within weak constraints. </font><font style="vertical-align: inherit;">In OpenGL, it is also called Primitive Shader.</font></font></p>

<h2><a id="h6-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Features of Geometry Shader</font></font></h2>

<h3><a id="h6-3-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rendering pipeline</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is located on the rendering pipeline after Vertex Shader and before Fragment Shader and rasterization. </font><font style="vertical-align: inherit;">In other words, within the Fragment Shader, the vertices dynamically generated by the Geometry Shader and the original vertices passed to the Vertex Shader are processed without distinction.</font></font></p>

<h3><a id="h6-3-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Input to Geometry Shader</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normally, the input information to Vertex Shader is in units of vertices, and conversion processing is performed for those vertices. </font><font style="vertical-align: inherit;">However, the input information to the Geometry Shader is a user-defined input primitive unit.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The actual program will be described later, but the vertex information group processed by Vertex Shader will be divided and input based on the input primitive type. </font><font style="vertical-align: inherit;">For example, if the input primitive type is triangle, three vertex information will be passed, if line, two vertex information will be passed, and if point, one vertex information will be passed. </font><font style="vertical-align: inherit;">This makes it possible to perform processing while referring to other vertex information, which was not possible with vertex shader, and enables a wide range of calculations.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One thing to note is that Vertex Shader processes on a vertex-by-vertex basis and passes information about the vertices it processes, but Geometry Shader is a primitive assembly topology regardless of the input primitive type. Processing is performed in units of primitives determined by. </font><font style="vertical-align: inherit;">In other words, if you run the Geometry Shader on a Quad mesh with a topology of Triangles, as shown in Figure 6.1, the Geometry Shader will be run twice for triangles ① and ②. </font><font style="vertical-align: inherit;">At this time, when the primitive type for input is Line, the information passed to the input is the vertices of two vertices 0,1,2 in the case of triangle ①, and the vertices 0,2,3 in the case of ②. It will be the apex of the two points.</font></font></p>
<div id="id_aoyama_2Fimg0" class="image">
<img src="./Chapter 6 _ Growing grass with geometry shaders_files/img0.png" alt="Quad mesh" class="width-040per">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 6.1: Quad mesh
</font></font></p>
</div>

<h3><a id="h6-3-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Output from Geometry Shader</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The output of Geometry Shader is a set of vertex information for user-defined output primitive types. </font><font style="vertical-align: inherit;">In Vertex Shader, it was 1 input and 1 output, but Geometry Shader will output multiple information, and there is no problem even if there is one or more primitives generated by the output information.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, if the output primitive type is defined as triangle and a total of 9 vertices newly calculated are output, 3 triangles are generated by Geometry Shader. </font><font style="vertical-align: inherit;">Since this process is performed in primitive units as described above, it is possible that the number of triangles that were originally one has increased to three.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, it is necessary to set in advance the maximum number of vertices to be output in one process called MaxVertexCount in Geometry Shader. </font><font style="vertical-align: inherit;">For example, if MaxVertexCount is set to 9, Geometry Shader will be able to output the number of vertices from 0 to 9 points. </font><font style="vertical-align: inherit;">Due to the "Geometry Shader Limits" described later, 1024 is generally the maximum value for this value.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, as a point to be careful when outputting vertex information, when adding a new vertex while maintaining the original mesh shape, the vertex information sent from Vertex Shader is also sent to Geometry Shader. Must be output. </font><font style="vertical-align: inherit;">The Geometry Shader does not have the behavior of adding to the output of the Vertex Shader, but the output of the Geometry Shader is rasterized and passed to the Fragment Shader. </font><font style="vertical-align: inherit;">Paradoxically, you can also dynamically reduce the number of vertices by setting the output of the Geometry Shader to 0.</font></font></p>

<h3><a id="h6-3-4"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3.4　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Geometry Shader Limits</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Geometry Shader has a maximum number of output vertices and a maximum number of output elements for one output. </font><font style="vertical-align: inherit;">The maximum number of output vertices is literally the limit value of the number of vertices, and although it depends on the GPU, 1024 is common, so you can increase the number of vertices from one triangle to a maximum of 1024 points. </font><font style="vertical-align: inherit;">The elements in the maximum number of output elements are the information that the vertices have, such as coordinates and colors. Generally, the position elements of (x, y, z, w) and (r, g, b, a) There are a total of 8 color elements. </font><font style="vertical-align: inherit;">The maximum number of outputs of this element also depends on the GPU, but since 1024 is also common, the output will be limited to 128 (1024/8) at the maximum.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since both of these restrictions must be met, even if the number of vertices can be output at 1024 points, the actual output of the Geometry Shader is limited to 128 points due to restrictions on the number of elements. </font><font style="vertical-align: inherit;">So, for example, if you use Geometry Shader for a mesh with 2 primitives (Quad mesh, etc.), you can handle only up to 256 vertices (128 points * 2 primitives). ..</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This number of 128 points is the limit value of the value that can be set in MaxVertexCount in the previous section.</font></font></p>

<h2><a id="h6-4"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.4　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Simple Geometry Shader</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below is a Geometry Shader program with simple behavior. </font><font style="vertical-align: inherit;">I will explain the explanation up to the previous section again by comparing it with the actual program.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to Geometry Shader, the explanation about ShaderLab syntax etc. required when writing shaders in Unity is omitted in this chapter, so if you have any questions, please refer to the official document below.</font></font></p>
<p><a href="https://docs.unity3d.com/ja/current/Manual/SL-Reference.html" class="link">https://docs.unity3d.com/ja/current/Manual/SL-Reference.html</a></p>
<div class="emlist-code">
<pre class="emlist language-cs">Shader "Custom/SimpleGeometryShader"<font></font>
{<font></font>
    Properties<font></font>
    {<font></font>
        _Height("Height", float) = 5.0<font></font>
        _TopColor("Top Color", Color) = (0.0, 0.0, 1.0, 1.0)<font></font>
        _BottomColor("Bottom Color", Color) = (1.0, 0.0, 0.0, 1.0)<font></font>
    }<font></font>
    SubShader<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    {</font></font></font></font><font></font>
        Tags { "RenderType" = "Opaque"}<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        LOD 100</font></font></font></font><font></font>
<font></font>
        Cull Off<font></font>
        Lighting Off<font></font>
<font></font>
        Pass<font></font>
        {<font></font>
            CGPROGRAM<font></font>
            #pragma target 5.0<font></font>
            #pragma vertex vert<font></font>
            #pragma geometry geom<font></font>
            #pragma fragment frag<font></font>
            #include "UnityCG.cginc"<font></font>
<font></font>
            uniform float _Height;<font></font>
            uniform float4 _TopColor, _BottomColor;<font></font>
<font></font>
            struct v2g<font></font>
            {<font></font>
                float4 pos : SV_POSITION;<font></font>
            };<font></font>
<font></font>
            struct g2f<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            {</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                float4 pos : SV_POSITION;</font></font></font></font><font></font>
                float4 col : COLOR;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            };</font></font></font></font><font></font>
<font></font>
            v2g vert(appdata_full v)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            {</font></font></font></font><font></font>
                v2g o;<font></font>
                o.pos = v.vertex;<font></font>
<font></font>
                return o;<font></font>
            }<font></font>
<font></font>
            [maxvertexcount(12)]<font></font>
            void geom(triangle v2g input[3],<font></font>
                      inout TriangleStream&lt;g2f&gt; outStream)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            {</font></font></font></font><font></font>
                float4 p0 = input[0].pos;<font></font>
                float4 p1 = input[1].pos;<font></font>
                float4 p2 = input[2].pos;<font></font>
<font></font>
                float4 c = float4(0.0f, 0.0f, -_Height, 1.0f)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                            + (p0 + p1 + p2) * 0.33333f;</font></font></font></font><font></font>
<font></font>
                g2f out0;<font></font>
                out0.pos = UnityObjectToClipPos(p0);<font></font>
                out0.col = _BottomColor;<font></font>
<font></font>
                g2f out1;<font></font>
                out1.pos = UnityObjectToClipPos(p1);<font></font>
                out1.col = _BottomColor;<font></font>
<font></font>
                g2f out2;<font></font>
                out2.pos = UnityObjectToClipPos(p2);<font></font>
                out2.col = _BottomColor;<font></font>
<font></font>
                g2f o;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                o.pos = UnityObjectToClipPos (c);</font></font></font></font><font></font>
                o.col = _TopColor;<font></font>
<font></font>
                // bottom<font></font>
                outStream.Append(out0);<font></font>
                outStream.Append(out1);<font></font>
                outStream.Append(out2);<font></font>
                outStream.RestartStrip();<font></font>
<font></font>
                // sides<font></font>
                outStream.Append(out0);<font></font>
                outStream.Append(out1);<font></font>
                outStream.Append(o);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                outStream.RestartStrip();</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                outStream.Append(out1);</font></font></font></font><font></font>
                outStream.Append(out2);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                outStream.Append(o);</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                outStream.RestartStrip();</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                outStream.Append(out2);</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                outStream.Append(out0);</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                outStream.Append(o);</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                outStream.RestartStrip();</font></font></font></font><font></font>
            }<font></font>
<font></font>
            float4 frag(g2f i) : COLOR<font></font>
            {<font></font>
                return i.col;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            }</font></font></font></font><font></font>
            ENDCG<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this shader, the center coordinates of the passed triangle are calculated and moved further upward, and each vertex of the passed triangle is connected to the calculated new coordinates. </font><font style="vertical-align: inherit;">In other words, we are generating a simple triangular pyramid from a flat triangle.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So if you apply this shader to a Quad mesh (consisting of two triangles), it will look like Figures 6.2 through 6.3.</font></font></p>
<div id="id_aoyama_2Fimg1" class="image">
<img src="./Chapter 6 _ Growing grass with geometry shaders_files/img1.png" alt="From a flat plate like this" class="width-040per">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 6.2: From a flat plate like this
</font></font></p>
</div>
<div id="id_aoyama_2Fimg2" class="image">
<img src="./Chapter 6 _ Growing grass with geometry shaders_files/img2.png" alt="Two three-dimensional triangular pyramids will be displayed" class="width-040per">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 6.3: Two three-dimensional triangular pyramids are now displayed
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this shader, I will extract and explain only the part related to Geometry Shader in particular.</font></font></p>
<div class="emlist-code">
<pre class="emlist language-cs">#pragma target 5.0<font></font>
#pragma vertex vert<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Declare the use of Geometry Shader</font></font><font></font>
#pragma geometry geom<font></font>
<font></font>
#pragma fragment frag<font></font>
#include "UnityCG.cginc"<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the above declaration part, </font></font><code class="tt">geom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we declare that the function named is a function for Geometry Shader. </font><font style="vertical-align: inherit;">This </font></font><code class="tt">geom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will cause the function to be called </font><font style="vertical-align: inherit;">when the Geometry Shader stage is reached </font><font style="vertical-align: inherit;">.</font></font></p>
<div class="emlist-code">
<pre class="emlist language-cs">[maxvertexcount(12)]<font></font>
void geom(triangle v2g input[3], inout TriangleStream&lt;g2f&gt; outStream)<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the function declaration for the Geometry Shader.</font></font></p>

<h3><a id="h6-4-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.4.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Input</font></font></h3>
<div class="emlist-code">
<pre class="emlist language-cs">triangle v2f input[3]
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the part related to input.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This time, I want to generate a triangular pyramid based on the triangle, so I input </font></font><code class="tt">triangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it. </font><font style="vertical-align: inherit;">As a result, the information of each vertex of the triangle, which is the unit primitive, is input, and since the triangle is composed of three vertices, the received formal argument is an array of length 3. </font><font style="vertical-align: inherit;">So, if the input </font></font><code class="tt">triangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is not </font><font style="vertical-align: inherit;">input </font><font style="vertical-align: inherit;">, </font></font><code class="tt">point</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">only one vertex will be composed, so </font></font><code class="tt">geom(point v2f input[1])</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it will be received as an array of length 1 like.</font></font></p>

<h3><a id="h6-4-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.4.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Output</font></font></h3>
<div class="emlist-code">
<pre class="emlist language-cs">inout TriangleStream&lt;g2f&gt; outStream
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the part related to output.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since we want to make the primitive of the mesh generated this time a triangle, </font></font><code class="tt">TriangleStream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we declare it with </font><font style="vertical-align: inherit;">a </font><font style="vertical-align: inherit;">type. </font></font><code class="tt">TriangleStrema</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the type means that the output is a triangle strip, it will generate a triangle based on each output vertex information. </font><font style="vertical-align: inherit;">There are other </font></font><code class="tt">PointStream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">types and </font></font><code class="tt">LineStream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">types, so you need to select the output primitive type according to your purpose.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, </font></font><code class="tt">[maxvertexcount(12)]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the maximum number of outputs is set to 12 in the part. </font><font style="vertical-align: inherit;">This is because the number of triangles that make up the triangular pyramid is one at the base and three at the side, for a total of four, and three vertices are required for each triangle, so 12 vertices are output with 3 * 4. It is set to 12 because it will be different.</font></font></p>

<h3><a id="h6-4-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.4.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Processing</font></font></h3>
<div class="emlist-code">
<pre class="emlist language-cs">g2f out0;<font></font>
out0.pos = UnityObjectToClipPos(p0);<font></font>
out0.col = _BottomColor;<font></font>
<font></font>
g2f out1;<font></font>
out1.pos = UnityObjectToClipPos(p1);<font></font>
out1.col = _BottomColor;<font></font>
<font></font>
g2f out2;<font></font>
out2.pos = UnityObjectToClipPos(p2);<font></font>
out2.col = _BottomColor;<font></font>
<font></font>
g2f o;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
o.pos = UnityObjectToClipPos (c);</font></font></font></font><font></font>
o.col = _TopColor;<font></font>
<font></font>
// bottom<font></font>
outStream.Append(out0);<font></font>
outStream.Append(out1);<font></font>
outStream.Append(out2);<font></font>
outStream.RestartStrip();<font></font>
<font></font>
// sides<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
outStream.Append(out0);</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
outStream.Append(out1);</font></font></font></font><font></font>
outStream.Append(o);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
outStream.RestartStrip();</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
outStream.Append(out1);</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
outStream.Append(out2);</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
outStream.Append(o);</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
outStream.RestartStrip();</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
outStream.Append(out2);</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
outStream.Append(out0);</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
outStream.Append(o);</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
outStream.RestartStrip();</font></font></font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the part of the process that outputs the actual vertices.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First of all, a g2f type variable for output is declared, and vertex coordinates and color information are stored. </font><font style="vertical-align: inherit;">At this time, it is necessary to convert from the object space to the clip space of the camera in the same way as Vertex Shader.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After that, the vertex information is output while being aware of the order of the vertices that make up the mesh. </font></font><code class="tt">outStream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of the variable </font></font><code class="tt">Append</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be added to the current stream by passing the output variable to the function, </font></font><code class="tt">RestartStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to end the current primitive strip by calling the function, you have to start a new stream.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since this is a </font></font><code class="tt">TriangleStream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">triangle strip, the more </font></font><code class="tt">Append</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vertices you add in the function, the more connected triangles will be generated based on all the vertices added to the stream. </font><font style="vertical-align: inherit;">So, </font></font><code class="tt">Append</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if </font></font><code class="tt">RestartStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">you don't want </font><font style="vertical-align: inherit;">to be connected based on the order in which the </font><font style="vertical-align: inherit;">triangles are </font><font style="vertical-align: inherit;">connected </font><font style="vertical-align: inherit;">like this time, </font><font style="vertical-align: inherit;">you need to call </font><font style="vertical-align: inherit;">once </font><font style="vertical-align: inherit;">to start a new stream. </font><font style="vertical-align: inherit;">Of course, </font><font style="vertical-align: inherit;">it is possible to reduce the number </font></font><code class="tt">Append</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of </font></font><code class="tt">RestartStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">function calls </font><font style="vertical-align: inherit;">by devising the order </font><font style="vertical-align: inherit;">.</font></font></p>

<h2><a id="h6-5"></a><span class="secno">6.5　</span>Grass Shader</h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this section, we will explain Grass Shader, which is a little development from the previous section "Simple Geometry Shader", and uses Geometry Shader to generate grass in real time.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following is the Grass Shader program described.</font></font></p>
<div class="emlist-code">
<pre class="emlist language-cs">Shader "Custom/Grass" {<font></font>
    Properties<font></font>
    {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Grass height</font></font><font></font>
        _Height("Height", float) = 80<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Grass width</font></font><font></font>
        _Width("Width", float) = 2.5<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // The height of the bottom of the grass</font></font><font></font>
        _BottomHeight("Bottom Height", float) = 0.3<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Height of the middle part of the grass</font></font><font></font>
        _MiddleHeight("Middle Height", float) = 0.4<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Height of the top of the grass</font></font><font></font>
        _TopHeight("Top Height", float) = 0.5<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // The width of the bottom of the grass</font></font><font></font>
        _BottomWidth("Bottom Width", float) = 0.5<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Width of the middle part of the grass</font></font><font></font>
        _MiddleWidth("Middle Width", float) = 0.4<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // The width of the top of the grass</font></font><font></font>
        _TopWidth("Top Width", float) = 0.2<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // How the bottom of the grass bends</font></font><font></font>
        _BottomBend("Bottom Bend", float) = 1.0<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // How the middle part of the grass bends</font></font><font></font>
        _MiddleBend("Middle Bend", float) = 1.0<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // How the top of the grass bends</font></font><font></font>
        _TopBend("Top Bend", float) = 2.0<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Wind strength</font></font><font></font>
        _WindPower("Wind Power", float) = 1.0<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // The color of the top of the grass</font></font><font></font>
        _TopColor("Top Color", Color) = (1.0, 1.0, 1.0, 1.0)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // The color of the bottom of the grass</font></font><font></font>
        _BottomColor("Bottom Color", Color) = (0.0, 0.0, 0.0, 1.0)<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Noise texture that gives randomness to grass height</font></font><font></font>
        _HeightMap("Height Map", 2D) = "white"<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Noise texture that gives randomness to the orientation of the grass</font></font><font></font>
        _RotationMap("Rotation Map", 2D) = "black"<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Noise texture that gives randomness to wind strength</font></font><font></font>
        _WindMap("Wind Map", 2D) = "black"<font></font>
    }<font></font>
    SubShader<font></font>
    {<font></font>
        Tags{ "RenderType" = "Opaque" }<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        LOD 100</font></font></font></font><font></font>
        Cull Off<font></font>
<font></font>
        Pass<font></font>
        {<font></font>
            CGPROGRAM<font></font>
            #pragma target 5.0<font></font>
            #include "UnityCG.cginc"<font></font>
<font></font>
            #pragma vertex vert<font></font>
            #pragma geometry geom<font></font>
            #pragma fragment frag<font></font>
<font></font>
            float _Height, _Width;<font></font>
            float _BottomHeight, _MiddleHeight, _TopHeight;<font></font>
            float _BottomWidth, _MiddleWidth, _TopWidth;<font></font>
            float _BottomBend, _MiddleBend, _TopBend;<font></font>
<font></font>
            float _WindPower;<font></font>
            float4 _TopColor, _BottomColor;<font></font>
            sampler2D _HeightMap, _RotationMap, _WindMap;<font></font>
<font></font>
            struct v2g<font></font>
            {<font></font>
                float4 pos : SV_POSITION;<font></font>
                float3 nor : NORMAL;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                float4 hey: TEXCOORD0;</font></font><font></font>
                float4 rot : TEXCOORD1;<font></font>
                float4 wind : TEXCOORD2;<font></font>
            };<font></font>
<font></font>
            struct g2f<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            {</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                float4 pos : SV_POSITION;</font></font></font></font><font></font>
                float4 color : COLOR;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            };</font></font></font></font><font></font>
<font></font>
            v2g vert(appdata_full v)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            {</font></font></font></font><font></font>
                v2g o;<font></font>
                float4 uv = float4(v.texcoord.xy, 0.0f, 0.0f);<font></font>
<font></font>
                o.pos = v.vertex;<font></font>
                o.nor = v.normal;<font></font>
                o.hei = tex2Dlod(_HeightMap, uv);<font></font>
                o.rot = tex2Dlod(_RotationMap, uv);<font></font>
                o.wind = tex2Dlod(_WindMap, uv);<font></font>
<font></font>
                return o;<font></font>
            }<font></font>
<font></font>
            [maxvertexcount(7)]<font></font>
            void geom(triangle v2g i[3], inout TriangleStream&lt;g2f&gt; stream)<font></font>
            {<font></font>
                float4 p0 = i[0].pos;<font></font>
                float4 p1 = i[1].pos;<font></font>
                float4 p2 = i[2].pos;<font></font>
<font></font>
                float3 n0 = i[0].nor;<font></font>
                float3 n1 = i[1].nor;<font></font>
                float3 n2 = i[2].nor;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                float height = (i [0] .hei.r + i [1] .hei.r + i [2] .hei.r) / 3.0f;</font></font></font></font><font></font>
                float rot = (i[0].rot.r + i[1].rot.r + i[2].rot.r) / 3.0f;<font></font>
                float wind = (i[0].wind.r + i[1].wind.r + i[2].wind.r) / 3.0f;<font></font>
<font></font>
                float4 center = ((p0 + p1 + p2) / 3.0f);<font></font>
                float4 normal = float4(((n0 + n1 + n2) / 3.0f).xyz, 1.0f);<font></font>
<font></font>
                float bottomHeight = height * _Height * _BottomHeight;<font></font>
                float middleHeight = height * _Height * _MiddleHeight;<font></font>
                float topHeight = height * _Height * _TopHeight;<font></font>
<font></font>
                float bottomWidth = _Width * _BottomWidth;<font></font>
                float middleWidth = _Width * _MiddleWidth;<font></font>
                float topWidth = _Width * _TopWidth;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                rot = rot - 0.5f;</font></font></font></font><font></font>
                float4 dir = float4(normalize((p2 - p0) * rot).xyz, 1.0f);<font></font>
<font></font>
                g2f o[7];<font></font>
<font></font>
                // Bottom.<font></font>
                o[0].pos = center - dir * bottomWidth;<font></font>
                o[0].color = _BottomColor;<font></font>
<font></font>
                o[1].pos = center + dir * bottomWidth;<font></font>
                o[1].color = _BottomColor;<font></font>
<font></font>
                // Bottom to Middle.<font></font>
                o[2].pos = center - dir * middleWidth + normal * bottomHeight;<font></font>
                o[2].color = lerp(_BottomColor, _TopColor, 0.33333f);<font></font>
<font></font>
                o[3].pos = center + dir * middleWidth + normal * bottomHeight;<font></font>
                o[3].color = lerp(_BottomColor, _TopColor, 0.33333f);<font></font>
<font></font>
                // Middle to Top.<font></font>
                o[4].pos = o[3].pos - dir * topWidth + normal * middleHeight;<font></font>
                o[4].color = lerp(_BottomColor, _TopColor, 0.66666f);<font></font>
<font></font>
                o[5].pos = o[3].pos + dir * topWidth + normal * middleHeight;<font></font>
                o[5].color = lerp(_BottomColor, _TopColor, 0.66666f);<font></font>
<font></font>
                // Top.<font></font>
                o[6].pos = o[5].pos + dir * topWidth + normal * topHeight;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                or [6] .color = _TopColor;</font></font><font></font>
<font></font>
                // Bend.<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                dir = float4 (1.0f, 0.0f, 0.0f, 1.0f);</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                o [2] .pos + =</font></font></font></font><font></font>
                            * (_WindPower * wind * _BottomBend)<font></font>
                            * sin(_Time);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                o [3] .pos + =</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                            * (_WindPower * wind * _BottomBend)</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                            * sin(_Time);</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                o [4] .pos + =</font></font></font></font><font></font>
                            * (_WindPower * wind * _MiddleBend)<font></font>
                            * sin(_Time);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                o [5] .pos + =</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                            * (_WindPower * wind * _MiddleBend)</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                            * sin(_Time);</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                o [6] .pos + =</font></font></font></font><font></font>
                            * (_WindPower * wind * _TopBend)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                            * sin(_Time);</font></font></font></font><font></font>
<font></font>
                [unroll]<font></font>
                for (int i = 0; i &lt; 7; i++) {<font></font>
                    o[i].pos = UnityObjectToClipPos(o[i].pos);<font></font>
                    stream.Append(o[i]);<font></font>
                }<font></font>
            }<font></font>
<font></font>
            float4 frag(g2f i) : COLOR<font></font>
            {<font></font>
                return i.color;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            }</font></font></font></font><font></font>
            ENDCG<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you apply this shader to a Plane mesh with multiple vertical and horizontal arrangements, it will look like Figure 6.4.</font></font></p>
<div id="id_aoyama_2Fimg3" class="image">
<img src="./Chapter 6 _ Growing grass with geometry shaders_files/img3.png" alt="Grass Shader results" class="width-060per">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 6.4: Grass Shader results
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will explain the process of growing grass from this.</font></font></p>

<h3><a id="h6-5-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.5.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Basic policy</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This time, we will generate one grass for each primitive. </font><font style="vertical-align: inherit;">As shown in Fig. 6.5, the shape of the grass is divided into the lower part, the middle part, and the upper part, and a total of 7 vertices are generated. I will.</font></font></p>
<div id="id_aoyama_2Fimg4" class="image">
<img src="./Chapter 6 _ Growing grass with geometry shaders_files/img4.png" alt="How to make a grass shape" class="width-040per">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 6.5: How to make a grass shape
</font></font></p>
</div>

<h3><a id="h6-5-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.5.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parameters</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Details are described in the comments, but the coefficient that controls the width and height of each part (lower part, middle part, upper part) in one grass, and the coefficient that controls the width and height of the whole grass It is prepared as the main parameter. </font><font style="vertical-align: inherit;">Also, it doesn't look good if each grass has the same shape, so we use a noise texture to give it randomness.</font></font></p>

<h3><a id="h6-5-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.5.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Processing</font></font></h3>
<div class="emlist-code">
<pre class="emlist language-cs"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">float height = (i [0] .hei.r + i [1] .hei.r + i [2] .hei.r) / 3.0f;</font></font><font></font>
float rot = (i[0].rot.r + i[1].rot.r + i[2].rot.r) / 3.0f;<font></font>
float wind = (i[0].wind.r + i[1].wind.r + i[2].wind.r) / 3.0f;<font></font>
<font></font>
float4 center = ((p0 + p1 + p2) / 3.0f);<font></font>
float4 normal = float4(((n0 + n1 + n2) / 3.0f).xyz, 1.0f);<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this part, the height and direction of the grass and the numerical values ​​that are the standard of the strength of the wind are calculated. </font><font style="vertical-align: inherit;">You can calculate in Geometry Shader, but if you give the vertices meta information, you can treat it like the initial value when performing calculation on Geometry Shader, so calculate with Vertex Shader. I am.</font></font></p>
<div class="emlist-code">
<pre class="emlist language-cs">float4 center = ((p0 + p1 + p2) / 3.0f);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
float4 normal = float4(((n0 + n1 + n2) / 3.0f).xyz, 1.0f);</font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, the central part of the grass and the direction in which the grass grows are calculated. </font><font style="vertical-align: inherit;">If you decide this part by noise texture etc., you can give randomness in the direction of grass growth.</font></font></p>
<div class="emlist-code">
<pre class="emlist language-cs">float bottomHeight = height * _Height * _BottomHeight;<font></font>
<font></font>
...<font></font>
<font></font>
o[6].pos += dir * (_WindPower * wind * _TopBend) * sin(_Time);<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The program is abbreviated because it is long. </font><font style="vertical-align: inherit;">In this part, the height and width of the lower part, middle part, and upper part are calculated respectively, and the coordinates are calculated based on that.</font></font></p>
<div class="emlist-code">
<pre class="emlist language-cs">[unroll]<font></font>
for (int i = 0; i &lt; 7; i++) {<font></font>
    o[i].pos = UnityObjectToClipPos(o[i].pos);<font></font>
    stream.Append(o[i]);<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are 7 vertices calculated in this part </font></font><code class="tt">Append</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This time, there is no problem even if the triangles are generated while being connected, so I have not done so </font></font><code class="tt">RestartStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, </font><font style="vertical-align: inherit;">the attribute called is applied to </font><font style="vertical-align: inherit;">the </font></font><code class="tt">for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">statement </font></font><code class="tt">[unroll]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is an attribute that expands the processing in the loop as many times as the number of loops at compile time, and although it has the disadvantage of increasing the memory size, it has the advantage of operating at high speed.</font></font></p>

<h2><a id="h6-6"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.6　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Summary</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So far, we have explained from the explanation of Geometry Shader to the basic and applied programs. </font><font style="vertical-align: inherit;">There are some features that are slightly different from writing a program that runs on the CPU, but you should be able to utilize it if you suppress the basic part.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, it is generally said that Geometry Shader is slow. </font><font style="vertical-align: inherit;">I haven't really felt it, but it may be difficult when the range of use is large. </font><font style="vertical-align: inherit;">If you are going to use Geometry Shader on a large scale, please take a benchmark etc. once.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Still, being able to dynamically and freely create and delete new meshes on the GPU will greatly expand the range of ideas. </font><font style="vertical-align: inherit;">Personally, I think the most important thing is not what technology was used, but what is created and expressed by it. </font><font style="vertical-align: inherit;">We hope that you will learn about and learn about one tool called Geometry Shader in this chapter, and feel some new possibilities.</font></font></p>

<h2><a id="h6-7"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.7　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reference</font></font></h2>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tutorial 13: Geometry Shader-https: </font></font><a href="https://msdn.microsoft.com/ja-jp/library/bb172497" class="link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">//msdn.microsoft.com/en-us/library/bb172497</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geometry shader object in MSDN-https: </font></font><a href="https://msdn.microsoft.com/ja-jp/library/ee418313" class="link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">//msdn.microsoft.com/en-us/library/ee418313</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering technique for transparent geometry by cutting geometry in geometry shader-http: </font></font><a href="http://t-pot.com/program/147_CGGONG2008/index.html" class="link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">//t-pot.com/program/147_CGGONG2008/index.html</font></font></a></li>
</ul></body></html>