<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="en" style="height: 100%;" class="translated-ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <link rel="stylesheet" type="text/css" href="./Chapter 3 _ GPU implementation of the simulation of the group_files/style.scss">
  <meta name="generator" content="Re:VIEW">
  <title>GPU implementation of group simulation</title>

			<style>
				img {
					max-width: 80vw;
					max-height: 80vh;
				}
			</style><style>
					.goog-te-banner-frame {
						display: none;
					}
				</style>
			<script>(function(){(function injection() {
  var pageLang = 'ja';
  var userLang = 'en';

  var uid = '1E07F158C6FA4460B352973E9693B329';
  var teId = 'TE_' + uid;
  var cbId = 'TECB_' + uid;

  function show() {
    window.setTimeout(function() {
      window[teId].showBanner(true);
    }, 10);
  }

  function newElem() {
    
  }

  if (window[teId]) {
    show();
  } else {
    if (!window.google || !google.translate ||
        !google.translate.TranslateElement) {
      if (!window[cbId]) {
        window[cbId] = function() {
          window[teId] = newElem();
          show();
        };
      }
      
    }
  }
})();})();</script><script src="https://translate.google.com/translate_a/element.js?cb=TECB_1E07F158C6FA4460B352973E9693B329&amp;client=tee&amp;hl=en"></script><script src="./Chapter 3 _ GPU implementation of the simulation of the group_files/f.txt"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://translate.googleapis.com/translate_static/css/translateelement.css"><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/translate_static/js/element/main.js"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="./Chapter 3 _ GPU implementation of the simulation of the group_files/translateelement.css"><script type="text/javascript" charset="UTF-8" src="./Chapter 3 _ GPU implementation of the simulation of the group_files/main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script><script type="text/javascript" charset="UTF-8" src="./Chapter 3 _ GPU implementation of the simulation of the group_files/element_main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://translate.googleapis.com/translate_static/css/translateelement.css"><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/translate_static/js/element/main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script></head>
		
<body style="position: relative; min-height: 100%; top: 40px;"><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div>
<h1><a id="h3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chapter 3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GPU implementation of the simulation of the group</font></font></h1>

<h2><a id="h3-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Introduction</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this chapter, we will explain the implementation of group simulation using the Boids algorithm using Compute Shader. </font><font style="vertical-align: inherit;">Birds, fish and other terrestrial animals sometimes flock. </font><font style="vertical-align: inherit;">The movements of this group show regularity and complexity, and have a certain beauty and have attracted people. </font><font style="vertical-align: inherit;">In computer graphics, it is not realistic to control the behavior of each individual by hand, and an algorithm for forming a group called Boids was devised. </font><font style="vertical-align: inherit;">This simulation algorithm consists of some simple rules and is easy to implement, but in a simple implementation it is necessary to check the positional relationship with all individuals, and as the number of individuals increases, it becomes squared. The amount of calculation will increase proportionally. </font><font style="vertical-align: inherit;">If you want to control many individuals, it is very difficult to implement with CPU. </font><font style="vertical-align: inherit;">Therefore, we will take advantage of the powerful parallel computing power of the GPU. </font><font style="vertical-align: inherit;">Unity provides a shader program called Compute Shader to perform such general purpose computing (GPGPU) by GPU. </font><font style="vertical-align: inherit;">The GPU has a special storage area called shared memory, which can be used effectively by using Compute Shader. </font><font style="vertical-align: inherit;">In addition, Unity has an advanced rendering function called GPU instancing, which allows you to draw a large number of arbitrary meshes. </font><font style="vertical-align: inherit;">We will introduce a program that controls and draws a large number of Boid objects using the functions that make use of the computing power of these Unity GPUs.</font></font></p>

<h2><a id="h3-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boids algorithm</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A group of simulation algorithms called Boids was developed by Craig Reynolds in 1986 and published the following year in 1987 at ACM SIGGRAPH as a paper entitled "Flocks, Herds, and Schools: A Distributed Behavioral Model".</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Reynolds, a herd produces complex behavior as a result of each individual modifying its own behavior based on the position and direction of movement of other individuals around it, through perceptions such as sight and hearing. Pay attention to the fact that there is.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each individual follows three simple rules of conduct:</font></font></p>

<h5><a id="h3-2-0-0-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Separation</font></font></h5>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Move to avoid crowding with individuals within a certain distance</font></font></p>

<h5><a id="h3-2-0-0-2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Alignment</font></font></h5>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Individuals within a certain distance move toward the average in the direction they are facing</font></font></p>

<h5><a id="h3-2-0-0-3"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Cohesion</font></font></h5>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Move to the average position of an individual within a certain distance</font></font></p>
<div id="boids-rules" class="image">
<img src="./Chapter 3 _ GPU implementation of the simulation of the group_files/boids-rules.png" alt="Basic rules of Boids">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.1: Basic rules for Boids
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can program the movement of the herd by controlling the individual movements according to these rules.</font></font></p>

<h2><a id="h3-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sample program</font></font></h2>

<h3><a id="h3-3-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Repository</font></font></h3>
<p><a href="https://github.com/IndieVisualLab/UnityGraphicsProgramming" class="link">https://github.com/IndieVisualLab/UnityGraphicsProgramming</a></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Open </font><font style="vertical-align: inherit;">the </font><strong><font style="vertical-align: inherit;">BoidsSimulationOnGPU.unity</font></strong><font style="vertical-align: inherit;"> scene data </font><font style="vertical-align: inherit;">in the </font><font style="vertical-align: inherit;">Assets / </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BoidsSimulationOnGPU</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> folder in </font><font style="vertical-align: inherit;">the sample Unity project in this document </font><font style="vertical-align: inherit;">.</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font></p>

<h3><a id="h3-3-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Execution conditions</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The programs introduced in this chapter use Compute Shader and GPU instancing.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ComputeShader runs on the following platforms or APIs:</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows and Windows Store apps with DirectX 11 or DirectX 12 graphics API and shader model 5.0 GPUs</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOS with Mac OS and Metal Graphics API</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android, Linux and Windows platforms with Vulkan API</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The latest OpenGL platform (OpenGL 4.3 on Linux or Windows, OpenGL ES 3.1 on Android). </font><font style="vertical-align: inherit;">(Note that MacOSX does not support OpenGL 4.3)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Console machines commonly used at this stage (Sony PS4, Microsoft Xbox One)</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU instancing is available on the following platforms or APIs:</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DirectX 11 and DirectX 12 on Windows</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenGL core 4.1 + / ES3.0 + on Windows, MacOS, Linux, iOS, Android</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metal on Mac OS and iOS</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vulkan for Windows and Android</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Playstation 4 and Xbox One</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WebGL (requires WebGL 2.0 API)</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this sample program, Graphics.DrawMeshInstacedIndirect method is used. </font><font style="vertical-align: inherit;">Therefore, the Unity version must be 5.6 or later.</font></font></p>

<h2><a id="h3-4"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.4　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Explanation of implementation code</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This sample program consists of the following code.</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUBoids.cs --Script that controls the Compute Shader that simulates Boids</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boids.compute --ComputeShader that simulates Boids</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BoidsRender.cs --C # script that controls the shader that draws Boids</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BoidsRender.shader-Shader for drawing objects with GPU instancing</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scripts, material resources, etc. are set like this</font></font></p>
<div id="editor-boids" class="image">
<img src="./Chapter 3 _ GPU implementation of the simulation of the group_files/editor-boids.png" alt="Settings on Unity Editor">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.2: Settings on Unity Editor
</font></font></p>
</div>

<h3><a id="h3-4-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.4.1　</font></font></font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GPUBoids.cs</font></font></font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This code manages Boids simulation parameters, Compute Shader that describes buffers and calculation instructions required for calculations on the GPU, and so on.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUBoids.cs</font></font></font></font></p>
<pre class="emlist language-csharp">using UnityEngine;<font></font>
using System.Collections;<font></font>
using System.Collections.Generic;<font></font>
using System.Runtime.InteropServices;<font></font>
<font></font>
public class GPUBoids : MonoBehaviour<font></font>
{<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Boid data structure</font></font><font></font>
    [System.Serializable]<font></font>
    struct BoidData<font></font>
    {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        public Vector3 Velocity; // Velocity</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        public Vector3 Position; // position</font></font><font></font>
    }<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Thread size of thread group</font></font><font></font>
    const int SIMULATION_BLOCK_SIZE = 256;<font></font>
<font></font>
    #region Boids Parameters<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Maximum number of objects</font></font><font></font>
    [Range(256, 32768)]<font></font>
    public int MaxObjectNum = 16384;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Radius with other individuals to which the bond applies</font></font><font></font>
    public float CohesionNeighborhoodRadius  = 2.0f;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Radius with other individuals to which alignment is applied</font></font><font></font>
    public float AlignmentNeighborhoodRadius = 2.0f;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Radius with other individuals to which separation is applied</font></font><font></font>
    public float SeparateNeighborhoodRadius  = 1.0f;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Maximum speed</font></font><font></font>
    public float MaxSpeed        = 5.0f;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Maximum steering force</font></font><font></font>
    public float MaxSteerForce   = 0.5f;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Weight of binding force</font></font><font></font>
    public float CohesionWeight  = 1.0f;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Weight of aligning force</font></font><font></font>
    public float AlignmentWeight = 1.0f;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Weight of separating force</font></font><font></font>
    public float SeparateWeight  = 3.0f;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Weight of force to avoid walls</font></font><font></font>
    public float AvoidWallWeight = 10.0f;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Center coordinates of the wall</font></font><font></font>
    public Vector3 WallCenter = Vector3.zero;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // wall size</font></font><font></font>
    public Vector3 WallSize = new Vector3(32.0f, 32.0f, 32.0f);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    #endregion</font></font></font></font><font></font>
<font></font>
    #region Built-in Resources<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Reference to Compute Shader for Boids simulation</font></font><font></font>
    public ComputeShader BoidsCS;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    #endregion</font></font></font></font><font></font>
<font></font>
    #region Private Resources<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Buffer that stores the steering force (Force) of the Boid</font></font><font></font>
    ComputeBuffer _boidForceBuffer;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Buffer containing basic Boid data (speed, position)</font></font><font></font>
    ComputeBuffer _boidDataBuffer;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    #endregion</font></font></font></font><font></font>
<font></font>
    #region Accessors<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Get the buffer that stores the basic data of Boid</font></font><font></font>
    public ComputeBuffer GetBoidDataBuffer()<font></font>
    {<font></font>
        return this._boidDataBuffer != null ? this._boidDataBuffer : null;<font></font>
    }<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Get the number of objects</font></font><font></font>
    public int GetMaxObjectNum()<font></font>
    {<font></font>
        return this.MaxObjectNum;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Returns the center coordinates of the simulation area</font></font><font></font>
    public Vector3 GetSimulationAreaCenter()<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    {</font></font></font></font><font></font>
        return this.WallCenter;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Returns the size of the box in the simulation area</font></font><font></font>
    public Vector3 GetSimulationAreaSize()<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    {</font></font></font></font><font></font>
        return this.WallSize;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    #endregion</font></font></font></font><font></font>
<font></font>
    #region MonoBehaviour Functions<font></font>
    void Start()<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    {</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Initialize the buffer</font></font><font></font>
        InitBuffer();<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font>
<font></font>
    void Update()<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    {</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // simulation</font></font><font></font>
        Simulation();<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font>
<font></font>
    void OnDestroy()<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    {</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Discard the buffer</font></font><font></font>
        ReleaseBuffer();<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font>
<font></font>
    void OnDrawGizmos()<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    {</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Draw the simulation area in wireframe as a debug</font></font><font></font>
        Gizmos.color = Color.cyan;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        Gizmos.DrawWireCube (WallCenter, WallSize);</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    #endregion</font></font></font></font><font></font>
<font></font>
    #region Private Functions<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Initialize the buffer</font></font><font></font>
    void InitBuffer()<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    {</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Initialize the buffer</font></font><font></font>
        _boidDataBuffer  = new ComputeBuffer(MaxObjectNum,<font></font>
            Marshal.SizeOf(typeof(BoidData)));<font></font>
        _boidForceBuffer = new ComputeBuffer(MaxObjectNum,<font></font>
            Marshal.SizeOf(typeof(Vector3)));<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Initialize Boid data, Force buffer</font></font><font></font>
        var forceArr = new Vector3[MaxObjectNum];<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        var boidDataArr = new BoidData [MaxObjectNum];</font></font></font></font><font></font>
        for (var i = 0; i &lt; MaxObjectNum; i++)<font></font>
        {<font></font>
            forceArr[i] = Vector3.zero;<font></font>
            boidDataArr[i].Position = Random.insideUnitSphere * 1.0f;<font></font>
            boidDataArr[i].Velocity = Random.insideUnitSphere * 0.1f;<font></font>
        }<font></font>
        _boidForceBuffer.SetData(forceArr);<font></font>
        _boidDataBuffer.SetData(boidDataArr);<font></font>
        forceArr    = null;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        boidDataArr = null;</font></font></font></font><font></font>
    }<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // simulation</font></font><font></font>
    void Simulation()<font></font>
    {<font></font>
        ComputeShader cs = BoidsCS;<font></font>
        int id = -1;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Find the number of thread groups</font></font><font></font>
        int threadGroupSize = Mathf.CeilToInt(MaxObjectNum<font></font>
            / SIMULATION_BLOCK_SIZE);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Calculate steering force</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        id = cs.FindKernel ("ForceCS"); // Get the kernel ID</font></font><font></font>
        cs.SetInt("_MaxBoidObjectNum", MaxObjectNum);<font></font>
        cs.SetFloat("_CohesionNeighborhoodRadius",<font></font>
            CohesionNeighborhoodRadius);<font></font>
        cs.SetFloat("_AlignmentNeighborhoodRadius",<font></font>
            AlignmentNeighborhoodRadius);<font></font>
        cs.SetFloat("_SeparateNeighborhoodRadius",<font></font>
            SeparateNeighborhoodRadius);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        cs.SetFloat ("_ MaxSpeed", MaxSpeed);</font></font></font></font><font></font>
        cs.SetFloat("_MaxSteerForce", MaxSteerForce);<font></font>
        cs.SetFloat("_SeparateWeight", SeparateWeight);<font></font>
        cs.SetFloat("_CohesionWeight", CohesionWeight);<font></font>
        cs.SetFloat("_AlignmentWeight", AlignmentWeight);<font></font>
        cs.SetVector("_WallCenter", WallCenter);<font></font>
        cs.SetVector("_WallSize", WallSize);<font></font>
        cs.SetFloat("_AvoidWallWeight", AvoidWallWeight);<font></font>
        cs.SetBuffer(id, "_BoidDataBufferRead", _boidDataBuffer);<font></font>
        cs.SetBuffer(id, "_BoidForceBufferWrite", _boidForceBuffer);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        cs.Dispatch (id, threadGroupSize, 1, 1); // Run Compute Shader</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Calculate speed and position from steering force</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        id = cs.FindKernel ("IntegrateCS"); // Get the kernel ID</font></font><font></font>
        cs.SetFloat("_DeltaTime", Time.deltaTime);<font></font>
        cs.SetBuffer(id, "_BoidForceBufferRead", _boidForceBuffer);<font></font>
        cs.SetBuffer(id, "_BoidDataBufferWrite", _boidDataBuffer);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        cs.Dispatch (id, threadGroupSize, 1, 1); // Run Compute Shader</font></font></font></font><font></font>
    }<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Free the buffer</font></font><font></font>
    void ReleaseBuffer()<font></font>
    {<font></font>
        if (_boidDataBuffer != null)<font></font>
        {<font></font>
            _boidDataBuffer.Release();<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            _boidDataBuffer = null;</font></font></font></font><font></font>
        }<font></font>
<font></font>
        if (_boidForceBuffer != null)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        {</font></font></font></font><font></font>
            _boidForceBuffer.Release();<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            _boidForceBuffer = null;</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        }</font></font></font></font><font></font>
    }<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    #endregion</font></font></font></font><font></font>
}<font></font>
<font></font>
</pre>
</div>

<h5><a id="h3-4-1-0-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialization of Compute Buffer</font></font></h5>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The InitBuffer function declares the buffer to use when performing calculations on the GPU. </font><font style="vertical-align: inherit;">We use a class called ComputeBuffer as a buffer to store the data to be calculated on the GPU. </font><font style="vertical-align: inherit;">Compute Buffer is a data buffer that stores data for the Compute Shader. </font><font style="vertical-align: inherit;">You will be able to read and write to the memory buffer on the GPU from a C # script. </font><font style="vertical-align: inherit;">Pass the number of elements in the buffer and the size (number of bytes) of one element as arguments at initialization. </font><font style="vertical-align: inherit;">You can get the size (in bytes) of the type by using the Marshal.SizeOf () method. </font><font style="vertical-align: inherit;">In ComputeBuffer, you can use SetData () to set the value of an array of any structure.</font></font></p>

<h5><a id="h3-4-1-0-2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Execution of the function described in ComputeShader</font></font></h5>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Simulation function passes the required parameters to ComputeShader and issues a calculation instruction.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function written in ComputeShader that actually causes the GPU to perform calculations is called the kernel. </font><font style="vertical-align: inherit;">The execution unit of this kernel is called a thread, and in order to perform parallel computing processing according to the GPU architecture, any number is treated as a group, and they are called a thread group. </font><font style="vertical-align: inherit;">Set the product of the number of threads and the number of thread groups to be equal to or greater than the number of Boid objects.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The kernel is specified in the ComputeShader script using the #pragma kernel directive. </font><font style="vertical-align: inherit;">An ID is assigned to each of them, and you can get this ID from the C # script by using the FindKernel method.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use the SetFloat method, SetVector method, SetBuffer method, etc. to pass the parameters and buffers required for simulation to the Compute Shader. </font><font style="vertical-align: inherit;">You will need the kernel ID when setting buffers and textures.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By executing the Dispatch method, an instruction is issued to calculate the kernel defined in Compute Shader on the GPU. </font><font style="vertical-align: inherit;">In the arguments, specify the kernel ID and the number of thread groups.</font></font></p>

<h3><a id="h3-4-2"></a><span class="secno">3.4.2　</span>Boids.compute</h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Describe the calculation instruction to GPU. </font><font style="vertical-align: inherit;">There are two kernels, one that calculates the steering force and the other that applies that force to update speed and position.</font></font></p>
<div class="emlist-code">
<p class="caption">Boids.compute</p>
<pre class="emlist language-computeshader"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Specify kernel function</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
#pragma kernel ForceCS // Calculate steering force</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
#pragma kernel IntegrateCS // Calculate speed and position</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Boid data structure</font></font><font></font>
struct BoidData<font></font>
{<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    float3 velocity; // velocity</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    float3 position; // position</font></font><font></font>
};<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Thread size of thread group</font></font><font></font>
#define SIMULATION_BLOCK_SIZE 256<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Boid data buffer (for reading)</font></font><font></font>
StructuredBuffer&lt;BoidData&gt;   _BoidDataBufferRead;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Boid data buffer (for reading and writing)</font></font><font></font>
RWStructuredBuffer&lt;BoidData&gt; _BoidDataBufferWrite;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Boid steering force buffer (for reading)</font></font><font></font>
StructuredBuffer&lt;float3&gt;     _BoidForceBufferRead;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Boid steering force buffer (for reading and writing)</font></font><font></font>
RWStructuredBuffer&lt;float3&gt;   _BoidForceBufferWrite;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int _MaxBoidObjectNum; // Number of Boid objects</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
float _DeltaTime; // Time elapsed from the previous frame</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
float _SeparateNeighborhoodRadius; // Distance to other individuals to which separation is applied</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
float _AlignmentNeighborhoodRadius; // Distance to other individuals to which alignment is applied</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
float _CohesionNeighborhoodRadius; // Distance to other individuals to which the bond applies</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
float _MaxSpeed; // Maximum speed</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
float _MaxSteerForce; // Maximum steering force</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
float _SeparateWeight; // Weight when applying separation</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
float _AlignmentWeight; // Weight when applying alignment</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
float _CohesionWeight; // Weight when applying join</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
float4 _WallCenter; // Wall center coordinates</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
float4 _WallSize; // Wall size</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
float _AvoidWallWeight; // Weight of strength to avoid walls</font></font><font></font>
<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Limit the magnitude of the vector</font></font><font></font>
float3 limit(float3 vec, float max)<font></font>
{<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    float length = sqrt (dot (vec, vec)); // size</font></font><font></font>
    return (length &gt; max &amp;&amp; length &gt; 0) ? vec.xyz * (max / length) : vec.xyz;<font></font>
}<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Return the opposite force when hitting the wall</font></font><font></font>
float3 avoidWall(float3 position)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    float3 wc = _WallCenter.xyz;</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    float3 ws = _WallSize.xyz;</font></font></font></font><font></font>
    float3 acc = float3(0, 0, 0);<font></font>
    // x<font></font>
    acc.x = (position.x &lt; wc.x - ws.x * 0.5) ? acc.x + 1.0 : acc.x;<font></font>
    acc.x = (position.x &gt; wc.x + ws.x * 0.5) ? acc.x - 1.0 : acc.x;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Y</font></font></font></font><font></font>
    acc.y = (position.y &lt; wc.y - ws.y * 0.5) ? acc.y + 1.0 : acc.y;<font></font>
    acc.y = (position.y &gt; wc.y + ws.y * 0.5) ? acc.y - 1.0 : acc.y;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // with</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    acc.z = (position.z &lt;wc.z - ws.z * 0.5)? </font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acc.z + 1.0: acc.z;</font></font></font></font><font></font>
    acc.z = (position.z &gt; wc.z + ws.z * 0.5) ? acc.z - 1.0 : acc.z;<font></font>
<font></font>
    return acc;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Shared memory for Boid data storage</font></font><font></font>
groupshared BoidData boid_data[SIMULATION_BLOCK_SIZE];<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Kernel function for calculating steering force</font></font><font></font>
[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]<font></font>
void ForceCS<font></font>
(<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    uint3 DTid: SV_DispatchThreadID, // ID unique to the entire thread</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    uint3 Gid: SV_GroupID, // Group ID</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    uint3 GTid: SV_GroupThreadID, // Thread ID in the group</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    uint GI: SV_GroupIndex // SV_GroupThreadID in one dimension 0-255</font></font><font></font>
)<font></font>
{<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    const unsigned int P_ID = DTid.x; // own ID</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    float3 P_position = _BoidDataBufferRead [P_ID] .position; // own position</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    float3 P_velocity = _BoidDataBufferRead [P_ID] .velocity; // own speed</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    float3 force = float3 (0, 0, 0); // Initialize steering force</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    float3 sepPosSum = float3 (0, 0, 0); // Position addition variable for separation calculation</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    int sepCount = 0; // Variable for counting the number of other individuals calculated for separation</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    float3 aliVelSum = float3 (0, 0, 0); // Velocity addition variable for alignment calculation</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    int aliCount = 0; // Variable for counting the number of other individuals calculated for alignment</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    float3 cohPosSum = float3 (0, 0, 0); // Position addition variable for join calculation</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    int cohCount = 0; // Variable for counting the number of other individuals calculated for binding</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Execution for each SIMULATION_BLOCK_SIZE (number of group threads) (execution for the number of groups)</font></font><font></font>
    [loop]<font></font>
    for (uint N_block_ID = 0; N_block_ID &lt; (uint)_MaxBoidObjectNum;<font></font>
        N_block_ID += SIMULATION_BLOCK_SIZE)<font></font>
    {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Store Boid data for SIMULATION_BLOCK_SIZE in shared memory</font></font><font></font>
        boid_data[GI] = _BoidDataBufferRead[N_block_ID + GI];<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // All group sharing access is complete</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Until all threads in the group reach this call</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Block the execution of all threads in the group</font></font><font></font>
        GroupMemoryBarrierWithGroupSync();<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Calculation with other individuals</font></font><font></font>
        for (int N_tile_ID = 0; N_tile_ID &lt; SIMULATION_BLOCK_SIZE;<font></font>
            N_tile_ID++)<font></font>
        {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // Position of other individuals</font></font><font></font>
            float3 N_position = boid_data[N_tile_ID].position;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // Speed ​​of other individuals</font></font><font></font>
            float3 N_velocity = boid_data[N_tile_ID].velocity;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // Difference in position between yourself and other individuals</font></font><font></font>
            float3 diff = P_position - N_position;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // Distance between yourself and the position of other individuals</font></font><font></font>
            float  dist = sqrt(dot(diff, diff));<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // --- Separation ---</font></font><font></font>
            if (dist &gt; 0.0 &amp;&amp; dist &lt;= _SeparateNeighborhoodRadius)<font></font>
            {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                // Vector from the position of another individual to itself</font></font><font></font>
                float3 repulse = normalize(P_position - N_position);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                // Divide by the distance between yourself and the position of another individual (the longer the distance, the smaller the effect)</font></font><font></font>
                repulse /= dist;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                sepPosSum + = repulse; // Add</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                sepCount ++; // Population count</font></font><font></font>
            }<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // --- Alignment ---</font></font><font></font>
            if (dist &gt; 0.0 &amp;&amp; dist &lt;= _AlignmentNeighborhoodRadius)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            {</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                aliVelSum + = N_velocity; // Add</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                aliCount ++; // Population count</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            }</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // --- Cohesion ---</font></font><font></font>
            if (dist &gt; 0.0 &amp;&amp; dist &lt;= _CohesionNeighborhoodRadius)<font></font>
            {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                cohPosSum + = N_position; // Add</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                cohCount ++; // Population count</font></font><font></font>
            }<font></font>
        }<font></font>
        GroupMemoryBarrierWithGroupSync();<font></font>
    }<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // steering force (separated)</font></font><font></font>
    float3 sepSteer = (float3)0.0;<font></font>
    if (sepCount &gt; 0)<font></font>
    {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        sepSteer = sepPosSum / (float) sepCount; // Calculate the average</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        sepSteer = normalize (sepSteer) * _MaxSpeed; // Adjust to maximum speed</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        sepSteer = sepSteer --P_velocity; // Calculate steering force</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        sepSteer = limit (sepSteer, _MaxSteerForce); // Limit steering force</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Steering force (alignment)</font></font><font></font>
    float3 aliSteer = (float3)0.0;<font></font>
    if (aliCount &gt; 0)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    {</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        aliSteer = aliVelSum / (float) aliCount; // Calculate the average velocity of close individuals</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        aliSteer = normalize (aliSteer) * _MaxSpeed; // Adjust to maximum speed</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        aliSteer = aliSteer --P_velocity; // Calculate steering force</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        aliSteer = limit (aliSteer, _MaxSteerForce); // Limit steering force</font></font><font></font>
    }<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // steering force (combined)</font></font><font></font>
    float3 cohSteer = (float3)0.0;<font></font>
    if (cohCount &gt; 0)<font></font>
    {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // / Calculate the average of the positions of close individuals</font></font><font></font>
        cohPosSum = cohPosSum / (float)cohCount;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        cohSteer = cohPosSum --P_position; // Find the vector in the average position direction</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        cohSteer = normalize (cohSteer) * _MaxSpeed; // Adjust to maximum speed</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        cohSteer = cohSteer --P_velocity; // Calculate steering force</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        cohSteer = limit (cohSteer, _MaxSteerForce); // Limit steering force</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    force + = aliSteer * _AlignmentWeight; // Add a force to align with the steering force</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    force + = cohSteer * _CohesionWeight; // Add force to combine with steering force</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    force + = sepSteer * _SeparateWeight; // Add a separating force to the steering force</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    _BoidForceBufferWrite [P_ID] = force; // Write</font></font><font></font>
}<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Kernel function for speed and position calculation</font></font><font></font>
[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]<font></font>
void IntegrateCS<font></font>
(<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    uint3 DTid: SV_DispatchThreadID // Unique ID for the entire thread</font></font><font></font>
)<font></font>
{<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    const unsigned int P_ID = DTid.x; // Get index</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    BoidData b = _BoidDataBufferWrite [P_ID]; // Read the current Boid data</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    float3 force = _BoidForceBufferRead [P_ID]; // Read the steering force</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Give repulsive force when approaching the wall</font></font><font></font>
    force += avoidWall(b.position) * _AvoidWallWeight;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    b.velocity + = force * _DeltaTime; // Apply steering force to speed</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    b.velocity = limit (b.velocity, _MaxSpeed); // Limit speed</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    b.position + = b.velocity * _DeltaTime; // Update position</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    _BoidDataBufferWrite [P_ID] = b; // Write the calculation result</font></font><font></font>
}<font></font>
<font></font>
</pre>
</div>

<h4><a id="h3-4-2-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculation of steering force</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ForceCS kernel calculates the steering force.</font></font></p>

<h5><a id="h3-4-2-1-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilization of shared memory</font></font></h5>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variables with the storage qualifier groupshared will now be written to shared memory. </font><font style="vertical-align: inherit;">Shared memory cannot write large amounts of data, but it is located close to registers and can be accessed very quickly. </font><font style="vertical-align: inherit;">This shared memory can be shared within the thread group. </font><font style="vertical-align: inherit;">By writing the information of other individuals for SIMULATION_BLOCK_SIZE together in the shared memory so that it can be read at high speed within the same thread group, the calculation considering the positional relationship with other individuals is efficient. I will go to the target.</font></font></p>
<div id="gpu-architecture" class="image">
<img src="./Chapter 3 _ GPU implementation of the simulation of the group_files/gpu-architecture.png" alt="GPU basic architecture">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.3: Basic GPU architecture
</font></font></p>
</div>

<h6><a id="h3-4-2-1-1-1"></a>GroupMemoryBarrierWithGroupSync()</h6>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When accessing the data written to the shared memory, it is necessary to describe the GroupMemoryBarrierWithGroupSync () method to synchronize the processing of all threads in the thread group. </font><font style="vertical-align: inherit;">GroupMemoryBarrierWithGroupSync () blocks the execution of all threads in the group until all threads in the thread group reach this call. </font><font style="vertical-align: inherit;">This ensures that all threads in the thread group have properly initialized the boid_data array.</font></font></p>

<h5><a id="h3-4-2-1-2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Steering force is calculated based on the distance to other individuals</font></font></h5>

<h6><a id="h3-4-2-1-2-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separation</font></font></h6>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If there is an individual closer than the specified distance, the vector from the position of the individual to its own position is calculated and normalized. </font><font style="vertical-align: inherit;">By dividing the vector by the value of the distance, it is weighted so that it avoids more when it is closer and avoids it smaller when it is far, and it is added as a force to prevent collision with other individuals. </font><font style="vertical-align: inherit;">After the calculation with all the individuals is completed, the steering force is calculated from the relationship with the current speed using the value.</font></font></p>

<h6><a id="h3-4-2-1-2-2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alignment</font></font></h6>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If there is an individual closer than the specified distance, the velocity (Velocity) of that individual is added up, the number of the individual is counted at the same time, and the velocity of the close individual (that is, the direction in which it is facing) is calculated by those values. Calculate the average of. </font><font style="vertical-align: inherit;">After the calculation with all the individuals is completed, the steering force is calculated from the relationship with the current speed using the value.</font></font></p>

<h6><a id="h3-4-2-1-2-3"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cohesion</font></font></h6>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If there is an individual closer than the specified distance, the position of that individual is added, the number of the individual is counted at the same time, and the average (center of gravity) of the position of the close individual is calculated from those values. </font><font style="vertical-align: inherit;">Furthermore, the vector toward that point is found, and the steering force is found in relation to the current speed.</font></font></p>

<h5><a id="h3-4-2-1-3"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Update the speed and position of individual Boids</font></font></h5>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The IntegrateCS kernel updates the speed and position of the Boid based on the steering force obtained by ForceCS (). </font><font style="vertical-align: inherit;">In AvoidWall, when you try to go out of the specified area, it applies a reverse force to stay inside the area.</font></font></p>

<h3><a id="h3-4-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.4.3　</font></font></font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> BoidsRender.cs</font></font></font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This script draws the results obtained from the Boids simulation on the specified mesh.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BoidsRender.cs</font></font></font></font></p>
<pre class="emlist language-csharp">using System.Collections;<font></font>
using System.Collections.Generic;<font></font>
using UnityEngine;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Guarantee that the GPU Boids component is attached to the GameObject</font></font><font></font>
[RequireComponent(typeof(GPUBoids))]<font></font>
public class BoidsRender : MonoBehaviour<font></font>
{<font></font>
    #region Paremeters<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Scale of the Boids object to draw</font></font><font></font>
    public Vector3 ObjectScale = new Vector3(0.1f, 0.2f, 0.5f);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    #endregion</font></font></font></font><font></font>
<font></font>
    #region Script References<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Reference GPUBoids script</font></font><font></font>
    public GPUBoids GPUBoidsScript;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    #endregion</font></font></font></font><font></font>
<font></font>
    #region Built-in Resources<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Reference to the mesh to draw</font></font><font></font>
    public Mesh InstanceMesh;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Reference material for drawing</font></font><font></font>
    public Material InstanceRenderMaterial;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    #endregion</font></font></font></font><font></font>
<font></font>
    #region Private Variables<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Arguments for GPU instancing (for transfer to ComputeBuffer)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Number of indexes per instance, number of instances,</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Start index position, base vertex position, instance start position</font></font><font></font>
    uint[] args = new uint[5] { 0, 0, 0, 0, 0 };<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Argument buffer for GPU instancing</font></font><font></font>
    ComputeBuffer argsBuffer;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    #endregion</font></font></font></font><font></font>
<font></font>
    #region MonoBehaviour Functions<font></font>
    void Start ()<font></font>
    {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Initialize the argument buffer</font></font><font></font>
        argsBuffer = new ComputeBuffer(1, args.Length * sizeof(uint),<font></font>
            ComputeBufferType.IndirectArguments);<font></font>
    }<font></font>
<font></font>
    void Update ()<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    {</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Instancing the mesh</font></font><font></font>
        RenderInstancedMesh();<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font>
<font></font>
    void OnDisable()<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    {</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Release the argument buffer</font></font><font></font>
        if (argsBuffer != null)<font></font>
            argsBuffer.Release();<font></font>
        argsBuffer = null;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    #endregion</font></font></font></font><font></font>
<font></font>
    #region Private Functions<font></font>
    void RenderInstancedMesh()<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    {</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // The drawing material is Null, or the GPUBoids script is Null,</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Or if GPU instancing is not supported, do not process</font></font><font></font>
        if (InstanceRenderMaterial == null || GPUBoidsScript == null ||<font></font>
            !SystemInfo.supportsInstancing)<font></font>
            return;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Get the number of indexes of the specified mesh</font></font><font></font>
        uint numIndices = (InstanceMesh != null) ?<font></font>
            (uint)InstanceMesh.GetIndexCount(0) : 0;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Set the number of indexes of the mesh</font></font><font></font>
        args[0] = numIndices;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Set the number of instances</font></font><font></font>
        args[1] = (uint)GPUBoidsScript.GetMaxObjectNum();<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        argsBuffer.SetData (args); // Set in buffer</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Set the buffer containing Boid data to the material</font></font><font></font>
        InstanceRenderMaterial.SetBuffer("_BoidDataBuffer",<font></font>
            GPUBoidsScript.GetBoidDataBuffer());<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Set the Boid object scale</font></font><font></font>
        InstanceRenderMaterial.SetVector("_ObjectScale", ObjectScale);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // define the boundary area</font></font><font></font>
        var bounds = new Bounds<font></font>
        (<font></font>
            GPUBoidsScript.GetSimulationAreaCenter(), // 中心<font></font>
            GPUBoidsScript.GetSimulationAreaSize()    // サイズ<font></font>
        );<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // GPU instantiate and draw mesh</font></font><font></font>
        Graphics.DrawMeshInstancedIndirect<font></font>
        (<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            InstanceMesh, // Instancing mesh</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            0, // submesh index</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            InstanceRenderMaterial, // Material to draw</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            bounds, // realm domain</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            argsBuffer // Argument buffer for GPU instancing</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        );</font></font></font></font><font></font>
    }<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    #endregion</font></font></font></font><font></font>
}<font></font>
<font></font>
</pre>
</div>

<h4><a id="h3-4-3-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU instancing</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When you want to draw a large number of the same mesh, if you create GameObjects one by one, the draw call will increase and the drawing load will increase. </font><font style="vertical-align: inherit;">In addition, the cost of transferring the calculation result of ComputeShader to the CPU memory is high, and if you want to perform processing at high speed, it is necessary to pass the calculation result of GPU as it is to the drawing shader and perform drawing processing. </font><font style="vertical-align: inherit;">With Unity's GPU instancing, you can draw a large number of identical meshes at high speed with few draw calls without creating unnecessary GameObjects.</font></font></p>

<h6><a id="h3-4-3-1-0-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Graphics.DrawMeshInstancedIndirect () method</font></font></h6>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This script uses the Graphics.DrawMeshInstancedIndirect method to draw a mesh with GPU instancing. </font><font style="vertical-align: inherit;">This method allows you to pass the number of mesh indexes and instances as a ComputeBuffer. </font><font style="vertical-align: inherit;">This is useful if you want to read all instance data from the GPU.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start () initializes the argument buffer for this GPU instancing. </font><font style="vertical-align: inherit;">Specify </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ComputeBufferType.IndirectArguments</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> as the </font><font style="vertical-align: inherit;">third argument of the constructor at initialization </font><font style="vertical-align: inherit;">.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RenderInstancedMesh () is performing mesh drawing with GPU instancing. </font><font style="vertical-align: inherit;">The Boid data (velocity, position array) obtained by the Boids simulation is passed to the material InstanceRenderMaterial for drawing with the SetBuffer method.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Graphics.DrawMeshInstancedIndrect method is passed as an argument a buffer that stores data such as the mesh to be instantiated, the index of the submesh, the drawing material, the boundary data, and the number of instances.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This method should normally be called within Update ().</font></font></p>

<h3><a id="h3-4-4"></a><span class="secno">3.4.4　</span>BoidsRender.shader</h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A shader for drawing that supports the Graphics.DrawMeshInstancedIndrect method.</font></font></p>
<div class="emlist-code">
<p class="caption">BoidsRender.shader</p>
<pre class="emlist language-hlsl">Shader "Hidden/GPUBoids/BoidsRender"<font></font>
{<font></font>
    Properties<font></font>
    {<font></font>
        _Color ("Color", Color) = (1,1,1,1)<font></font>
        _MainTex ("Albedo (RGB)", 2D) = "white" {}<font></font>
        _Glossiness ("Smoothness", Range(0,1)) = 0.5<font></font>
        _Metallic ("Metallic", Range(0,1)) = 0.0<font></font>
    }<font></font>
    SubShader<font></font>
    {<font></font>
        Tags { "RenderType"="Opaque" }<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        LOD 200</font></font></font></font><font></font>
<font></font>
        CGPROGRAM<font></font>
        #pragma surface surf Standard vertex:vert addshadow<font></font>
        #pragma instancing_options procedural:setup<font></font>
<font></font>
        struct Input<font></font>
        {<font></font>
            float2 uv_MainTex;<font></font>
        };<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Boid structure</font></font><font></font>
        struct BoidData<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        {</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            float3 velocity; // velocity</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            float3 position; // position</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        };</font></font></font></font><font></font>
<font></font>
        #ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Boid data structure buffer</font></font><font></font>
        StructuredBuffer&lt;BoidData&gt; _BoidDataBuffer;<font></font>
        #endif<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        sampler2D _MainTex; // Texture</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        half _Glossiness; // Gloss</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        half _Metallic; // Metal characteristics</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        fixed4 _Color; // Color</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        float3 _ObjectScale; // Boid object scale</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Convert Euler angles (radians) to rotation matrix</font></font><font></font>
        float4x4 eulerAnglesToRotationMatrix(float3 angles)<font></font>
        {<font></font>
            float ch = cos(angles.y); float sh = sin(angles.y); // heading<font></font>
            float ca = cos(angles.z); float sa = sin(angles.z); // attitude<font></font>
            float cb = cos(angles.x); float sb = sin(angles.x); // bank<font></font>
<font></font>
            // RyRxRz (Heading Bank Attitude)<font></font>
            return float4x4(<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                ch * ca + sh * sb * sa, -ch * sa + sh * sb * ca, sh * cb, 0,</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                cb * sa, cb * ca, -sb, 0,</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                -sh * ca + ch * sb * sa, sh * sa + ch * sb * ca, ch * cb, 0,</font></font></font></font><font></font>
                0, 0, 0, 1<font></font>
            );<font></font>
        }<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Vertex shader</font></font><font></font>
        void vert(inout appdata_full v)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        {</font></font></font></font><font></font>
            #ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // Get Boid data from instance ID</font></font><font></font>
            BoidData boidData = _BoidDataBuffer[unity_InstanceID];<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            float3 pos = boidData.position.xyz; // Get the position of Boid</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            float3 scl = _ObjectScale; // Get the Boid scale</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // Define a matrix to convert from object coordinates to world coordinates</font></font><font></font>
            float4x4 object2world = (float4x4)0;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // Substitute scale value</font></font><font></font>
            object2world._11_22_33_44 = float4(scl.xyz, 1.0);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // Calculate the rotation about the Y axis from the velocity</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            float rotY =</font></font></font></font><font></font>
                atan2(boidData.velocity.x, boidData.velocity.z);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // Calculate the rotation about the X axis from the velocity</font></font><font></font>
            float rotX =<font></font>
                -asin(boidData.velocity.y / (length(boidData.velocity.xyz)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                + 1e-8)); // 0 division prevention</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // Find the rotation matrix from Euler angles (radians)</font></font><font></font>
            float4x4 rotMatrix =<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                eulerAnglesToRotationMatrix (float3 (rotX, rotY, 0));</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // Apply rotation to matrix</font></font><font></font>
            object2world = mul(rotMatrix, object2world);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // Apply position (translation) to matrix</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            object2world._14_24_34 + = pos.xyz;</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // Coordinate transformation of vertices</font></font><font></font>
            v.vertex = mul(object2world, v.vertex);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // Convert normals to coordinates</font></font><font></font>
            v.normal = normalize(mul(object2world, v.normal));<font></font>
            #endif<font></font>
        }<font></font>
<font></font>
        void setup()<font></font>
        {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        }</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Surface shader</font></font><font></font>
        void surf (Input IN, inout SurfaceOutputStandard o)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        {</font></font></font></font><font></font>
            fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;<font></font>
            o.Albedo = c.rgb;<font></font>
            o.Metallic = _Metallic;<font></font>
            o.Smoothness = _Glossiness;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        }</font></font></font></font><font></font>
        ENDCG<font></font>
    }<font></font>
    FallBack "Diffuse"<font></font>
}<font></font>
<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">#pragma surface surf Standard vertex: vert addshadow In this part, surf () is specified as the surface shader, Standard is specified as the lighting model, and vert () is specified as the custom vertex shader.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can tell Unity to generate an additional variant for when using the Graphics.DrawMeshInstancedIndirect method by writing procedural: FunctionName in the #pragma instancing_options directive, specified by FunctionName at the beginning of the vertex shader stage. The function will be called. </font><font style="vertical-align: inherit;">If you look at the official sample (https://docs.unity3d.com/ScriptReference/Graphics.DrawMeshInstancedIndirect.html) etc., in this function, based on the position, rotation and scale of each instance, of the unity_ObjectToWorld matrix, unity_WorldToObject matrix I am rewriting, but in this sample program, I receive Boids data in the vertex shader and perform coordinate conversion of vertices and normals (I do not know if it is good ...). </font><font style="vertical-align: inherit;">Therefore, nothing is described in the specified setup function.</font></font></p>

<h4><a id="h3-4-4-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get Boid data for each instance with vertex shader and perform coordinate conversion</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Describe the processing to be performed on the vertices of the mesh passed to the shader in the vertex shader (Vertex Shader).</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can get a unique ID for each instance by unity_InstanceID. </font><font style="vertical-align: inherit;">By specifying this ID in the index of the array of StructuredBuffer declared as a buffer of Boid data, you can get Boid data unique to each instance.</font></font></p>

<h4><a id="h3-4-4-2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ask for rotation</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the Boid's velocity data, calculate the value of rotation that points in the direction of travel. </font><font style="vertical-align: inherit;">For the sake of intuitive handling, we will use Euler angles for rotation. </font><font style="vertical-align: inherit;">If you think of a Boid as a flying object, the three-axis rotations of the coordinates relative to the object are called pitch, yaw, and roll, respectively.</font></font></p>
<div id="roll-pitch-yaw" class="image">
<img src="./Chapter 3 _ GPU implementation of the simulation of the group_files/roll-pitch-yaw.png" alt="Axle and rotation designation">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.4: Axis and Rotation Names
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, from the velocity about the Z axis and the velocity about the X axis, find the yaw (which direction is facing the horizontal plane) using the atan2 method that returns the arctangent.</font></font></p>
<div id="arctan" class="image">
<img src="./Chapter 3 _ GPU implementation of the simulation of the group_files/arctan.png" alt="Relationship between speed and angle (yaw)">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.5: Relationship between speed and angle (yaw)
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, from the magnitude of the velocity and the ratio of the velocity with respect to the Y axis, the pitch (slope up and down) is calculated using the asin method that returns an inverse sine (arc sine). </font><font style="vertical-align: inherit;">If the speed of the Y axis is small among the speeds of each axis, the amount of rotation is weighted so that there is little change and the speed remains horizontal.</font></font></p>
<div id="arcsin" class="image">
<img src="./Chapter 3 _ GPU implementation of the simulation of the group_files/arcsin.png" alt="Relationship between speed and angle (pitch)">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.6: Relationship between velocity and angle (pitch)
</font></font></p>
</div>

<h4><a id="h3-4-4-3"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculate the matrix to apply the Boids transform</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coordinate transformation processes such as movement, rotation, and scaling can be collectively represented by a single matrix. </font><font style="vertical-align: inherit;">Defines a 4x4 matrix object2world.</font></font></p>

<h5><a id="h3-4-4-3-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scale</font></font></h5>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, substitute the scale value. </font><font style="vertical-align: inherit;">The </font><font style="vertical-align: inherit;">matrix S that </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scales</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> by </font><span class="equation"><font style="vertical-align: inherit;">\ rm S_x S_y S_z {} on</font></span><font style="vertical-align: inherit;"> each of the XYZ axes </font><font style="vertical-align: inherit;">is expressed as follows.</font></font></p>
<div class="equation">
<pre>\rm<font></font>
S=<font></font>
\left(<font></font>
\begin{array}{cccc}<font></font>
\rm S_x &amp; 0 &amp; 0 &amp; 0 \\<font></font>
0 &amp; \rm S_y &amp; 0 &amp; 0 \\<font></font>
0 &amp; 0 &amp; \rm S_z &amp; 0 \\<font></font>
0 &amp; 0 &amp; 0 &amp; 1<font></font>
\end{array}<font></font>
\right)<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variables of type float4x4 in HLSL can specify specific elements of the matrix using a swizzle such as ._11_22_33_44. </font><font style="vertical-align: inherit;">By default, the components are arranged as follows:</font></font></p>
<div id="tbl2" class="table">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Form 3.1: </font></font></p>
<table>
<tbody><tr><th>11</th><th>12</th><th>13</th><th>14</th></tr>
<tr><td>21</td><td>22</td><td>23</td><td>24</td></tr>
<tr><td>31</td><td>32</td><td>33</td><td>34</td></tr>
<tr><td>41</td><td>42</td><td>43</td><td>44</td></tr>
</tbody></table>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, substitute the XYZ scale values ​​for 11, 22, 33, and 1 for 44.</font></font></p>

<h5><a id="h3-4-4-3-2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rotation</font></font></h5>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then apply the rotation. </font><font style="vertical-align: inherit;">If the rotation </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ rm R_x R_y R_z {}</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for </font><font style="vertical-align: inherit;">each of the XYZ axes </font><font style="vertical-align: inherit;">is represented by a matrix,</font></font></p>
<div class="equation">
<pre>\rm<font></font>
R_x(\phi)=<font></font>
\left(<font></font>
\begin{array}{cccc}<font></font>
1 &amp; 0 &amp; 0 &amp; 0 \\<font></font>
0 &amp; \rm cos(\phi) &amp; \rm -sin(\phi) &amp; 0 \\<font></font>
0 &amp; \rm sin(\phi) &amp; \rm cos(\phi) &amp; 0 \\<font></font>
0 &amp; 0 &amp; 0 &amp; 1<font></font>
\end{array}<font></font>
\right)<font></font>
</pre>
</div>
<div class="equation">
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\rm</font></font></font></font><font></font>
R_y(\theta)=<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
\left(</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
\begin{array}{cccc}</font></font></font></font><font></font>
\rm cos(\theta) &amp; 0 &amp; \rm sin(\theta) &amp; 0 \\<font></font>
0 &amp; 1 &amp; 0 &amp; 0 \\<font></font>
\rm -sin(\theta) &amp; 0 &amp; \rm cos(\theta) &amp; 0 \\<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0 &amp; 0 &amp; 0 &amp; 1</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
\end{array}</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
\right)</font></font></font></font><font></font>
</pre>
</div>
<div class="equation">
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\rm</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
R_z (\ psi) =</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
\left(</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
\begin{array}{cccc}</font></font></font></font><font></font>
\rm cos(\psi) &amp; \rm -sin(\psi) &amp; 0 &amp; 0 \\<font></font>
\rm sin(\psi) &amp; \rm cos(\psi) &amp; 0 &amp; 0 \\<font></font>
0 &amp; 0 &amp; 1 &amp; 0 \\<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0 &amp; 0 &amp; 0 &amp; 1</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
\end{array}</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
\right)</font></font></font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Combine this into a matrix. </font><font style="vertical-align: inherit;">At this time, the behavior at the time of rotation changes depending on the order of the axes of rotation to be combined, but if you combine in this order, it should be similar to the standard rotation of Unity.</font></font></p>
<div id="synth-euler2matrix" class="image">
<img src="./Chapter 3 _ GPU implementation of the simulation of the group_files/synth-euler2matrix.png" alt="Synthesis of rotation matrix">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.7: Synthesis of rotation matrix
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The rotation is applied by finding the product of the rotation matrix thus obtained and the matrix to which the above scale is applied.</font></font></p>

<h5><a id="h3-4-4-3-3"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Translation</font></font></h5>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then apply translation. </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assuming</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that </font><span class="equation"><font style="vertical-align: inherit;">\ rm T_x T_y T_z {}</font></span><font style="vertical-align: inherit;"> translates </font><font style="vertical-align: inherit;">to each axis </font><font style="vertical-align: inherit;">, the matrix is ​​expressed as follows.</font></font></p>
<div class="equation">
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ rm T =</font></font></font></font><font></font>
\left(<font></font>
\begin{array}{cccc}<font></font>
1 &amp; 0 &amp; 0 &amp; \rm T_x \\<font></font>
0 &amp; 1 &amp; 0 &amp; \rm T_y \\<font></font>
0 &amp; 0 &amp; 1 &amp; \rm T_z \\<font></font>
0 &amp; 0 &amp; 0 &amp; 1<font></font>
\end{array}<font></font>
\right)<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This translation can be applied by adding the Position data for each of the XYZ axes to the 14, 24, and 34 components.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By applying the matrix obtained by these calculations to the vertices and normals, the Boid transform data is reflected.</font></font></p>

<h3><a id="h3-4-5"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.4.5　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Drawing result</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I think that objects that move like a group like this are drawn.</font></font></p>
<div id="result" class="image">
<img src="./Chapter 3 _ GPU implementation of the simulation of the group_files/result.png" alt="Execution result">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.8: Execution result
</font></font></p>
</div>

<h2><a id="h3-5"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.5　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Summary</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The implementation introduced in this chapter uses the minimum Boids algorithm, but it has different characteristics such as a large group or a number of small colonies even by adjusting the parameters. I think it will move. </font><font style="vertical-align: inherit;">In addition to the basic rules of conduct shown here, there are other rules to consider. </font><font style="vertical-align: inherit;">For example, if this is a school of fish and foreign enemies that prey on them appear, they will naturally move away, and if there are obstacles such as terrain, the fish will avoid hitting them. </font><font style="vertical-align: inherit;">When thinking about vision, the field of view and accuracy differ depending on the species of animal, and I think that if you exclude other individuals outside the field of view from the calculation process, it will be closer to the actual one. </font><font style="vertical-align: inherit;">The characteristics of movement also change depending on the environment such as whether it flies in the sky, moves in water, or moves on land, and the characteristics of the motor organs for locomotion. </font><font style="vertical-align: inherit;">You should also pay attention to individual differences.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallel processing by GPU can calculate more individuals than calculation by CPU, but basically the calculation with other individuals is done by brute force, and the calculation efficiency is not very good. </font><font style="vertical-align: inherit;">To do this, the calculation cost is improved by improving the efficiency of searching for nearby individuals, such as registering individuals in an area divided by a grid or block according to their position and performing calculation processing only for individuals existing in adjacent areas. Can be suppressed.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is still plenty of room for improvement, and by applying appropriate implementation and behavioral rules, we will be able to express even more beautiful, powerful, dense and tasty group movements. </font><font style="vertical-align: inherit;">I want to be able to do it.</font></font></p>

<h2><a id="h3-6"></a><span class="secno"><font style="vertical-align: inherit;"></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">See </font><span class="secno"><font style="vertical-align: inherit;">3.6　</font></span></font></h2>
<ul>
<li>Boids Background and Update - https://www.red3d.com/cwr/boids/</li>
<li>THE NATURE OF CODE - http://natureofcode.com/</li>
<li>Real-Time Particle Systems on the GPU in Dynamic Environments - http://amd-dev.wpengine.netdna-cdn.com/wordpress/media/2013/02/Chapter7-Drone-Real-Time<b>Particle</b>Systems<b>On</b>The_GPU.pdf</li>
<li>Practical Rendering and Computation with Direct3D 11 - https://dl.acm.org/citation.cfm?id=2050039</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introduction to GPU Parallel Graphic Processing --http://gihyo.jp/book/2014/978-4-7741-6304-8</font></font></li>
</ul></body></html>