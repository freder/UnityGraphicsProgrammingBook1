<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="en" style="height: 100%;" class="translated-ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <link rel="stylesheet" type="text/css" href="./Chapter 4 _ Fluid Simulation by Lattice Method_files/style.scss">
  <meta name="generator" content="Re:VIEW">
  <title>Fluid simulation by grid method</title>

			<style>
				img {
					max-width: 80vw;
					max-height: 80vh;
				}
			</style><style>
					.goog-te-banner-frame {
						display: none;
					}
				</style>
			<script>(function(){(function injection() {
  var pageLang = 'ja';
  var userLang = 'en';

  var uid = '1E07F158C6FA4460B352973E9693B329';
  var teId = 'TE_' + uid;
  var cbId = 'TECB_' + uid;

  function show() {
    window.setTimeout(function() {
      window[teId].showBanner(true);
    }, 10);
  }

  function newElem() {
    
  }

  if (window[teId]) {
    show();
  } else {
    if (!window.google || !google.translate ||
        !google.translate.TranslateElement) {
      if (!window[cbId]) {
        window[cbId] = function() {
          window[teId] = newElem();
          show();
        };
      }
      
    }
  }
})();})();</script><script src="https://translate.google.com/translate_a/element.js?cb=TECB_1E07F158C6FA4460B352973E9693B329&amp;client=tee&amp;hl=en"></script><script src="./Chapter 4 _ Fluid Simulation by Lattice Method_files/f.txt"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://translate.googleapis.com/translate_static/css/translateelement.css"><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/translate_static/js/element/main.js"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="./Chapter 4 _ Fluid Simulation by Lattice Method_files/translateelement.css"><script type="text/javascript" charset="UTF-8" src="./Chapter 4 _ Fluid Simulation by Lattice Method_files/main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script><script type="text/javascript" charset="UTF-8" src="./Chapter 4 _ Fluid Simulation by Lattice Method_files/element_main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://translate.googleapis.com/translate_static/css/translateelement.css"><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/translate_static/js/element/main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script></head>
		
<body style="position: relative; min-height: 100%; top: 40px;"><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div>
<h1><a id="h4"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;" class="">Chapter 4　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;" class=""> Fluid Simulation by Lattice Method</font></font></h1>

<h2><a id="h4-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> About this chapter</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this chapter, we will explain the fluid simulation by the lattice method using Compute Shader.</font></font></p>

<h2><a id="h4-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sample data</font></font></h2>

<h3><a id="h4-2-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code</font></font></h3>
<p><a href="https://github.com/IndieVisualLab/UnityGraphicsProgramming/" class="link">https://github.com/IndieVisualLab/UnityGraphicsProgramming/</a></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is stored in Assets / StabeFluids of.</font></font></p>

<h3><a id="h4-2-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Execution environment</font></font></h3>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shader model 5.0 compatible environment where ComputeShader can be executed</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operation confirmed in writing environment, Unity5.6.2, Unity2017.1.1</font></font></li>
</ul>

<h2><a id="h4-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Introduction</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this chapter, we will explain the fluid simulation by the lattice method and the calculation method and understanding of mathematical formulas necessary for realizing them. </font><font style="vertical-align: inherit;">First of all, what is the grid method? </font><font style="vertical-align: inherit;">In order to explore its meaning, let's take a closer look at how to analyze "flow" in fluid mechanics.</font></font></p>

<h3><a id="h4-3-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3.1 How　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to understand in fluid mechanics</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fluid mechanics is characterized by formulating a natural phenomenon, "flow," and making it computable. </font><font style="vertical-align: inherit;">How can this "flow" be quantified and analyzed? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you go straight to it, you can quantify it by deriving the "flow velocity when the time advances for a moment". </font><font style="vertical-align: inherit;">To put it a little mathematically, it can be rephrased as an analysis of the amount of change in the flow velocity vector when differentiating with time. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, there are two possible methods for analyzing this flow. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One is to measure the flow velocity vector of each fixed lattice space by dividing the hot water in the bath into a grid when imagining the hot water in the bath. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the other is to float a duck in the bath and analyze the movement of the duck itself. </font><font style="vertical-align: inherit;">Of these two methods, the former is called the "Euler's method" and the latter is called the "Lagrange's method".</font></font></p>

<h3><a id="h4-3-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Various fluid simulations</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, let's get back to computer graphics. </font><font style="vertical-align: inherit;">There are several simulation methods for fluid simulation, such as "Euler's method" and "Lagrange's method", but they can be roughly divided into the following three types.</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lattice method (eg Stable Fluid)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Particle Method (eg SPH)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lattice method + particle method (eg FLIP)</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can imagine from the meaning of Chinese characters, the grid method creates a grid-like "field" when simulating the flow, like the "Euler's method", and when it is differentiated with time, it is It is a method of simulating the speed of each grid. </font><font style="vertical-align: inherit;">In addition, the particle method is a method of simulating the advection of the particles themselves, focusing on the particles, such as the "Lagrange method". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Along with the lattice method and particle method, there are areas of strength and weakness in each other. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The lattice method is good at calculating pressure, viscosity, diffusion, etc. in fluid simulation, but not good at advection calculation. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the contrary, the particle method is good at calculating advection. </font><font style="vertical-align: inherit;">(You can imagine </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">these </font><font style="vertical-align: inherit;">strengths and weaknesses when you think of how to analyze Euler's method and Lagrange's method.) </font><font style="vertical-align: inherit;">To supplement these, the lattice method + particle method represented by the FLIP method. There are also methods that complement each other's areas of expertise.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this paper, we will explain the implementation method of fluid simulation and the necessary mathematical formulas in the simulation based on Stable Fluids, which is a paper on incompressible viscous fluid simulation in the lattice method by Jon Stam published at SIGGRAPH 1999. ..</font></font></p>

<h2><a id="h4-4"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.4　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> About the Navier-Stokes equation</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, let's look at the Navier-Stokes equation in the grid method.</font></font></p>
<div class="equation">
<pre>\dfrac {\partial \overrightarrow {u}} {\partial t}=-\left( \overrightarrow {u} \cdot \nabla \right) \overrightarrow {u} + \nu \nabla ^{2} \overrightarrow {u} + \overrightarrow{f}
</pre>
</div>
<div class="equation">
<pre>\dfrac {\partial \rho} {\partial t}=-\left( \overrightarrow {u} \cdot \nabla \right) \rho + \kappa \nabla ^{2} \rho + S
</pre>
</div>
<div class="equation">
<pre>\nabla \cdot \overrightarrow{u} = 0
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of the above, the first equation represents the velocity field and the second represents the density field. </font><font style="vertical-align: inherit;">The third is the "continuity equation (conservation of mass)". </font><font style="vertical-align: inherit;">Let's unravel these three formulas one by one.</font></font></p>

<h2><a id="h4-5"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.5　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Continuity equation (conservation of mass)</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, let's unravel the "continuity equation (conservation of mass)", which is short as an equation and works as a condition when simulating an "incompressible" fluid. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When simulating a fluid, it is necessary to make a clear distinction between compressible and incompressible objects. </font><font style="vertical-align: inherit;">For example, if the target is a gas whose density changes with pressure, it will be a compressible fluid. </font><font style="vertical-align: inherit;">Conversely, objects with a constant density, such as water, are incompressible fluids. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since this chapter deals with incompressible fluid simulations, the divergence of each cell in the velocity field should be kept at zero. </font><font style="vertical-align: inherit;">That is, it offsets the inflow and outflow of the velocity field and keeps it at zero. </font><font style="vertical-align: inherit;">If there is an inflow, it will flow out, so the flow velocity will propagate. </font><font style="vertical-align: inherit;">This condition can be expressed by the following equation as a continuity equation (conservation of mass).</font></font></p>
<div class="equation">
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\nabla \cdot \overrightarrow{u} = 0
</font></font></pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The above means that "divergence is 0". </font><font style="vertical-align: inherit;">First, let's check the formula of "divergence".</font></font></p>

<h3><a id="h4-5-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.5.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Divergence</font></font></h3>
<div class="equation">
<pre>\nabla \cdot \overrightarrow{u} = \nabla \cdot (u, v) = \dfrac{\partial u}{\partial x} + \dfrac{\partial v}{\partial y}
</pre>
</div>
<p><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ nabla</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (nabla operator) is called the vector differential operator. </font><font style="vertical-align: inherit;">For example, assuming that the vector field is two-dimensional, </font><font style="vertical-align: inherit;">the partial differential of </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ left (\ dfrac {\ partial} {\ partial x} _, \ dfrac {\ partial} {\ partial y} \ right)</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is </font><font style="vertical-align: inherit;">calculated as shown in the figure. </font><font style="vertical-align: inherit;">It acts as an operator that simplifies the notation of partial differential when taking. </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the \ nabla</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operator is an operator, it has no meaning by itself, but the </font><font style="vertical-align: inherit;">operation content changes depending on </font><font style="vertical-align: inherit;">whether the expression to be combined together is an inner product, an outer product, or just a </font><font style="vertical-align: inherit;">function such as </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ nabla f</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This time, let's explain "divergence" which takes the inner product of partial differential. </font><font style="vertical-align: inherit;">First, let's see why this formula means "divergence".</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to understand the divergence, let's first cut out one cell in the lattice space as shown below.</font></font></p>
<div id="divergence-s" class="image">
<img src="./Chapter 4 _ Fluid Simulation by Lattice Method_files/divergence-s.png" alt="Extract cells in the differential interval (Δx, Δy) from the vector field" class="width-070per">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 4.1: Extracting cells in the differential interval (Δx, Δy) from the vector field
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Divergence is the calculation of how many vectors flow out and flow into one cell of a vector field. </font><font style="vertical-align: inherit;">The outflow is + and the inflow is-.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As mentioned above, the divergence is the </font><font style="vertical-align: inherit;">amount of change </font><font style="vertical-align: inherit;">between the specific point x in the x direction and the slightly advanced </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ Delta x</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> when looking at the partial differential when the cell of the vector field is cut out, and the specific </font><font style="vertical-align: inherit;">amount in the y direction. It </font><font style="vertical-align: inherit;">can be calculated by the inner product of the amount of change between the </font><font style="vertical-align: inherit;">point y and the slightly advanced </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ Delta y</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The reason why the outflow can be obtained by the inner product with the partial differential can be proved by performing a differential operation on the above figure.</font></font></p>
<div class="equation">
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ frac {i (x + \ Delta x, y) \ Delta y - i (x, y) \ Delta y + j (x, y + \ Delta y) \ Delta x - j (x, y) \ Delta x } {\ Delta x \ Delta y}
</font></font></font></font></pre>
</div>
<div class="equation">
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = \ frac {i (x + \ Delta x, y) - i (x, y)} {\ Delta x} + \ frac {j (x, y + \ Delta y) - j (x, y)} { \ Delta Y}
</font></font></font></font></pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taking the limit from the above formula,</font></font></p>
<div class="equation">
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ lim _ {\ Delta x \ to 0} \ frac {i (x + \ Delta x, y) - i (x, y)} {\ Delta x} + \ lim _ {\ Delta y \ to 0} \ frac {j (x, y + \ Delta y) - j (x, y)} {\ Delta y} = \ dfrac {\ partial i} {\ partial x} + \ dfrac {\ partial j} {\ partial y }
</font></font></font></font></pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By doing so, we can see that the final equation is the equation of the inner product with the partial derivative.</font></font></p>

<h2><a id="h4-6"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.6　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Velocity field</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, I will explain the velocity field, which is the main body of the lattice method. </font><font style="vertical-align: inherit;">Before that, in implementing the Navier-Stokes equation of the velocity field, let's confirm the gradient and the Laplacian in addition to the divergence confirmed earlier.</font></font></p>

<h3><a id="h4-6-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.6.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gradient</font></font></h3>
<div class="equation">
<pre>\nabla f(x, y) = \left( \dfrac{\partial f}{\partial x}_,\dfrac{\partial f}{\partial y}\right)
</pre>
</div>
<p><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ nabla f (grad \ f)</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the formula for finding the gradient. </font><font style="vertical-align: inherit;">The meaning is </font><font style="vertical-align: inherit;">which vector is finally directed by sampling the </font><font style="vertical-align: inherit;">coordinates slightly advanced in each partial differential direction with the function </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and synthesizing the obtained values ​​in each partial differential direction. I will. </font><font style="vertical-align: inherit;">In other words, it is possible to calculate a vector that points in the direction of the larger value when partially differentiated.</font></font></p>

<h3><a id="h4-6-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.6.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Laplacian</font></font></h3>
<div class="equation">
<pre>\Delta f = \nabla^2 f = \nabla \cdot \nabla f = \frac{\partial^2 f}{\partial x^2} + \frac{\partial^2 f}{\partial y^2}
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Laplacian is represented by a symbol with the nabla turned upside down. </font><font style="vertical-align: inherit;">(Same as delta, but read from the context and make sure you don't make a mistake.) </font><font style="vertical-align: inherit;">Also write </font></font><br><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ nabla ^ 2 f</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ nabla \ cdot \ nabla f</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and it is calculated as the second derivative. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, if you think about it by disassembling it, you can take the form of finding the divergence by taking the gradient of the function. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In terms of meaning, in the vector field, the part concentrated in the gradient direction has a lot of inflow, so when the divergence is taken, the part with a low gradient has a lot of springing out, so when the divergence is taken, it becomes +. I can imagine that. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laplacian operators include scalar Laplacian and vector Laplacian, and when acting on a vector field, gradient, divergence, and rotation (cross product of ∇ and vector) are used.</font></font><br></p>
<div class="equation">
<pre>\nabla^2 \overrightarrow{u} = \nabla \nabla \cdot \overrightarrow{u} - \nabla \times \nabla \times \overrightarrow{u}
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, only in the case of the Cartesian coordinate system, the gradient and divergence can be obtained for each component of the vector and can be obtained by combining them.</font></font></p>
<div class="equation">
<pre>\nabla^2 \overrightarrow{u} = \left(<font></font>
\dfrac{\partial ^2 u_x}{\partial x^2}+\dfrac{\partial ^2 u_x}{\partial y^2}+\dfrac{\partial ^2 u_x}{\partial z^2}_,<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
\ dfrac {\ partial ^ 2 u_y} {\ partial x ^ 2} + \ dfrac {\ partial ^ 2 u_y} {\ partial y ^ 2} + \ dfrac {\ partial ^ 2 u_y} {\ partial z ^ 2} _,</font></font></font></font><font></font>
\dfrac{\partial ^2 u_z}{\partial x^2}+\dfrac{\partial ^2 u_z}{\partial y^2}+\dfrac{\partial ^2 u_z}{\partial z^2}<font></font>
\right)<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This completes the confirmation of the mathematical formulas required to solve the Navier-Stokes equation in the grid method. </font><font style="vertical-align: inherit;">From here, let's look at the velocity field equation for each term.</font></font></p>

<h3><a id="h4-6-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.6.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Confirmation of velocity field from Navier-Stokes equation</font></font></h3>
<div class="equation">
<pre>\dfrac {\partial \overrightarrow {u}} {\partial t}=-\left( \overrightarrow {u} \cdot \nabla \right) \overrightarrow {u} + \nu \nabla ^{2} \overrightarrow {u} + \overrightarrow {f}
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of the above, </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ overrightarrow {u}</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the flow velocity, </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ nu</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the kinematic viscosity, and </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ overrightarrow {f}</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the external force (force). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can see that the left side is the flow velocity when the partial differential is taken with respect to time. </font><font style="vertical-align: inherit;">On the right side, the first term is the advection term, the second term is the diffusion viscosity term, the third term is the pressure term, and the fourth term is the external force term.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even if these can be done collectively at the time of calculation, it is necessary to implement them in steps at the time of implementation. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First of all, as a step, if you do not receive an external force, you cannot make a change under the initial conditions, so I would like to start with the external force term in the fourth term.</font></font></p>

<h3><a id="h4-6-4"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.6.4 External　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> force term of velocity field</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is simply the part that adds the vectors from the outside. </font><font style="vertical-align: inherit;">In other words, when the velocity field is 0 in the initial condition, the vector is added to the corresponding ID of RWTexture2D from the UI as the starting point of the vector or some event. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The kernel of the external force term of the compute shader is implemented as follows. </font><font style="vertical-align: inherit;">Also, describe the definitions of each coefficient and buffer that will be used in the compute shader.</font></font></p>
<div class="emlist-code">
<pre class="emlist"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">float visc; //Dynamic viscosity coefficient</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
float dt; // delta time</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
float velocityCoef; //external force coefficient of velocity field</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
float densityCoef; //Density outside pressure coefficient</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// xy = velocity, z = density, fluid solver to pass to drawing shader</font></font><font></font>
RWTexture2D&lt;float4&gt; solver;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
//density field, density field</font></font><font></font>
RWTexture2D&lt;float&gt;  density;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
//velocity field, velocity field</font></font><font></font>
RWTexture2D&lt;float2&gt; velocity;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// xy = for vel, z = for dens. </font><font style="vertical-align: inherit;">when project, x = p, y = div</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Save the buffer one step before and the temporary buffer when saving the mass</font></font><font></font>
RWTexture2D&lt;float3&gt; prev;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// xy = velocity source, z = density source External force input buffer</font></font><font></font>
Texture2D source;<font></font>
<font></font>
[numthreads(THREAD_X, THREAD_Y, THREAD_Z)]<font></font>
void AddSourceVelocity(uint2 id : SV_DispatchThreadID)<font></font>
{<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    uint w, h;</font></font></font></font><font></font>
    velocity.GetDimensions(w, h);<font></font>
<font></font>
    if (id.x &lt; w &amp;&amp; id.y &lt; h)<font></font>
    {<font></font>
        velocity[id] += source[id].xy * velocityCoef * dt;<font></font>
        prev[id] = float3(source[id].xy * velocityCoef * dt, prev[id].z);<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next step is to implement the second term, the diffusion viscosity term.</font></font></p>

<h3><a id="h4-6-5"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.6.5　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dispersion viscosity term of velocity field</font></font></h3>
<div class="equation">
<pre>\nu \nabla ^{2} \overrightarrow {u}
</pre>
</div>
<p><span class="equation"><font style="vertical-align: inherit;"></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When there are values ​​on the left and right of the </font><span class="equation"><font style="vertical-align: inherit;">\ nabla</font></span><font style="vertical-align: inherit;"> operator and </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ Delta</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operator, there is a rule that "acts only on the right element", so in this case, leave the kinematic viscosity coefficient once and leave the vector Laplacian part. Think first. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With </font><font style="vertical-align: inherit;">vector Laplacian for the </font><font style="vertical-align: inherit;">flow velocity </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ overright</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> arrow </font><span class="equation"><font style="vertical-align: inherit;">{u}</font></span><font style="vertical-align: inherit;"> , the gradient and divergence of each component of the vector are taken and combined, and the flow velocity is diffused adjacently. </font><font style="vertical-align: inherit;">By multiplying it by the kinematic viscosity coefficient, the momentum of diffusion is adjusted. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, since the gradient of each component of the flow velocity is taken and diffused, inflow from the adjacency and outflow to the adjacency occur, and the phenomenon that the vector received in step 1 affects the adjacency can be understood. think. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In terms of mounting, some ingenuity is required. </font><font style="vertical-align: inherit;">If implemented according to the formula, if the diffusivity obtained by multiplying the viscosity coefficient by the differential time / number of lattices becomes high, vibration will occur, convergence will not be achieved, and the simulation itself will eventually diverge. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterative methods such as the Gauss-Seidel method, Jacobi method, and SOR method are used here to make the diffusion stable. </font><font style="vertical-align: inherit;">Here, let's simulate with the Gauss-Seidel method. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Gauss-Seidel method is a method of converting a formula into a linear equation consisting of unknowns for its own cell, using the calculated value immediately at the next iteration, and chaining it to converge to an approximate answer. </font><font style="vertical-align: inherit;">The higher the number of iterations, the more accurate the values ​​will converge, but graphics in real-time rendering require better frame rates and aesthetics rather than accurate results, so iterations are machine. Adjust for performance and appearance.</font></font></p>
<div class="emlist-code">
<pre class="emlist">#define GS_ITERATE 4<font></font>
<font></font>
[numthreads(THREAD_X, THREAD_Y, THREAD_Z)]<font></font>
void DiffuseVelocity(uint2 id : SV_DispatchThreadID)<font></font>
{<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    uint w, h;</font></font></font></font><font></font>
    velocity.GetDimensions(w, h);<font></font>
<font></font>
    if (id.x &lt; w &amp;&amp; id.y &lt; h)<font></font>
    {<font></font>
        float a = dt * visc * w * h;<font></font>
<font></font>
        [unroll]<font></font>
        for (int k = 0; k &lt; GS_ITERATE; k++) {<font></font>
            velocity[id] = (prev[id].xy + a * (<font></font>
                            velocity[int2(id.x - 1, id.y)] +<font></font>
                            velocity[int2(id.x + 1, id.y)] +<font></font>
                            velocity[int2(id.x, id.y - 1)] +<font></font>
                            velocity[int2(id.x, id.y + 1)]<font></font>
                            )) / (1 + 4 * a);<font></font>
            SetBoundaryVelocity(id, w, h);<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The SetBoundaryVelocity function above is a method for boundaries. </font><font style="vertical-align: inherit;">Please refer to the repository for details.</font></font></p>

<h3><a id="h4-6-6"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.6.6　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quality preservation</font></font></h3>
<div class="equation">
<pre>\nabla \cdot \overrightarrow{u} = 0
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's go back to the conservation of mass side before proceeding with the section. </font><font style="vertical-align: inherit;">In the process so far, the force received in the external force term is diffused in the velocity field, but at present, the mass of each cell is not preserved, and the mass is in the place where it keeps springing out and the place where there is a lot of inflow. Is in an unsaved state. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As in the equation above, you must save the mass and bring the divergence of each cell to 0, so let's save the mass here. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, when performing the mass conservation step with Compute Shader, the field must be fixed because the partial differential operation with the adjacent thread is performed. </font><font style="vertical-align: inherit;">It was expected to speed up if the partial differential operation could be performed in the group shared memory, but when the partial differential was taken from another group thread, the value could not be obtained and the result was dirty, so here is a buffer. While confirming, proceed in 3 steps. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Divergence calculation from velocity field&gt; Poisson's equation is calculated by Gauss-Seidel method&gt; Subtract to velocity field, divide the </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kernel into 3 steps of conservation of mass, and bring it to conservation of mass while determining the field. </font><font style="vertical-align: inherit;">In addition, SetBound ~ system is a method call for the boundary.</font></font></p>
<div class="emlist-code">
<pre class="emlist"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">//Quality preservation Step1.</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// In step1, calculate the divergence from the velocity field</font></font><font></font>
[numthreads(THREAD_X, THREAD_Y, THREAD_Z)]<font></font>
void ProjectStep1(uint2 id : SV_DispatchThreadID)<font></font>
{<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    uint w, h;</font></font></font></font><font></font>
    velocity.GetDimensions(w, h);<font></font>
<font></font>
    if (id.x &lt; w &amp;&amp; id.y &lt; h)<font></font>
    {<font></font>
        float2 uvd;<font></font>
        uvd = float2(1.0 / w, 1.0 / h);<font></font>
<font></font>
        prev[id] = float3(0.0,<font></font>
                    -0.5 *<font></font>
                    (uvd.x * (velocity[int2(id.x + 1, id.y)].x -<font></font>
                              velocity[int2(id.x - 1, id.y)].x)) +<font></font>
                    (uvd.y * (velocity[int2(id.x, id.y + 1)].y -<font></font>
                              velocity[int2(id.x, id.y - 1)].y)),<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                    prev [id] .z);</font></font></font></font><font></font>
<font></font>
        SetBoundaryDivergence(id, w, h);<font></font>
        SetBoundaryDivPositive(id, w, h);<font></font>
    }<font></font>
}<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
//Quality preservation Step2.</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// In step2, the Poisson equation is solved by the Gauss-Seidel method from the divergence obtained in step1.</font></font><font></font>
[numthreads(THREAD_X, THREAD_Y, THREAD_Z)]<font></font>
void ProjectStep2(uint2 id : SV_DispatchThreadID)<font></font>
{<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    uint w, h;</font></font></font></font><font></font>
<font></font>
    velocity.GetDimensions(w, h);<font></font>
<font></font>
    if (id.x &lt; w &amp;&amp; id.y &lt; h)<font></font>
    {<font></font>
        for (int k = 0; k &lt; GS_ITERATE; k++)<font></font>
        {<font></font>
            prev[id] = float3(<font></font>
                        (prev[id].y + prev[uint2(id.x - 1, id.y)].x +<font></font>
                                      prev[uint2(id.x + 1, id.y)].x +<font></font>
                                      prev[uint2(id.x, id.y - 1)].x +<font></font>
                                      prev[uint2(id.x, id.y + 1)].x) / 4,<font></font>
                        prev[id].yz);<font></font>
            SetBoundaryDivPositive(id, w, h);<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
//Quality preservation Step3.</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// In step3, set ∇ ･ u = 0.</font></font><font></font>
[numthreads(THREAD_X, THREAD_Y, THREAD_Z)]<font></font>
void ProjectStep3(uint2 id : SV_DispatchThreadID)<font></font>
{<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    uint w, h;</font></font></font></font><font></font>
<font></font>
    velocity.GetDimensions(w, h);<font></font>
<font></font>
    if (id.x &lt; w &amp;&amp; id.y &lt; h)<font></font>
    {<font></font>
        float  velX, velY;<font></font>
        float2 uvd;<font></font>
        uvd = float2(1.0 / w, 1.0 / h);<font></font>
<font></font>
        velX = velocity[id].x;<font></font>
        velY = velocity[id].y;<font></font>
<font></font>
        velX -= 0.5 * (prev[uint2(id.x + 1, id.y)].x -<font></font>
                       prev[uint2(id.x - 1, id.y)].x) / uvd.x;<font></font>
        velY -= 0.5 * (prev[uint2(id.x, id.y + 1)].x -<font></font>
                       prev[uint2(id.x, id.y - 1)].x) / uvd.y;<font></font>
<font></font>
        velocity[id] = float2(velX, velY);<font></font>
        SetBoundaryVelocity(id, w, h);<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The velocity field is now in a state of conservation of mass. </font><font style="vertical-align: inherit;">Since the inflow occurs at the place where the outflow occurs and the outflow occurs from the place where there is a lot of inflow, it is expressed like a fluid.</font></font></p>

<h3><a id="h4-6-7"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.6.7　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Advection term</font></font></h3>
<div class="equation">
<pre>-\left( \overrightarrow {u} \cdot \nabla \right) \overrightarrow {u}
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lagrange's method is used for the advection term, but the work of back tracing the velocity field one step before and moving the value of the place where the velocity vector is subtracted from the corresponding cell to the current location Do this for each cell. </font><font style="vertical-align: inherit;">When backtraced, it does not go back to the place where it fits exactly in the grid, so when advection, linear interpolation with the neighboring 4 cells is performed and the correct value is advected.</font></font></p>
<div class="emlist-code">
<pre class="emlist">[numthreads(THREAD_X, THREAD_Y, THREAD_Z)]<font></font>
void AdvectVelocity(uint2 id : SV_DispatchThreadID)<font></font>
{<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    uint w, h;</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    density.GetDimensions (w, h);</font></font></font></font><font></font>
<font></font>
    if (id.x &lt; w &amp;&amp; id.y &lt; h)<font></font>
    {<font></font>
        int ddx0, ddx1, ddy0, ddy1;<font></font>
        float x, y, s0, t0, s1, t1, dfdt;<font></font>
<font></font>
        dfdt = dt * (w + h) * 0.5;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Back trace point index.</font></font><font></font>
        x = (float)id.x - dfdt * prev[id].x;<font></font>
        y = (float)id.y - dfdt * prev[id].y;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Clamp so that the points are within the simulation range.</font></font><font></font>
        clamp(x, 0.5, w + 0.5);<font></font>
        clamp(y, 0.5, h + 0.5);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Determining cells near the back trace point.</font></font><font></font>
        ddx0 = floor(x);<font></font>
        ddx1 = ddx0 + 1;<font></font>
        ddy0 = floor(y);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        Dy1 = Dy0 + 1;</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Save the difference for linear interpolation with neighboring cells.</font></font><font></font>
        s1 = x - ddx0;<font></font>
        s0 = 1.0 - s1;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        t1 = y - ddy0;</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        t0 = 1.0 - t1;</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Backtrace, take the value one step before by linear interpolation with the neighborhood, and substitute it for the current velocity field.</font></font><font></font>
        velocity[id] = s0 * (t0 * prev[int2(ddx0, ddy0)].xy +<font></font>
                             t1 * prev[int2(ddx0, ddy1)].xy) +<font></font>
                       s1 * (t0 * prev[int2(ddx1, ddy0)].xy +<font></font>
                             t1 * prev[int2(ddx1, ddy1)].xy);<font></font>
        SetBoundaryVelocity(id, w, h);<font></font>
    }<font></font>
}<font></font>
</pre>
</div>

<h2><a id="h4-7"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.7　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Density field</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, let's look at the density field equation.</font></font></p>
<div class="equation">
<pre>\dfrac {\partial \rho} {\partial t}=-\left( \overrightarrow {u} \cdot \nabla \right) \rho + \kappa \nabla ^{2} \rho + S
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of the above, </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ overrightarrow {u}</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the flow velocity, </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ kappa</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the diffusion coefficient, ρ is the density, and S is the external pressure. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The density field is not always necessary, but by placing the pixels on the screen diffused by the density field on each vector when the velocity field is calculated, it becomes possible to express a more fluid-like expression that flows while melting. I will. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As some of you may have noticed by looking at the formula of the density field, the flow is exactly the same as the velocity field, the difference is that the vector is a scalar and the kinematic viscosity coefficient </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ nu</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the diffusion coefficient. </font><font style="vertical-align: inherit;">There are only three points, one that is </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ kappa</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and the other that does not use the law of conservation of mass. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the density field is a field of change in density, it does not need to be incompressible and does not need to be conserved by mass. </font><font style="vertical-align: inherit;">In addition, the kinematic viscosity coefficient and the diffusion coefficient have the same usage as coefficients. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, it is possible to implement the density field by making a kernel other than the mass conservation law of the kernel used in the velocity field earlier by lowering the dimension. </font><font style="vertical-align: inherit;">I will not explain the density field on paper, but please refer to the density field as it is also implemented in the repository.</font></font></p>

<h2><a id="h4-8"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.8　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Each item step of the simulation</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fluids can be simulated by using the above velocity field, density field, and conservation of mass law, but let's take a look at the simulation steps at the end.</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generates an external force event and inputs it to the external force term of the velocity field and density field.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Update the speed field in the following steps</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nisan viscosity term</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quality preservation</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advection term</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quality preservation</font></font></font></font></li>
</ul>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then update the density field in the following steps</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stray term</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advection density using velocity in velocity field</font></font></li>
</ul>
</li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The above is the simulation step of StableFluid.</font></font></p>

<h2><a id="h4-9"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.9　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Results</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By executing and dragging on the screen with the mouse, it is possible to cause the following fluid simulation.</font></font></p>
<div id="fluid-s" class="image">
<img src="./Chapter 4 _ Fluid Simulation by Lattice Method_files/fluid-s.png" alt="Execution example" class="width-070per">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 4.2: Execution example
</font></font></p>
</div>

<h2><a id="h4-10"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.10　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Summary</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fluid simulation, unlike pre-rendering, is a heavy field for real-time game engines like Unity. </font><font style="vertical-align: inherit;">However, due to the improvement of GPU computing power, it has become possible to produce FPS that can withstand even a certain resolution if it is two-dimensional. </font><font style="vertical-align: inherit;">Also, if you try to implement the Gauss-Seidel iterative method, which is a heavy load for the GPU that came out on the way, with another process, or substitute the speed field itself with curl noise, etc. It will be possible to express fluids with lighter calculations.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you have read this chapter and are interested in fluids even a little, please try "Fluid simulation by particle method" in the next chapter. </font><font style="vertical-align: inherit;">Since you can approach the fluid from a different angle than the grid method, you can experience the depth of fluid simulation and the fun of mounting.</font></font></p>

<h2><a id="h4-11"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.11　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reference</font></font></h2>
<ul>
<li>Jos Stam. SIGGRAPH 1999. Stable Fluids</li>
</ul><div id="goog-gt-tt" class="goog-tooltip skiptranslate" dir="ltr" style="visibility: hidden; left: 380px; top: 33.125px; display: none;"><div style="padding: 8px;"><div><div class="logo"><img src="./Chapter 4 _ Fluid Simulation by Lattice Method_files/translate_24dp.png" width="20" height="20" alt="Google Translate"></div></div></div><div class="top" style="padding: 8px; float: left; width: 100%;"><h1 class="title gray">Original text</h1></div><div class="middle" style="padding: 8px;"><div class="original-text">第4章　格子法による流体シミュレーション</div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">Contribute a better translation</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none; opacity: 0;"></div></div>


<div class="goog-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div><iframe frameborder="0" class="goog-te-menu-frame skiptranslate" title="Language Translate Widget" style="visibility: visible; box-sizing: content-box; width: 1001px; height: 263px; display: none;" src="./Chapter 4 _ Fluid Simulation by Lattice Method_files/saved_resource(1).html"></iframe><div id="goog-gt-tt" class="skiptranslate" dir="ltr"><div style="padding: 8px;"><div><div class="logo"><img src="https://www.gstatic.com/images/branding/product/1x/translate_24dp.png" width="20" height="20" alt="Google Translate"></div></div></div><div class="top" style="padding: 8px; float: left; width: 100%;"><h1 class="title gray">Original text</h1></div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">Contribute a better translation</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div><iframe frameborder="0" class="goog-te-menu-frame skiptranslate" title="Language Translate Widget" style="visibility: visible; box-sizing: content-box; width: 197px; height: 69px; display: none;" src="./Chapter 4 _ Fluid Simulation by Lattice Method_files/saved_resource(2).html"></iframe><div id="goog-gt-tt" class="skiptranslate" dir="ltr"><div style="padding: 8px;"><div><div class="logo"><img src="https://www.gstatic.com/images/branding/product/1x/translate_24dp.png" width="20" height="20" alt="Google Translate"></div></div></div><div class="top" style="padding: 8px; float: left; width: 100%;"><h1 class="title gray">Original text</h1></div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">Contribute a better translation</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div><div class="goog-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div><div id="goog-gt-tt" class="skiptranslate" dir="ltr"><div style="padding: 8px;"><div><div class="logo"><img src="https://www.gstatic.com/images/branding/product/1x/translate_24dp.png" width="20" height="20" alt="Google Translate"></div></div></div><div class="top" style="padding: 8px; float: left; width: 100%;"><h1 class="title gray">Original text</h1></div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">Contribute a better translation</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div><div class="goog-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div><div class="goog-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div><iframe frameborder="0" class="goog-te-menu-frame skiptranslate" title="Language Translate Widget" style="visibility: visible; box-sizing: content-box; width: 1001px; height: 263px; display: none;"></iframe><iframe frameborder="0" class="goog-te-menu-frame skiptranslate" title="Language Translate Widget" style="visibility: visible; box-sizing: content-box; width: 197px; height: 69px; display: none;"></iframe><iframe frameborder="0" class="goog-te-menu-frame skiptranslate" title="Language Translate Widget" style="visibility: visible; box-sizing: content-box; width: 1001px; height: 263px; display: none;"></iframe><iframe frameborder="0" class="goog-te-menu-frame skiptranslate" title="Language Translate Widget" style="visibility: visible; box-sizing: content-box; width: 197px; height: 69px; display: none;"></iframe></body></html>