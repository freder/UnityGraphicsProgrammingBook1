<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="en" style="height: 100%;" class="translated-ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <link rel="stylesheet" type="text/css" href="./Chapter 7 _ Introduction to the Marching Cubes Method Starting with Atmosphere_files/style.scss">
  <meta name="generator" content="Re:VIEW">
  <title>Introduction to the Marching Cubes method starting with an atmosphere</title>

			<style>
				img {
					max-width: 80vw;
					max-height: 80vh;
				}
			</style><style>
					.goog-te-banner-frame {
						display: none;
					}
				</style>
			<script>(function(){(function injection() {
  var pageLang = 'ja';
  var userLang = 'en';

  var uid = '1E07F158C6FA4460B352973E9693B329';
  var teId = 'TE_' + uid;
  var cbId = 'TECB_' + uid;

  function show() {
    window.setTimeout(function() {
      window[teId].showBanner(true);
    }, 10);
  }

  function newElem() {
    
  }

  if (window[teId]) {
    show();
  } else {
    if (!window.google || !google.translate ||
        !google.translate.TranslateElement) {
      if (!window[cbId]) {
        window[cbId] = function() {
          window[teId] = newElem();
          show();
        };
      }
      
    }
  }
})();})();</script><script src="https://translate.google.com/translate_a/element.js?cb=TECB_1E07F158C6FA4460B352973E9693B329&amp;client=tee&amp;hl=en"></script><script src="./Chapter 7 _ Introduction to the Marching Cubes Method Starting with Atmosphere_files/f.txt"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://translate.googleapis.com/translate_static/css/translateelement.css"><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/translate_static/js/element/main.js"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="./Chapter 7 _ Introduction to the Marching Cubes Method Starting with Atmosphere_files/translateelement.css"><script type="text/javascript" charset="UTF-8" src="./Chapter 7 _ Introduction to the Marching Cubes Method Starting with Atmosphere_files/main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script><script type="text/javascript" charset="UTF-8" src="./Chapter 7 _ Introduction to the Marching Cubes Method Starting with Atmosphere_files/element_main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://translate.googleapis.com/translate_static/css/translateelement.css"><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/translate_static/js/element/main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script></head>
		
<body style="position: relative; min-height: 100%; top: 40px;"><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div>
<h1><a id="h7"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chapter 7　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Introduction to the Marching Cubes Method Starting with Atmosphere</font></font></h1>

<h2><a id="h7-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1 What is the　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Marching Cubes method?</font></font></h2>

<h3><a id="h7-1-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> History and overview</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Marching Cubes method is one of the volume rendering methods, and is an algorithm that converts 3D voxel data filled with scalar data into polygon data. </font><font style="vertical-align: inherit;">The first paper was published in 1987 by William E. Lorensen and Harvey E. Cline.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Marching Cubes method was patented, but since it expired in 2005, it is now free to use.</font></font></p>

<h3><a id="h7-1-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Explanation of simple mechanism</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, divide the volume data space with a 3D grid.</font></font></p>
<div id="id_marching__cubes__001_404x" class="image">
<img src="./Chapter 7 _ Introduction to the Marching Cubes Method Starting with Atmosphere_files/marching_cubes_001@4x.png" alt="3D volume data and grid division">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 7.1: 3D volume data and grid partitioning
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, let's take out one of the divided grids. </font><font style="vertical-align: inherit;">The boundaries of the eight vertices are calculated as 1 if the values ​​of the eight corners of the grid are above the threshold and 0 if they are below the threshold. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The figure below shows the flow when the threshold is set to 0.5.</font></font></p>
<div id="id_marching__cubes__002_404x" class="image">
<img src="./Chapter 7 _ Introduction to the Marching Cubes Method Starting with Atmosphere_files/marching_cubes_002@4x.png" alt="Determining the boundary according to the value of the angle">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 7.2: Determining the boundary according to the value of the angle
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are 256 types of combinations of the eight corners, but if you make full use of rotation and inversion, it will fit in 15 types. </font><font style="vertical-align: inherit;">Assign triangular polygon patterns corresponding to the 15 types of combinations.</font></font></p>
<div id="id_marching__cubes__003_404x" class="image">
<img src="./Chapter 7 _ Introduction to the Marching Cubes Method Starting with Atmosphere_files/marching_cubes_003@4x.png" alt="Combination of horns">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 7.3: Combination of corners
</font></font></p>
</div>

<h2><a id="h7-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sample repository</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The sample projects described in this chapter can be found in Assets / GPU ArchingCubes under Unity Graphics Programming's Unity Project https://github.com/IndieVisualLab/UnityGraphicsProgramming.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For implementation, </font><font style="vertical-align: inherit;">I ported it to Unity by referring to </font><font style="vertical-align: inherit;">Paul Bourke's Polygonising a scalar field site </font></font><a id="fnb-paul" href="https://freder.github.io/UnityGraphicsProgrammingBook1/articles/MarchingCubes.html#fn-paul" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p>
<div class="footnote" epub:type="footnote" id="fn-paul"><p class="footnote">[*1] Polygonising a scalar field http://paulbourke.net/geometry/polygonise/</p></div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This time, I will explain along with this sample project.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are three main implementations.</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialization of mesh, drawing registration process for each frame (C # script part)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialization of Compute Buffer</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actual drawing process (shader part)</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, </font><font style="vertical-align: inherit;">create from </font><font style="vertical-align: inherit;">the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU ArchingCubesDrawMesh</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class </font><font style="vertical-align: inherit;">that initializes the mesh and registers the drawing </font><font style="vertical-align: inherit;">.</font></font></p>

<h3><a id="h7-2-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2.1</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Make a mesh for Geometry </font><span class="secno"><font style="vertical-align: inherit;">Shader　</font></span></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As explained in the previous section, the Marching cubes method is an algorithm that generates polygons by combining the eight corners of the grid. </font><font style="vertical-align: inherit;">To do that in real time, you need to dynamically create polygons. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, it is inefficient to generate a mesh vertex array on the CPU side (C # side) every frame. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So we use Geometry Shader. </font><font style="vertical-align: inherit;">GeometryShader is a Shader located between VertexShader and FragmentShader, which can increase or decrease the number of vertices processed by VertexShader. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, you can add 6 vertices around one vertex to generate a plate polygon. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Furthermore, it is very fast because it is processed on the Shader side (GPU side). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This time, I will use Geometry Shader to generate and display Marching Cubes polygons.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, </font><font style="vertical-align: inherit;">define the variables used </font><font style="vertical-align: inherit;">in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUMarchingCubesDrawMesh</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class.</font></font></p>
<div id="kaiware_define_cs" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 7.1: Definition of variables</font></font></p>
<pre class="list language-cs">using UnityEngine;<font></font>
<font></font>
public class GPUMarchingCubesDrawMesh : MonoBehaviour {<font></font>
<font></font>
    #region public<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public int segmentNum = 32; // Number of divisions on one side of the grid</font></font><font></font>
<font></font>
    [Range(0,1)]<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public float threashold = 0.5f; // Threshold for the scalar value to mesh</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public Material mat; // Material for rendering</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public Color DiffuseColor = Color.green; // Diffuse color</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public Color EmissionColor = Color.black; // Emission color</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public float EmissionIntensity = 0; // Emission intensity</font></font><font></font>
<font></font>
    [Range(0,1)]<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public float metallic = 0; // metallic feeling</font></font><font></font>
    [Range(0, 1)]<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public float glossiness = 0.5f; // Glossiness</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    #endregion</font></font><font></font>
<font></font>
     #region private<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    int vertexMax = 0; // number of vertices</font></font><font></font>
    Mesh[] meshs = null;                        // Mesh配列<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    Material [] materials = null; // Material array for each mesh</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    float renderScale = 1f / 32f; // Display scale</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    MarchingCubesDefines mcDefines = null; // Constant array group for MarchingCubes</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    #endregion</font></font><font></font>
<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, create a mesh to pass to the Geometry Shader. </font><font style="vertical-align: inherit;">The vertices of the mesh should be placed one by one in the divided 3D grid. </font><font style="vertical-align: inherit;">For example, if the number of divisions on one side is 64, 64 * 64 * 64 = 262,144 vertices are required.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, in Unity2017.1.1f1, the maximum number of vertices in one mesh is 65,535. </font><font style="vertical-align: inherit;">Therefore, each mesh is divided so that the number of vertices is within 65,535.</font></font></p>
<div id="kaiware_create_mesh_cs" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 7.2: Meshing part</font></font></p>
<pre class="list language-cs">void Initialize()<font></font>
{<font></font>
  vertexMax = segmentNum * segmentNum * segmentNum;<font></font>
<font></font>
  Debug.Log("VertexMax " + vertexMax);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Divide the size of 1Cube by segmentNum to determine the size at the time of rendering</font></font><font></font>
  renderScale = 1f / segmentNum;<font></font>
<font></font>
  CreateMesh();<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Initialize constant array for Marching Cubes used in shader</font></font><font></font>
  mcDefines = new MarchingCubesDefines();<font></font>
}<font></font>
<font></font>
void CreateMesh()<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Since the maximum number of vertices of Mesh is 65535, divide Mesh</font></font><font></font>
  int vertNum = 65535;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  int meshNum = Mathf.CeilToInt ((float) vertexMax / vertNum); // Number of meshes to split</font></font><font></font>
  Debug.Log("meshNum " + meshNum );<font></font>
<font></font>
  meshs = new Mesh[meshNum];<font></font>
  materials = new Material[meshNum];<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Mesh bounce calculation</font></font><font></font>
  Bounds bounds = new Bounds(<font></font>
    transform.position,<font></font>
    new Vector3(segmentNum, segmentNum, segmentNum) * renderScale<font></font>
  );<font></font>
<font></font>
  int id = 0;<font></font>
  for (int i = 0; i &lt; meshNum; i++)<font></font>
  {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Vertex creation</font></font><font></font>
    Vector3[] vertices = new Vector3[vertNum];<font></font>
    int[] indices = new int[vertNum];<font></font>
    for(int j = 0; j &lt; vertNum; j++)<font></font>
    {<font></font>
      vertices[j].x = id % segmentNum;<font></font>
      vertices[j].y = (id / segmentNum) % segmentNum;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      vertices [j] .z = (id / (segmentNum * segmentNum))% segmentNum;</font></font><font></font>
<font></font>
      indices[j] = j;<font></font>
      id++;<font></font>
    }<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Mesh creation</font></font><font></font>
    meshs[i] = new Mesh();<font></font>
    meshs[i].vertices = vertices;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Mesh Topology can be Points because polygons are created with Geometry Shader</font></font><font></font>
    meshs[i].SetIndices(indices, MeshTopology.Points, 0);<font></font>
    meshs[i].bounds = bounds;<font></font>
<font></font>
    materials[i] = new Material(mat);<font></font>
  }<font></font>
}<font></font>
</pre>
</div>

<h3><a id="h7-2-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Initialization of Compute Buffer</font></font></h3>
<p><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The source </font><b><font style="vertical-align: inherit;">MarchingCubesDefinces.cs</font></b><font style="vertical-align: inherit;"> defines a constant array used for rendering the Marching Cubes method and a ComputeBuffer for passing the constant array to the shader. </font><font style="vertical-align: inherit;">ComputeBuffer is a buffer that stores data used by shaders. </font><font style="vertical-align: inherit;">Since the data is stored in the memory on the GPU side, it is quickly accessible from the shader.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, the constant array used in the rendering of the Marching Cubes method can be defined on the shader side. </font><font style="vertical-align: inherit;">However, the reason why the constant array used in the shader is initialized on the C # side is that the shader has a limitation that the number of literal values ​​(directly written values) can only be registered up to 4096. </font><font style="vertical-align: inherit;">If you define a huge array of constants in your shader, you will quickly reach the upper limit of the number of literal values.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, by storing it in ComputeShader and passing it, it will not be a literal value, so it will not hit the upper limit. </font><font style="vertical-align: inherit;">Therefore, the number of processes increases a little, but on the C # side, the constant array is stored in ComputeBuffer and passed to the shader.</font></font></p>
<div id="kaiware_computebuffer_init" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 7.3: ComputeBuffer initialization part</font></font></p>
<pre class="list language-cs">void Initialize()<font></font>
{<font></font>
  vertexMax = segmentNum * segmentNum * segmentNum;<font></font>
<font></font>
  Debug.Log("VertexMax " + vertexMax);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Divide the size of 1Cube by segmentNum to determine the size at the time of rendering</font></font><font></font>
  renderScale = 1f / segmentNum;<font></font>
<font></font>
  CreateMesh();<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Initialize constant array for Marching Cubes used in shader</font></font><font></font>
  mcDefines = new MarchingCubesDefines();<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the Initialize () function mentioned earlier, MarchingCubesDefines is initialized.</font></font></p>

<h3><a id="h7-2-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rendering</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next is the function that calls the rendering process. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This time, I'll use Graphics.DrawMesh () to render multiple meshes at once and to be affected by Unity's lighting. </font><font style="vertical-align: inherit;">The meaning of DiffuseColor etc. defined in the public variable will be explained in the explanation on the shader side.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ComputeBuffers of the MarchingCubesDefines class in the previous section are passed to the shader with material.setBuffer.</font></font></p>
<div id="kaiware_rendermesh" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 7.4: Rendered part</font></font></p>
<pre class="list language-cs">void RenderMesh()<font></font>
{<font></font>
  Vector3 halfSize = new Vector3(segmentNum, segmentNum, segmentNum)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                     * renderScale * 0.5f;</font></font></font></font><font></font>
  Matrix4x4 trs = Matrix4x4.TRS(<font></font>
                     transform.position,<font></font>
                     transform.rotation,<font></font>
                     transform.localScale<font></font>
                  );<font></font>
<font></font>
  for (int i = 0; i &lt; meshs.Length; i++)<font></font>
  {<font></font>
    materials[i].SetPass(0);<font></font>
    materials[i].SetInt("_SegmentNum", segmentNum);<font></font>
    materials[i].SetFloat("_Scale", renderScale);<font></font>
    materials[i].SetFloat("_Threashold", threashold);<font></font>
    materials[i].SetFloat("_Metallic", metallic);<font></font>
    materials[i].SetFloat("_Glossiness", glossiness);<font></font>
    materials[i].SetFloat("_EmissionIntensity", EmissionIntensity);<font></font>
<font></font>
    materials[i].SetVector("_HalfSize", halfSize);<font></font>
    materials[i].SetColor("_DiffuseColor", DiffuseColor);<font></font>
    materials[i].SetColor("_EmissionColor", EmissionColor);<font></font>
    materials[i].SetMatrix("_Matrix", trs);<font></font>
<font></font>
    Graphics.DrawMesh(meshs[i], Matrix4x4.identity, materials[i], 0);<font></font>
  }<font></font>
}<font></font>
</pre>
</div>

<h2><a id="h7-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Call</font></font></h2>
<div id="kaiware_update" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 7.5: Calling Part</font></font></p>
<pre class="list language-cs">// Use this for initialization<font></font>
void Start ()<font></font>
{<font></font>
  Initialize();<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
<font></font>
void Update()<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  RenderMesh ();</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start () calls Initialize () to generate a mesh, and the Update () function calls RenderMesh () to render. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The reason for calling RenderMesh () with Update () is that Graphics.DrawMesh () does not draw immediately, but it feels like "registering for rendering process once". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By registering, Unity will adapt the lights and shadows. </font><font style="vertical-align: inherit;">A similar function is Graphics.DrawMeshNow (), but it draws instantly, so Unity lights and shadows are not applied. </font><font style="vertical-align: inherit;">Also, you need to call it with OnRenderObject () or OnPostRender () instead of Update ().</font></font></p>

<h2><a id="h7-4"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.4　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader side implementation</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The shader this time is roughly divided into </font><font style="vertical-align: inherit;">two </font><b><font style="vertical-align: inherit;">parts, the " </font></b></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rendering part of the entity"</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"rendering part of the shadow"</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In addition, three shader functions are executed within each, the vertex shader, the geometry shader, and the fragment shader.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the shader source is long, I will have the sample project look at the entire implementation, and I will explain only the important points. </font><font style="vertical-align: inherit;">The shader file described is GPU ArchingCubesRenderMesh.shader.</font></font></p>

<h3><a id="h7-4-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.4.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Variable declaration</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the top of the shader, we define the structure used for rendering.</font></font></p>
<div id="kaiware_shader_struct_define" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 7.6: Structure Definition Part</font></font></p>
<pre class="list language-cs"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Vertex data coming from the mesh</font></font><font></font>
struct appdata<font></font>
{<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  float4 vertex: POSITION; // vertex coordinates</font></font><font></font>
};<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Data passed from the vertex shader to the geometry shader</font></font><font></font>
struct v2g<font></font>
{<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  float4 pos: SV_POSITION; // Vertex coordinates</font></font><font></font>
};<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Data passed from the geometry shader to the fragment shader when rendering the entity</font></font><font></font>
struct g2f_light<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  float4 pos: SV_POSITION; // Local coordinates</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  float3 normal: NORMAL; </font><font style="vertical-align: inherit;">// normal</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  float4 worldPos: TEXCOORD0; // World coordinates</font></font><font></font>
  half3 sh        : TEXCOORD3;    // SH<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
};</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Data passed from the geometry shader to the fragment shader when rendering shadows</font></font><font></font>
struct g2f_shadow<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  float4 pos: SV_POSITION; // coordinate</font></font><font></font>
  float4 hpos     : TEXCOORD1;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
};</font></font></font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, we are defining variables.</font></font><br></p>
<div id="kaiware_shader_arguments_define" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 7.7: Variable definition part</font></font></p>
<pre class="list language-cs">int _SegmentNum;<font></font>
<font></font>
float _Scale;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
float _Threashold;</font></font></font></font><font></font>
<font></font>
float4 _DiffuseColor;<font></font>
float3 _HalfSize;<font></font>
float4x4 _Matrix;<font></font>
<font></font>
float _EmissionIntensity;<font></font>
half3 _EmissionColor;<font></font>
<font></font>
half _Glossiness;<font></font>
half _Metallic;<font></font>
<font></font>
StructuredBuffer&lt;float3&gt; vertexOffset;<font></font>
StructuredBuffer&lt;int&gt; cubeEdgeFlags;<font></font>
StructuredBuffer&lt;int2&gt; edgeConnection;<font></font>
StructuredBuffer&lt;float3&gt; edgeDirection;<font></font>
StructuredBuffer&lt;int&gt; triangleConnectionTable;<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The contents of various variables defined here are passed by the material.Set ○○ function in the RenderMesh () function on the C # side. </font><font style="vertical-align: inherit;">ComputeBuffers in the MarchingCubesDefines class have changed their type names to StructuredBuffer &lt;○○&gt;.</font></font></p>

<h3><a id="h7-4-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.4.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vertex shader</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The vertex shader is very simple, as most of the work is done by the geometry shader. </font><font style="vertical-align: inherit;">It simply passes the vertex data passed from the mesh to the geometry shader as is.</font></font></p>
<div id="kaiware_shader_vertex" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 7.8: Vertex shader implementation</font></font></p>
<pre class="list language-cs"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Vertex data coming from the mesh</font></font><font></font>
struct appdata<font></font>
{<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  float4 vertex: POSITION; // vertex coordinates</font></font><font></font>
};<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Data passed from the vertex shader to the geometry shader</font></font><font></font>
struct v2g<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  float4 pos: SV_POSITION; // coordinate</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
};</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Vertex shader</font></font><font></font>
v2g vert(appdata v)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  v2g or = (v2g) 0;</font></font><font></font>
  o.pos = v.vertex;<font></font>
  return o;<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way, the vertex shader is common to the entity and the shadow.</font></font></p>

<h3><a id="h7-4-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.4.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entity Geometry Shader</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since it is long, I will explain it while dividing it.</font></font></p>
<div id="kaiware_shader_geometry_1" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 7.9: Function declaration part of the geometry shader</font></font></p>
<pre class="list language-cs"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Entity geometry shader</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[maxvertexcount (15)] // Definition of the maximum number of vertices output from the shader</font></font><font></font>
void geom_light(point v2g input[1],<font></font>
                inout TriangleStream&lt;g2f_light&gt; outStream)<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First is the declaration part of the geometry shader.</font></font></p>
<p><code class="inline-code tt">[maxvertexcount(15)]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is the definition of the maximum number of vertices output from the shader. </font><font style="vertical-align: inherit;">With the algorithm of the Marching Cubes method this time, a maximum of 5 triangular polygons can be created per grid, so a total of 15 vertices are output in 3 * 5. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, write 15 in () of maxvertexcount.</font></font></p>
<div id="kaiware_shader_geometry_2" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 7.10: Scalar value acquisition part of the eight corners of the grid</font></font></p>
<pre class="list language-cs"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">float cubeValue [8]; // Array for getting scalar values ​​at the eight corners of the grid</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Get the scalar values ​​for the eight corners of the grid</font></font><font></font>
for (i = 0; i &lt; 8; i++) {<font></font>
  cubeValue[i] = Sample(<font></font>
                  pos.x + vertexOffset[i].x,<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                  pos.y + vertexOffset [i] .y,</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                  pos.z + vertexOffset [i] .z</font></font><font></font>
  );<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pos contains the coordinates of the vertices placed in the grid space when creating the mesh. </font><font style="vertical-align: inherit;">As the name implies, vertexOffset is an array of offset coordinates added to pos.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This loop gets the scalar values ​​in the volume data of the coordinates of the eight corners of one vertex = one grid. </font><font style="vertical-align: inherit;">vertexOffset points to the order of the corners of the grid.</font></font></p>
<div id="id_marching__cubes__005_404x" class="image">
<img src="./Chapter 7 _ Introduction to the Marching Cubes Method Starting with Atmosphere_files/marching_cubes_005@4x.png" alt="Order of coordinates of grid corners">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 7.4: Order of grid corner coordinates
</font></font></p>
</div>
<div id="kaiware_shader_sampling" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 7.11: Sampling function part</font></font></p>
<pre class="list language-cs"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// sampling function</font></font><font></font>
float Sample(float x, float y, float z) {<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Are the coordinates out of the grid space?</font></font><font></font>
  if ((x &lt;= 1) ||<font></font>
      (y &lt;= 1) ||<font></font>
      (z &lt;= 1) ||<font></font>
      (x &gt;= (_SegmentNum - 1)) ||<font></font>
      (y &gt;= (_SegmentNum - 1)) ||<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      (z&gt; = (_SegmentNum - 1))</font></font><font></font>
     )<font></font>
    return 0;<font></font>
<font></font>
  float3 size = float3(_SegmentNum, _SegmentNum, _SegmentNum);<font></font>
<font></font>
  float3 pos = float3(x, y, z) / size;<font></font>
<font></font>
  float3 spPos;<font></font>
  float result = 0;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Distance function of 3 spheres</font></font><font></font>
  for (int i = 0; i &lt; 3; i++) {<font></font>
    float sp = -sphere(<font></font>
      pos - float3(0.5, 0.25 + 0.25 * i, 0.5),<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      0.1 + (sin (_Time.y * 8.0 + i * 23.365) * 0.5 + 0.5) * 0.025) + 0.5;</font></font><font></font>
    result = smoothMax(result, sp, 14);<font></font>
  }<font></font>
<font></font>
  return result;<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This function fetches the scalar value of the specified coordinates from the volume data. </font><font style="vertical-align: inherit;">This time, instead of using a huge amount of 3D volume data, we will calculate the scalar value using a simple algorithm that uses a distance function.</font></font></p>
<div class="column">

<h4><a id="column-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">About the distance function</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The 3D shape drawn by the Marching Cubes method this time is </font><font style="vertical-align: inherit;">defined using what is called </font><font style="vertical-align: inherit;">a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"distance function"</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The distance function here is, roughly speaking, a "function that satisfies the distance condition".</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, the distance function of a sphere is:</font></font></p>
<div id="kaiware_distance_function" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 7.12: Sphere Distance Function</font></font></p>
<pre class="list language-cs">inline float sphere(float3 pos, float radius)<font></font>
{<font></font>
    return length(pos) - radius;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coordinates are entered in pos, but consider the case where the center coordinates of the sphere are the origin (0,0,0). </font><font style="vertical-align: inherit;">radius is the radius.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The length is calculated by length (pos), but this is the distance between the origin and pos, and it is subtracted by the radius radius, so if the length is less than the radius, it is a natural but negative value.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In other words, if you pass the coordinates pos and a negative value is returned, you can judge that the coordinates are inside the sphere.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The advantage of the distance function is that it is easy to make the program small because the figure can be expressed with a simple calculation formula of several lines. </font><font style="vertical-align: inherit;">You can find a lot of information about other distance functions on Inigo Quilez's site.</font></font></p>
<p><a href="http://iquilezles.org/www/articles/distfunctions/distfunctions.htm" class="link">http://iquilezles.org/www/articles/distfunctions/distfunctions.htm</a></p>
</div>
<div id="kaiware_sphere" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 7.13: A composite of the distance functions of three spheres</font></font></p>
<pre class="list language-cs"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Distance function of 3 spheres</font></font><font></font>
for (int i = 0; i &lt; 3; i++) {<font></font>
  float sp = -sphere(<font></font>
    pos - float3(0.5, 0.25 + 0.25 * i, 0.5),<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    0.1 + (sin (_Time.y * 8.0 + i * 23.365) * 0.5 + 0.5) * 0.025) + 0.5;</font></font><font></font>
  result = smoothMax(result, sp, 14);<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This time, 8 corners (vertices) of 1 square of the grid are used as pos. </font><font style="vertical-align: inherit;">The distance from the center of the sphere is treated as it is as the density of the volume data.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As will be described later, the sign is inverted because it is polygonized when the threshold value is 0.5 or more. </font><font style="vertical-align: inherit;">In addition, the coordinates are slightly shifted to obtain the distances to the three spheres.</font></font></p>
<div id="kaiware_shader_smoothmax" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 7.14: smoothMax function</font></font></p>
<pre class="list language-cs">float smoothMax(float d1, float d2, float k)<font></font>
{<font></font>
  float h = exp(k * d1) + exp(k * d2);<font></font>
  return log(h) / k;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">smoothMax is a function that blends the results of distance functions nicely. </font><font style="vertical-align: inherit;">You can use this to fuse the three spheres like a metaball.</font></font></p>
<div id="kaiware_shader_flagindex" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 7.15: Threshold Check</font></font></p>
<pre class="list language-cs"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Check if the values ​​at the eight corners of the grid exceed the threshold</font></font><font></font>
for (i = 0; i &lt; 8; i++) {<font></font>
  if (cubeValue[i] &lt;= _Threashold) {<font></font>
    flagIndex |= (1 &lt;&lt; i);<font></font>
  }<font></font>
}<font></font>
<font></font>
int edgeFlags = cubeEdgeFlags[flagIndex];<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Do not draw anything if empty or completely filled</font></font><font></font>
if ((edgeFlags == 0) || (edgeFlags == 255)) {<font></font>
  return;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the scalar value at the corner of the grid exceeds the threshold, set a bit in flagIndex. </font><font style="vertical-align: inherit;">Using the flagIndex as an index, the information for generating polygons is extracted from the cubeEdgeFlags array and stored in edgeFlags. </font><font style="vertical-align: inherit;">If all corners of the grid are below or above the threshold, it is completely inside or outside and no polygons are generated.</font></font></p>
<div id="kaiware_shader_offset" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 7.16: Polygon Vertex Coordinate Calculation</font></font></p>
<pre class="list language-cs">float offset = 0.5;<font></font>
float3 vertex;<font></font>
for (i = 0; i &lt; 12; i++) {<font></font>
  if ((edgeFlags &amp; (1 &lt;&lt; i)) != 0) {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Get the threshold offset between the corners</font></font><font></font>
    offset = getOffset(<font></font>
               cubeValue[edgeConnection[i].x],<font></font>
               cubeValue[edgeConnection[i].y], _<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
               Threashold</font></font></font></font><font></font>
             );<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Complement the coordinates of the vertices based on the offset</font></font><font></font>
    vertex = vertexOffset[edgeConnection[i].x]<font></font>
             + offset * edgeDirection[i];<font></font>
<font></font>
    edgeVertices[i].x = pos.x + vertex.x * _Scale;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    edgeVertices [i] .y = pos.y + vertex.y * _Scale;</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    edgeVertices [i] .z = pos.z + vertex.z * _Scale;</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Normal calculation (requires vertex coordinates before scaling to resample)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    edgeNormals [i] = getNormal (</font></font></font></font><font></font>
                        defpos.x + vertex.x,<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                        defpos.y + vertex.y,</font></font></font></font><font></font>
                        defpos.z + vertex.z<font></font>
                     );<font></font>
  }<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is where the vertex coordinates of the polygon are calculated. </font><font style="vertical-align: inherit;">Looking at the bit of edgeFlags earlier, we are calculating the vertex coordinates of the polygon to be placed on the edge of the grid.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getOffset gives the ratio (offset) from the current corner to the next corner from the scalar values ​​and thresholds of the two corners of the grid. </font><font style="vertical-align: inherit;">By offsetting the coordinates of the current corner toward the next corner by offset, the polygon will eventually become smooth.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In getNormal, the normal is calculated by re-sampling and calculating the gradient.</font></font></p>
<div id="kaiware_shader_make_polygon" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 7.17: Concatenate vertices to make a polygon</font></font></p>
<pre class="list language-cs"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Concatenate vertices to create polygons</font></font><font></font>
int vindex = 0;<font></font>
int findex = 0;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Create up to 5 triangles</font></font><font></font>
for (i = 0; i &lt; 5; i++) {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  findx = flagIndex * 16 + 3 * i;</font></font><font></font>
  if (triangleConnectionTable[findex] &lt; 0)<font></font>
    break;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // make a triangle</font></font><font></font>
  for (j = 0; j &lt; 3; j++) {<font></font>
    vindex = triangleConnectionTable[findex + j];<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Multiply the Transform matrix to convert to world coordinates</font></font><font></font>
    float4 ppos = mul(_Matrix, float4(edgeVertices[vindex], 1));<font></font>
    o.pos = UnityObjectToClipPos(ppos);<font></font>
<font></font>
    float3 norm = UnityObjectToWorldNormal(<font></font>
                    normalize(edgeNormals[vindex])<font></font>
                  );<font></font>
    o.normal = normalize(mul(_Matrix, float4(norm,0)));<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    outStream.Append (o); // Append vertices to strip</font></font><font></font>
  }<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  outStream.RestartStrip (); // Break once and start the next primitive strip</font></font><font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the place where the polygon is made by connecting the vertex coordinate groups obtained earlier. </font><font style="vertical-align: inherit;">triangleConnectionTable Contains the indexes of the vertices that connect to the array. </font><font style="vertical-align: inherit;">Multiply the vertex coordinates by the Transform matrix to convert to world coordinates, and then use UnityObjectToClipPos () to convert to screen coordinates.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, UnityObjectToWorldNormal () converts the normals to the world coordinate system. </font><font style="vertical-align: inherit;">These vertices and normals will be used for lighting in the next fragment shader.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TriangleStream.Append () and RestartStrip () are special functions for geometry shaders. </font><font style="vertical-align: inherit;">Append () adds vertex data to the current strip. </font><font style="vertical-align: inherit;">RestartStrip () creates a new strip. </font><font style="vertical-align: inherit;">Since it is a Triangle Stream, it is an image to append up to 3 on one strip.</font></font></p>

<h3><a id="h7-4-4"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.4.4　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entity Fragment Shader</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to reflect the lighting such as GI (Global Illumination) of Unity, the lighting processing part of Surface Shader after Generate code is ported.</font></font></p>
<div id="kaiware_shader_fragment_define" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 7.18: Fragment Shader Definition</font></font></p>
<pre class="list language-cs"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Entity fragment shader</font></font><font></font>
void frag_light(g2f_light IN,<font></font>
  out half4 outDiffuse        : SV_Target0,<font></font>
  out half4 outSpecSmoothness : SV_Target1,<font></font>
  out half4 outNormal         : SV_Target2,<font></font>
  out half4 outEmission       : SV_Target3)<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are 4 outputs (SV_Target) to output to G-Buffer.</font></font></p>
<div id="kaiware_shader_surface" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 7.19: Initializing the SurfaceOutputStandard structure</font></font></p>
<pre class="list language-cs">#ifdef UNITY_COMPILER_HLSL<font></font>
  SurfaceOutputStandard o = (SurfaceOutputStandard)0;<font></font>
#else<font></font>
  SurfaceOutputStandard o;<font></font>
#endif<font></font>
  o.Albedo = _DiffuseColor.rgb;<font></font>
  o.Emission = _EmissionColor * _EmissionIntensity;<font></font>
  o.Metallic = _Metallic;<font></font>
  o.Smoothness = _Glossiness;<font></font>
  o.Alpha = 1.0;<font></font>
  o.Occlusion = 1.0;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  o.Normal = normal;</font></font></font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Set parameters such as color and gloss to the SurfaceOutputStandard structure that will be used later.</font></font></p>
<div id="kaiware_shader_light" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 7.20: GI-related processing</font></font></p>
<pre class="list language-cs">// Setup lighting environment<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UnityGI gi;</font></font></font></font><font></font>
UNITY_INITIALIZE_OUTPUT(UnityGI, gi);<font></font>
gi.indirect.diffuse = 0;<font></font>
gi.indirect.specular = 0;<font></font>
gi.light.color = 0;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
gi.light.dir = half3 (0, 1, 0);</font></font></font></font><font></font>
gi.light.ndotl = LambertTerm(o.Normal, gi.light.dir);<font></font>
<font></font>
// Call GI (lightmaps/SH/reflections) lighting function<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UnityGIInput giInput;</font></font></font></font><font></font>
UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);<font></font>
giInput.light = gi.light;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
giInput.worldPos = worldPos;</font></font></font></font><font></font>
giInput.worldViewDir = worldViewDir;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
giInput.atten = 1.0;</font></font></font></font><font></font>
<font></font>
giInput.ambient = IN.sh;<font></font>
<font></font>
giInput.probeHDR[0] = unity_SpecCube0_HDR;<font></font>
giInput.probeHDR[1] = unity_SpecCube1_HDR;<font></font>
<font></font>
#if UNITY_SPECCUBE_BLENDING || UNITY_SPECCUBE_BOX_PROJECTION<font></font>
// .w holds lerp value for blending<font></font>
giInput.boxMin[0] = unity_SpecCube0_BoxMin;<font></font>
#endif<font></font>
<font></font>
#if UNITY_SPECCUBE_BOX_PROJECTION<font></font>
giInput.boxMax[0] = unity_SpecCube0_BoxMax;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
giInput.probePosition [0] = unity_SpecCube0_ProbePosition;</font></font></font></font><font></font>
giInput.boxMax[1] = unity_SpecCube1_BoxMax;<font></font>
giInput.boxMin[1] = unity_SpecCube1_BoxMin;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
giInput.probePosition [1] = unity_SpecCube1_ProbePosition;</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
#endif</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LightingStandard_GI (o, giInput, gi);</font></font></font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GI related processing. </font><font style="vertical-align: inherit;">I put the initial value in UnityGIInput and write the result of GI calculated by LightnintStandard_GI () to UnityGI.</font></font></p>
<div id="kaiware_shader_gi" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 7.21: Calculation of light reflection</font></font></p>
<pre class="list language-cs">// call lighting function to output g-buffer<font></font>
outEmission = LightingStandard_Deferred(o, worldViewDir, gi,<font></font>
                                        outDiffuse,<font></font>
                                        outSpecSmoothness,<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                                        outNormal);</font></font></font></font><font></font>
outDiffuse.a = 1.0;<font></font>
<font></font>
#ifndef UNITY_HDR_ON<font></font>
outEmission.rgb = exp2(-outEmission.rgb);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
#endif</font></font></font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pass the calculation results to LightingStandard_Deferred () to calculate the degree of light reflection and write it to the Emission buffer. </font><font style="vertical-align: inherit;">In the case of HDR, write after sandwiching the part compressed by exp.</font></font></p>

<h3><a id="h7-4-5"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.4.5　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shadow Geometry Shader</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It's almost the same as the actual geometry shader. </font><font style="vertical-align: inherit;">I will explain only where there are differences.</font></font></p>
<div id="kaiware_shader_geometry_shadow" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 7.22: Shadow Geometry Shader</font></font></p>
<pre class="list language-cs">int vindex = 0;<font></font>
int findex = 0;<font></font>
for (i = 0; i &lt; 5; i++) {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  findx = flagIndex * 16 + 3 * i;</font></font></font></font><font></font>
  if (triangleConnectionTable[findex] &lt; 0)<font></font>
    break;<font></font>
<font></font>
  for (j = 0; j &lt; 3; j++) {<font></font>
    vindex = triangleConnectionTable[findex + j];<font></font>
<font></font>
    float4 ppos = mul(_Matrix, float4(edgeVertices[vindex], 1));<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    float3 norm;</font></font></font></font><font></font>
    norm = UnityObjectToWorldNormal(normalize(edgeNormals[vindex]));<font></font>
<font></font>
    float4 lpos1 = mul(unity_WorldToObject, ppos);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    o.pos = UnityClipSpaceShadowCasterPos (lpos1,</font></font></font></font><font></font>
                                            normalize(<font></font>
                                              mul(_Matrix,<font></font>
                                                float4(norm, 0)<font></font>
                                              )<font></font>
                                            )<font></font>
                                          );<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    o.pos = UnityApplyLinearShadowBias (o.pos);</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    o.hpos = o.pos;</font></font></font></font><font></font>
<font></font>
    outStream.Append(o);<font></font>
  }<font></font>
  outStream.RestartStrip();<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Convert the vertex coordinates to the coordinates of the shadow projection destination with UnityClipSpaceShadowCasterPos () and UnityApplyLinearShadowBias ().</font></font></p>

<h3><a id="h7-4-6"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.4.6　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shadow Fragment Shader</font></font></h3>
<div id="kaiware_shader_fragment_shadow" class="caption-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 7.23: Shadow Fragment Shader</font></font></p>
<pre class="list language-cs"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Shadow Fragment Shader</font></font><font></font>
fixed4 frag_shadow(g2f_shadow i) : SV_Target<font></font>
{<font></font>
  return i.hpos.z / i.hpos.w;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It's too short to explain. </font><font style="vertical-align: inherit;">Actually, the shadow is drawn normally even with return 0 ;. </font><font style="vertical-align: inherit;">Is Unity doing a good job inside?</font></font></p>

<h2><a id="h7-5"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.5　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finish</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When you run it, you should see a picture like this.</font></font></p>
<div id="marching_cubes_006" class="image">
<img src="./Chapter 7 _ Introduction to the Marching Cubes Method Starting with Atmosphere_files/marching_cubes_006.png" alt="Undulating" class="width-025per">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 7.5: undulation
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, various shapes can be created by combining distance functions.</font></font></p>
<div id="marching_cubes_007" class="image">
<img src="./Chapter 7 _ Introduction to the Marching Cubes Method Starting with Atmosphere_files/marching_cubes_007.png" alt="Kaiware daikon" class="width-025per">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 7.6: Kaiware daikon
</font></font></font></font></p>
</div>

<h2><a id="h7-6"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.6　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Summary</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This time I used the distance function for simplification, but I think that the Marching cubes method can also be used to use 3D textures with volume data written in them and to visualize various 3D data. .. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For game use, you </font><font style="vertical-align: inherit;">may be able to create games like </font><font style="vertical-align: inherit;">ASTORONEER </font></font><a id="fnb-astroneer" href="https://freder.github.io/UnityGraphicsProgrammingBook1/articles/MarchingCubes.html#fn-astroneer" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which </font><font style="vertical-align: inherit;">allows you to dig and build terrain </font><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everyone, please try to find various expressions with the Marching Cubes method!</font></font></p>

<h2><a id="h7-7"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.7　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reference</font></font></h2>
<ul>
<li>Polygonising a scalar field - http://paulbourke.net/geometry/polygonise/</li>
<li>modeling with distance functions -</li>
</ul>
<p>http://iquilezles.org/www/articles/distfunctions/distfunctions.htm</p>
<div class="footnote" epub:type="footnote" id="fn-astroneer"><p class="footnote"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[* 2] ASTRONEER http://store.steampowered.com/app/361420/ASTRONEER/?l=japanese</font></font></font></font></font></font></p></div></body></html>