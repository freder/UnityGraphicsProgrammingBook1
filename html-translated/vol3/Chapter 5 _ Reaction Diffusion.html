<!DOCTYPE html>
<!-- saved from url=(0046)https://freder.io/files/unity3/kaiware007.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="en" class="translated-ltr" style="height: 100%;"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <link rel="stylesheet" type="text/css" href="./Chapter 5 _ Reaction Diffusion_files/style.scss">
  <meta name="generator" content="Re:VIEW">
  <title>Reaction Diffusion</title>

			<style>
				img {
					max-width: 80vw;
					max-height: 80vh;
				}
			</style>
			<script>(function(){(function injection() {
  var pageLang = 'ja';
  var userLang = 'en';

  var uid = '1E07F158C6FA4460B352973E9693B329';
  var teId = 'TE_' + uid;
  var cbId = 'TECB_' + uid;

  function show() {
    window.setTimeout(function() {
      window[teId].showBanner(true);
    }, 10);
  }

  function newElem() {
    var elem = new google.translate.TranslateElement({
      autoDisplay: false,
      floatPosition: 0,
      multilanguagePage: true,
      pageLanguage: pageLang
    });
    return elem;
  }

  if (window[teId]) {
    show();
  } else {
    if (!window.google || !google.translate ||
        !google.translate.TranslateElement) {
      if (!window[cbId]) {
        window[cbId] = function() {
          window[teId] = newElem();
          show();
        };
      }
      var s = document.createElement('script');
      s.src = 'https://translate.google.com/translate_a/element.js?cb=' +
              encodeURIComponent(cbId) + '&client=tee&hl=' + userLang;
      document.getElementsByTagName('head')[0].appendChild(s);
    }
  }
})();})();</script><script src="./Chapter 5 _ Reaction Diffusion_files/f.txt"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="./Chapter 5 _ Reaction Diffusion_files/translateelement.css"><script type="text/javascript" charset="UTF-8" src="./Chapter 5 _ Reaction Diffusion_files/main.js"></script><script type="text/javascript" charset="UTF-8" src="./Chapter 5 _ Reaction Diffusion_files/element_main.js"></script></head>
		
<body style="position: relative; min-height: 100%; top: 40px;"><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:&#39;&#39;" style="visibility:visible" src="./Chapter 5 _ Reaction Diffusion_files/saved_resource.html"></iframe></div>
<h1><a id="h5"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chapter 5　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reaction Diffusion</font></font></h1>

<h2><a id="h5-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Introduction</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In nature, there are various patterns such as horizontal stripes of tropical fish and wrinkles like a maze of coral. </font><font style="vertical-align: inherit;">The genius mathematician Alan Turing expressed the occurrence of these patterns that exist in nature with mathematical formulas. </font><font style="vertical-align: inherit;">The pattern generated by the mathematical formulas he derived is called the "Turing pattern". </font><font style="vertical-align: inherit;">This equation is commonly referred to as the reaction-diffusion equation. </font><font style="vertical-align: inherit;">Based on this reaction-diffusion equation, we will develop a program to create a picture like a pattern of a living thing using Compute Shader on Unity. </font><font style="vertical-align: inherit;">At first, we will create a program that operates on a two-dimensional plane, but at the end, we will also introduce a program that operates on a three-dimensional space. </font><font style="vertical-align: inherit;">For details on ComputeShader, refer to "Chapter 2 Introduction to ComputeShader" in UnityGraphicsProgramming vol.1.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The sample in this chapter is </font><font style="vertical-align: inherit;">"Reaction Diffusion" from </font></font><br><a href="https://github.com/IndieVisualLab/UnityGraphicsProgramming3" class="link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/IndieVisualLab/UnityGraphicsProgramming3</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p>

<h2><a id="h5-2"></a><span class="secno">5.2　</span>Reaction Diffusionとは</h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As the name suggests, Reaction Diffusion is a local chemical reaction in which the concentrations of one or more substances distributed in a space change with each other, and space. It is a mathematical model of how diffusion, which spreads throughout the whole, changes due to the influence of two processes. </font><font style="vertical-align: inherit;">This time, we will use the "Gray-Scott model" as the reaction-diffusion equation. </font><font style="vertical-align: inherit;">The Gray-Scott model was published in a treatise by P. Gray and SKScott in 1983. </font><font style="vertical-align: inherit;">Roughly speaking, when two virtual substances, U and V, are filled in the grid, they react with each other to increase or decrease or diffuse, and the concentration in the space changes over time. Various patterns will appear as you go.</font></font></p>
<p><span class="imgref"><a href="https://freder.io/files/unity3/kaiware007.html#id_kaiware_2Fdescription"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 5.1</font></font></a></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a</font><span class="imgref"><a href="https://freder.io/files/unity3/kaiware007.html#id_kaiware_2Fdescription"><font style="vertical-align: inherit;"> schematic diagram</font></a></span><font style="vertical-align: inherit;"> of the “Reaction” of the Gray-Scott model.</font></font></p>
<div id="id_kaiware_2Fdescription" class="image">
<img src="./Chapter 5 _ Reaction Diffusion_files/description.png" alt="Schematic diagram of &quot;Reaction&quot; of Gray-Scott model">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 5.1: Schematic diagram of the "Reaction" of the Gray-Scott model
</font></font></p>
</div>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U is fed into the space at a constant rate</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When there are two Vs, it reacts with U to create another V.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since V will continue to increase as it is, V will be deleted (Kill) at a certain rate.</font></font></li>
</ol>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, as </font></font><span class="imgref"><a href="https://freder.io/files/unity3/kaiware007.html#id_kaiware_2Fdiffusion"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shown in Figure 5.2</font></font></a></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , U and V spread to the adjacent grid at different speeds.</font></font></p>
<div id="id_kaiware_2Fdiffusion" class="image">
<img src="./Chapter 5 _ Reaction Diffusion_files/diffusion.png" alt="Outline of &quot;Diffusion&quot; of Gray-Scott model">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 5.2: Schematic diagram of "Diffusion" in the Gray-Scott model
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This difference in diffusion rate creates a difference in U and V concentrations, creating a pattern. </font><font style="vertical-align: inherit;">The reaction and diffusion of these U and V are expressed by the following equations.</font></font></p>
<div class="equation">
<pre>\frac{\partial u}{\partial t} = Du \Delta u - uv^2 + f_{(1-u)}
</pre>
</div>
<div class="equation">
<pre>\frac{\partial v}{\partial t} = Dv \Delta v + uv^2 - (f_{}+k)
</pre>
</div>
<p>この式では、Uは<span class="equation">u</span>、Vは<span class="equation">v</span>で表しています。式は大きく３つに分かれています。 <br>最初の<span class="equation">Du \Delta u</span>と<span class="equation">Dv \Delta v</span>は拡散項といい、前半の<span class="equation">Du</span>と<span class="equation">Dv</span>は、<span class="equation">u</span>と<span class="equation">v</span>の拡散の速度の定数です。後半の<span class="equation">\Delta u</span>と<span class="equation">\Delta v</span>はラプラシアンといって、UとVの周囲との濃度差を無くす方向に拡散（Diffusion）する過程を表しています。 <br>２番目は反応項といい、<span class="equation">uv^2</span>はU１つとV２つで反応（Reaction）することで、Uが減り、Vが増えることを表しています。 <br>３番目の<span class="equation">+f_{(1-u)}</span>は流入項といい、Uが減った場合に補充（Feed）される量を表しており、０に近いほど多く補充され、１に近いほど補充されなくなります。<span class="equation">-(f_{}+k)</span>は流出項といい、増えたVを一定数減らす（Kill）ことを表しています。</p>
<p>もうちょっと簡単にまとめると、U１つとV２つで反応してUは減り、Vは増えていきます。このままではUは減り続け、Vは増え続ける一方なので、Uは<span class="equation">+f_{(1-u)}</span>の分だけ補充され、Vは<span class="equation">-(f_{}+k)</span>の分だけ強制的に減るようになっています。そして、UとVは<span class="equation">Du \Delta u</span>と<span class="equation">Dv \Delta v</span>によって周囲に拡散していきます。</p>

<h2><a id="h5-3"></a><span class="secno">5.3　</span>Unityでの実装</h2>
<p>なんとなく方程式の雰囲気がわかったところでUnityでの実装の説明に移ります。動作確認できるサンプルシーンは、<b>ReactionDiffusion2D_1</b>です。</p>

<h3><a id="h5-3-1"></a><span class="secno">5.3.1　</span>グリッド構造体の定義</h3>
<p>２次元の平面空間のグリッドの中に、UとVのそれぞれの濃度の値が入っていると仮定します。今回はComputeShaderを使って並列に処理するため、ComputeBufferでグリッドを管理します。まず、１グリッドの中の構造体を定義します。</p>
<div class="emlist-code">
<p class="caption">ReactionDiffusion2D.cs</p>
<pre class="emlist">public struct RDData<font></font>
{<font></font>
    public float u; // Uの濃度<font></font>
    public float v; // Vの濃度<font></font>
}<font></font>
</pre>
</div>

<h3><a id="h5-3-2"></a><span class="secno">5.3.2　</span>初期化</h3>
<div class="emlist-code">
<p class="caption">ReactionDiffusion2D.cs</p>
<pre class="emlist">/// &lt;summary&gt;<font></font>
/// 初期化<font></font>
/// &lt;/summary&gt;<font></font>
void Initialize()<font></font>
{<font></font>
    ...<font></font>
<font></font>
    int wh = texWidth * texHeight;  // バッファのサイズ<font></font>
    buffers = new ComputeBuffer[2]; // ダブルバッファリング用のComputeBufferの配列初期化<font></font>
<font></font>
    for (int i = 0; i &lt; buffers.Length; i++)<font></font>
    {<font></font>
        // グリッドの初期化<font></font>
        buffers[i] = new ComputeBuffer(wh, Marshal.SizeOf(typeof(RDData)));<font></font>
    }<font></font>
<font></font>
    // リセット用のグリッド配列<font></font>
    bufData = new RDData[wh];<font></font>
    bufData2 = new RDData[wh];<font></font>
<font></font>
    // バッファの初期化<font></font>
    ResetBuffer();<font></font>
<font></font>
    // Seed追加用バッファの初期化<font></font>
    inputData = new Vector2[inputMax];<font></font>
    inputIndex = 0;<font></font>
    inputBuffer = new ComputeBuffer(<font></font>
        inputMax, Marshal.SizeOf(typeof(Vector2))<font></font>
      );<font></font>
}<font></font>
</pre>
</div>
<p>更新用であるComputeBufferの<b>buffers</b>は２次元配列ですが、これは読み込み用と書き込み用に分けるために２つ用意しています。というのも、ComputeShaderはマルチスレッドで並列に処理されています。今回のように周囲のグリッドを参照して計算結果が変わる処理をする場合、１つのバッファだと、処理するスレッドの順番によって先に計算し終わったグリッドの値を参照したりして計算結果がかわってきてしまいます。それを防ぐために、読み込み用と書き込み用の２つに分けています。</p>

<h3><a id="h5-3-3"></a><span class="secno">5.3.3　</span>更新処理</h3>
<div class="emlist-code">
<p class="caption">ReactionDiffusion2D.cs</p>
<pre class="emlist">// 更新処理<font></font>
void UpdateBuffer()<font></font>
{<font></font>
    cs.SetInt("_TexWidth", texWidth);<font></font>
    cs.SetInt("_TexHeight", texHeight);<font></font>
    cs.SetFloat("_DU", du);<font></font>
    cs.SetFloat("_DV", dv);<font></font>
<font></font>
    cs.SetFloat("_Feed", feed);<font></font>
    cs.SetFloat("_K", kill);<font></font>
<font></font>
    cs.SetBuffer(kernelUpdate, "_BufferRead", buffers[0]);<font></font>
    cs.SetBuffer(kernelUpdate, "_BufferWrite", buffers[1]);<font></font>
    cs.Dispatch(kernelUpdate,<font></font>
      Mathf.CeilToInt((float)texWidth / THREAD_NUM_X),<font></font>
      Mathf.CeilToInt((float)texHeight / THREAD_NUM_X),<font></font>
      1);<font></font>
<font></font>
    SwapBuffer();<font></font>
}<font></font>
</pre>
</div>
<p>C#側のソースでは、前述の方程式にもあったパラメータをComputeShaderに渡して更新処理を行っています。次に、ComputeShader内の更新処理について説明します。</p>
<div class="emlist-code">
<p class="caption">ReactionDiffusion2D.compute</p>
<pre class="emlist">// 更新処理<font></font>
[numthreads(THREAD_NUM_X, THREAD_NUM_X, 1)]<font></font>
void Update(uint3 id : SV_DispatchThreadID)<font></font>
{<font></font>
<font></font>
  int idx = GetIndex(id.x, id.y);<font></font>
  float u = _BufferRead[idx].u;<font></font>
  float v = _BufferRead[idx].v;<font></font>
  float uvv = u * v * v;<font></font>
  float f, k;<font></font>
<font></font>
  f = _Feed;<font></font>
  k = _K;<font></font>
<font></font>
  _BufferWrite[idx].u = saturate(<font></font>
      u + (_DU * LaplaceU(id.x, id.y) - uvv + f * (1.0 - u))<font></font>
    );<font></font>
  _BufferWrite[idx].v = saturate(<font></font>
      v + (_DV * LaplaceV(id.x, id.y) + uvv - (k + f) * v)<font></font>
    );<font></font>
}<font></font>
</pre>
</div>
<p>まさに前述の方程式と同様の計算を行っています。GetIndex()は、２次元のグリッド座標と１次元のComputeBufferのインデックスを紐付けるための関数です。</p>
<div class="emlist-code">
<p class="caption">ReactionDiffusion2D.compute</p>
<pre class="emlist">// バッファのインデックス計算<font></font>
int GetIndex(int x, int y) {<font></font>
  x = (x &lt; 0) ? x + _TexWidth : x;<font></font>
  x = (x &gt;= _TexWidth) ? x - _TexWidth : x;<font></font>
<font></font>
  y = (y &lt; 0) ? y + _TexHeight : y;<font></font>
  y = (y &gt;= _TexHeight) ? y - _TexHeight : y;<font></font>
<font></font>
  return y * _TexWidth + x;<font></font>
}<font></font>
</pre>
</div>
<p>_BufferReadには１フレーム前の計算結果が入っています。そこからuとvを取り出します。LaplaceUとLaplaceVは、自分のグリッドの周囲８マスのUとVの濃度を集めるラプラシアン関数です。これによって周囲のグリッドと濃度が平均化されていきます。斜めのグリッドは影響度は低くなるように調整しています。</p>
<div class="emlist-code">
<p class="caption">ReactionDiffusion2D.compute</p>
<pre class="emlist">// Uのラプラシアン関数<font></font>
float LaplaceU(int x, int y) {<font></font>
  float sumU = 0;<font></font>
<font></font>
  for (int i = 0; i &lt; 9; i++) {<font></font>
    int2 pos = laplaceIndex[i];<font></font>
    int idx = GetIndex(x + pos.x, y + pos.y);<font></font>
    sumU += _BufferRead[idx].u * laplacePower[i];<font></font>
  }<font></font>
<font></font>
  return sumU;<font></font>
}<font></font>
<font></font>
// Vのラプラシアン関数<font></font>
float LaplaceV(int x, int y) {<font></font>
  float sumV = 0;<font></font>
<font></font>
  for (int i = 0; i &lt; 9; i++) {<font></font>
    int2 pos = laplaceIndex[i];<font></font>
    int idx = GetIndex(x + pos.x, y + pos.y);<font></font>
    sumV += _BufferRead[idx].v * laplacePower[i];<font></font>
  }<font></font>
<font></font>
  return sumV;<font></font>
}<font></font>
</pre>
</div>
<p>uとvを計算したら、_BufferWriteに書き込みます。saturateは0～1の間でクリップするための保険です。</p>

<h3><a id="h5-3-4"></a><span class="secno">5.3.4　</span>入力処理</h3>
<p>AキーやCキーを押すことで、グリッドに意図的にUとVの濃度差を追加する機能を用意しています。Aキーを押すことでランダムな位置にSeedNum個の点（Seed）を配置します。Cキーを押すことで中心に１つ点を配置します。</p>
<div class="emlist-code">
<p class="caption">ReactionDiffusion2D.cs</p>
<pre class="emlist">/// &lt;summary&gt;<font></font>
/// Seedの追加<font></font>
/// &lt;/summary&gt;<font></font>
/// &lt;param name="x"&gt;&lt;/param&gt;<font></font>
/// &lt;param name="y"&gt;&lt;/param&gt;<font></font>
void AddSeed(int x, int y)<font></font>
{<font></font>
  if (inputIndex &lt; inputMax)<font></font>
  {<font></font>
    inputData[inputIndex].x = x;<font></font>
    inputData[inputIndex].y = y;<font></font>
    inputIndex++;<font></font>
  }<font></font>
}<font></font>
</pre>
</div>
<p>inputData配列にグリッド上の点の座標を格納しています。</p>
<div class="emlist-code">
<p class="caption">ReactionDiffusion2D.cs</p>
<pre class="emlist">/// &lt;summary&gt;<font></font>
/// Seed配列をComputeShaderにわたす<font></font>
/// &lt;/summary&gt;<font></font>
void AddSeedBuffer()<font></font>
{<font></font>
  if (inputIndex &gt; 0)<font></font>
  {<font></font>
    inputBuffer.SetData(inputData);<font></font>
    cs.SetInt("_InputNum", inputIndex);<font></font>
    cs.SetInt("_TexWidth", texWidth);<font></font>
    cs.SetInt("_TexHeight", texHeight);<font></font>
    cs.SetInt("_SeedSize", seedSize);<font></font>
    cs.SetBuffer(kernelAddSeed, "_InputBufferRead", inputBuffer);<font></font>
    cs.SetBuffer(kernelAddSeed, "_BufferWrite", buffers[0]);    // update前なので0<font></font>
    cs.Dispatch(kernelAddSeed,<font></font>
      Mathf.CeilToInt((float)inputIndex / (float)THREAD_NUM_X),<font></font>
      1,<font></font>
      1);<font></font>
    inputIndex = 0;<font></font>
  }<font></font>
}<font></font>
</pre>
</div>
<p><b>inputBuffer</b>に、さきほどの点の座標が入ったinputeData配列をセットして、ComputeShaderに渡しています。</p>
<div class="emlist-code">
<p class="caption">ReactionDiffusion2D.compute</p>
<pre class="emlist">// シードの追加<font></font>
[numthreads(THREAD_NUM_X, 1, 1)]<font></font>
void AddSeed(uint id : SV_DispatchThreadID)<font></font>
{<font></font>
  if (_InputNum &lt;= id) return;<font></font>
<font></font>
  int w = _SeedSize;<font></font>
  int h = _SeedSize;<font></font>
  float radius = _SeedSize * 0.5;<font></font>
<font></font>
  int centerX = _InputBufferRead[id].x;<font></font>
  int centerY = _InputBufferRead[id].y;<font></font>
  int startX = _InputBufferRead[id].x - w / 2;<font></font>
  int startY = _InputBufferRead[id].y - h / 2;<font></font>
  for (int x = 0; x &lt; w; x++)<font></font>
  {<font></font>
    for (int y = 0; y &lt; h; y++)<font></font>
    {<font></font>
      float dis = distance(<font></font>
        float2(centerX, centerY),<font></font>
        float2(startX + x, startY + y)<font></font>
      );<font></font>
      if (dis &lt;= radius) {<font></font>
        _BufferWrite[GetIndex((centerX + x), (centerY + y))].v = 1;<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
}<font></font>
</pre>
</div>
<p>C#から渡されたinputBufferの座標を中心に円形になるようにvの値を1にしています。</p>

<h3><a id="h5-3-5"></a><span class="secno">5.3.5　</span>RenderTextureに結果を書き込み</h3>
<p>更新したグリッドはただの配列なので、可視化のためにRenderTextureに書き込んで画像にします。RenderTextureにはuとvの濃度差を書き込みます。 <br>まずはRenderTextureを作成します。1ピクセルに書き込む情報は濃度差だけなので、RenderTextureFormatはRFloatにしておきます。RenderTextureFormat.RFloatは1ピクセルに付きfloat１つ分の情報が書き込めるRenderTextureの形式です。</p>
<div class="emlist-code">
<p class="caption">ReactionDiffusion2D.cs</p>
<pre class="emlist">/// &lt;summary&gt;<font></font>
/// RenderTexture作成<font></font>
/// &lt;/summary&gt;<font></font>
/// &lt;param name="width"&gt;&lt;/param&gt;<font></font>
/// &lt;param name="height"&gt;&lt;/param&gt;<font></font>
/// &lt;returns&gt;&lt;/returns&gt;<font></font>
RenderTexture CreateRenderTexture(int width, int height)<font></font>
{<font></font>
  RenderTexture tex = new RenderTexture(width, height, 0,<font></font>
    RenderTextureFormat.RFloat,<font></font>
    RenderTextureReadWrite.Linear);<font></font>
  tex.enableRandomWrite = true;<font></font>
  tex.filterMode = FilterMode.Bilinear;<font></font>
  tex.wrapMode = TextureWrapMode.Repeat;<font></font>
  tex.Create();<font></font>
<font></font>
  return tex;<font></font>
}<font></font>
</pre>
</div>
<p>続いてComputeShaderにRenderTextureを渡して書き込むC#側の処理です。</p>
<div class="emlist-code">
<p class="caption">ReactionDiffusion2D.cs</p>
<pre class="emlist">/// &lt;summary&gt;<font></font>
/// ReactionDiffusionの結果をテクスチャに書き込み<font></font>
/// &lt;/summary&gt;<font></font>
void DrawTexture()<font></font>
{<font></font>
  cs.SetInt("_TexWidth", texWidth);<font></font>
  cs.SetInt("_TexHeight", texHeight);<font></font>
  cs.SetBuffer(kernelDraw, "_BufferRead", buffers[0]);<font></font>
  cs.SetTexture(kernelDraw, "_HeightMap", resultTexture);<font></font>
  cs.Dispatch(kernelDraw,<font></font>
    Mathf.CeilToInt((float)texWidth / THREAD_NUM_X),<font></font>
    Mathf.CeilToInt((float)texHeight / THREAD_NUM_X),<font></font>
    1);<font></font>
}<font></font>
</pre>
</div>
<p>こちらは、ComputeShader側の処理です、グリッドのバッファからuとvの濃度差を求めて、テクスチャに書き込んでいます。</p>
<div class="emlist-code">
<p class="caption">ReactionDiffusion2D.compute</p>
<pre class="emlist">// テクスチャ書き込み用の値計算<font></font>
float GetValue(int x, int y) {<font></font>
  int idx = GetIndex(x, y);<font></font>
  float u = _BufferRead[idx].u;<font></font>
  float v = _BufferRead[idx].v;<font></font>
  return 1 - clamp(u - v, 0, 1);<font></font>
}<font></font>
<font></font>
...<font></font>
<font></font>
// テクスチャに描画<font></font>
[numthreads(THREAD_NUM_X, THREAD_NUM_X, 1)]<font></font>
void Draw(uint3 id : SV_DispatchThreadID)<font></font>
{<font></font>
  float c = GetValue(id.x, id.y);<font></font>
<font></font>
  // height map<font></font>
  _HeightMap[id.xy] = c;<font></font>
<font></font>
}<font></font>
</pre>
</div>

<h3><a id="h5-3-6"></a><span class="secno">5.3.6　</span>描画</h3>
<p>通常のUnlit Shaderを改修して、前項で作ったテクスチャの明度をもとに、２色を間を補間しています。</p>
<div class="emlist-code">
<p class="caption">ReactionDiffusion2D.cs</p>
<pre class="emlist">/// &lt;summary&gt;<font></font>
/// マテリアルの更新<font></font>
/// &lt;/summary&gt;<font></font>
void UpdateMaterial()<font></font>
{<font></font>
  material.SetTexture("_MainTex", resultTexture);<font></font>
<font></font>
  material.SetColor("_Color0", bottomColor);<font></font>
  material.SetColor("_Color1", topColor);<font></font>
}<font></font>
</pre>
</div>
<div class="emlist-code">
<p class="caption">ReactionDiffusion2D.shader</p>
<pre class="emlist">fixed4 frag (v2f i) : SV_Target<font></font>
{<font></font>
  // sample the texture<font></font>
  fixed4 col = lerp(_Color0, _Color1, tex2D(_MainTex, i.uv).r);<font></font>
  return col;<font></font>
}<font></font>
</pre>
</div>
<p>実行すると画面上に生物のような模様が広がっていくはずです。</p>
<div id="id_kaiware_2Frd2d__1" class="image">
<img src="./Chapter 5 _ Reaction Diffusion_files/rd2d_1.png" alt="State of simulation" class="width-050per">
<p class="caption">
図5.3: シミュレーションの様子
</p>
</div>

<h2><a id="h5-4"></a><span class="secno">5.4　</span>パラメータを変えてみる</h2>
<p>FeedとKillのパラメータを少し変えてみるだけで、さまざまな模様が浮かび上がります。ここでいくつかパラメータの組み合わせを紹介します。</p>
<br class="pagebreak">

<h3><a id="h5-4-1"></a><span class="secno">5.4.1　</span>サンゴのような模様</h3>
<p>Feed:0.037 / Kill:0.06</p>
<div id="id_kaiware_2Fcoral" class="image">
<img src="./Chapter 5 _ Reaction Diffusion_files/coral.png" alt="Coral-like pattern" class="width-040per">
<p class="caption">
図5.4: サンゴのような模様
</p>
</div>

<h3><a id="h5-4-2"></a><span class="secno">5.4.2　</span>つぶつぶ模様</h3>
<p>Feed:0.03 / Kill:0.062</p>
<div id="id_kaiware_2Fpoints001" class="image">
<img src="./Chapter 5 _ Reaction Diffusion_files/points001.png" alt="Crushed pattern" class="width-040per">
<p class="caption">
図5.5: つぶつぶ模様
</p>
</div>
<br class="pagebreak">

<h3><a id="h5-4-3"></a><span class="secno">5.4.3　</span>つぶつぶが消滅と分裂を繰り返す模様</h3>
<p>Feed:0.0263 / Kill:0.06</p>
<div id="id_kaiware_2Fpoints002" class="image">
<img src="./Chapter 5 _ Reaction Diffusion_files/points002.png" alt="It seems that crushing repeats disappearance and division" class="width-040per">
<p class="caption">
図5.6: つぶつぶが消滅と分裂を繰り返す模様
</p>
</div>

<h3><a id="h5-4-4"></a><span class="secno">5.4.4　</span>まっすぐ伸びて、ぶつからないように避ける模様</h3>
<p>Feed:0.077 / Kill:0.0615</p>
<div id="id_kaiware_2Fworm" class="image">
<img src="./Chapter 5 _ Reaction Diffusion_files/worm.png" alt="It seems that it stretches straight and avoids hitting" class="width-040per">
<p class="caption">
図5.7: まっすぐ伸びて、ぶつからないように避ける模様
</p>
</div>
<br class="pagebreak">

<h3><a id="h5-4-5"></a><span class="secno">5.4.5　</span>ぷつぷつ穴模様</h3>
<p>Feed:0.039 / Kill:0.058</p>
<div id="id_kaiware_2Fhole" class="image">
<img src="./Chapter 5 _ Reaction Diffusion_files/hole.png" alt="Plump hole pattern" class="width-040per">
<p class="caption">
図5.8: ぷつぷつ穴模様
</p>
</div>

<h3><a id="h5-4-6"></a><span class="secno">5.4.6　</span>常にうねうねして安定しない模様</h3>
<p>Feed:0.026 / Kill:0.051</p>
<div id="id_kaiware_2Fchaos" class="image">
<img src="./Chapter 5 _ Reaction Diffusion_files/chaos.png" alt="It seems that it is always undulating and unstable" class="width-040per">
<p class="caption">
図5.9: 常にうねうねして安定しない模様
</p>
</div>
<br class="pagebreak">

<h3><a id="h5-4-7"></a><span class="secno">5.4.7　</span>波紋のように広がり続ける模様</h3>
<p>Feed:0.014 / Kill:0.0477</p>
<div id="id_kaiware_2Fwave" class="image">
<img src="./Chapter 5 _ Reaction Diffusion_files/wave.png" alt="A pattern that continues to spread like ripples" class="width-040per">
<p class="caption">
図5.10: 波紋のように広がり続ける模様
</p>
</div>

<h2><a id="h5-5"></a><span class="secno">5.5　</span>おまけ：Surface Shader対応版</h2>
<p>ここで、Surface Shaderを利用したUnityならではのきれいな質感表現をしたサンプルを紹介します。動作確認できるサンプルシーンは、<b>ReactionDiffusion2D_2</b>です。</p>

<h3><a id="h5-5-1"></a><span class="secno">5.5.1　</span>通常版との変更点</h3>
<p>ReactionDiffusionの処理自体は通常版と同じですが、描画用のテクスチャの作成時に、立体感を出すためのノーマルマップも作成しています。また、結果のテクスチャはRenderTextureFormat.RFloatでしたが、ノーマルマップはXYZ方向のノーマルベクトルを格納するため、RenderTextureFormat.ARGBFloatで作成しています。</p>
<div class="emlist-code">
<p class="caption">ReactionDiffusion2DForStandard.cs</p>
<pre class="emlist">void Initialize()<font></font>
{<font></font>
  ...<font></font>
  heightMapTexture = CreateRenderTexture(texWidth, texHeight,<font></font>
    RenderTextureFormat.RFloat);        // 高さマップ用テクスチャ作成<font></font>
  normalMapTexture = CreateRenderTexture(texWidth, texHeight,<font></font>
    RenderTextureFormat.ARGBFloat);     // ノーマルマップマップ用テクスチャ作成<font></font>
  ...<font></font>
}<font></font>
<font></font>
/// &lt;summary&gt;<font></font>
/// RenderTexture作成<font></font>
/// &lt;/summary&gt;<font></font>
/// &lt;param name="width"&gt;&lt;/param&gt;<font></font>
/// &lt;param name="height"&gt;&lt;/param&gt;<font></font>
/// &lt;param name="texFormat"&gt;&lt;/param&gt;<font></font>
/// &lt;returns&gt;&lt;/returns&gt;<font></font>
RenderTexture CreateRenderTexture(<font></font>
  int width,<font></font>
  int height,<font></font>
  RenderTextureFormat texFormat)<font></font>
{<font></font>
    RenderTexture tex = new RenderTexture(width, height, 0,<font></font>
      texFormat, RenderTextureReadWrite.Linear);<font></font>
    tex.enableRandomWrite = true;<font></font>
    tex.filterMode = FilterMode.Bilinear;<font></font>
    tex.wrapMode = TextureWrapMode.Repeat;<font></font>
    tex.Create();<font></font>
<font></font>
    return tex;<font></font>
}<font></font>
<font></font>
...<font></font>
<font></font>
void DrawTexture()<font></font>
{<font></font>
  ...<font></font>
  cs.SetTexture(kernelDraw, "_HeightMap", heightMapTexture);<font></font>
  cs.SetTexture(kernelDraw, "_NormalMap", normalMapTexture);  // ノーマルマップ用テクスチャセット<font></font>
  cs.Dispatch(kernelDraw,<font></font>
    Mathf.CeilToInt((float)texWidth / THREAD_NUM_X),<font></font>
    Mathf.CeilToInt((float)texHeight / THREAD_NUM_X),<font></font>
    1);<font></font>
}<font></font>
</pre>
</div>
<p>ComputeShader内では、周囲のグリッドとの濃度差から傾きを求めてノーマルマップ用のテクスチャに書き込んでいます。</p>
<div class="emlist-code">
<p class="caption">ReactionDiffusion2DStandard.compute</p>
<pre class="emlist">float3 GetNormal(int x, int y) {<font></font>
  float3 normal = float3(0, 0, 0);<font></font>
  float c = GetValue(x, y);<font></font>
  normal.x = ((GetValue(x - 1, y) - c) - (GetValue(x + 1, y) - c));<font></font>
  normal.y = ((GetValue(x, y - 1) - c) - (GetValue(x, y + 1) - c));<font></font>
  normal.z = 1;<font></font>
  normal = normalize(normal) * 0.5 + 0.5;<font></font>
  return normal;<font></font>
}<font></font>
<font></font>
...<font></font>
<font></font>
// テクスチャに描画<font></font>
[numthreads(THREAD_NUM_X, THREAD_NUM_X, 1)]<font></font>
void Draw(uint3 id : SV_DispatchThreadID)<font></font>
{<font></font>
  float c = GetValue(id.x, id.y);<font></font>
<font></font>
  // height map<font></font>
  _HeightMap[id.xy] = c;<font></font>
<font></font>
  // normal map<font></font>
  _NormalMap[id.xy] = float4(GetNormal(id.x, id.y), 1);<font></font>
}<font></font>
</pre>
</div>
<p>作成した２枚のテクスチャをSurface Shaderに渡して模様を描画します。Surface Shaderは、Unityの物理ベースレンダリングを簡単に使えるようにラッピングされたシェーダーで、surf関数の中で<b>SurfaceOutputStandard</b>構造体に必要なデータを代入して出力するだけで、自動的にライティングしてくれます。</p>
<div class="emlist-code">
<p class="caption">SurfaceOutputStandard構造体の定義</p>
<pre class="emlist">struct SurfaceOutputStandard<font></font>
{<font></font>
    fixed3 Albedo;      // ベース (ディフューズかスペキュラー) カラー<font></font>
    fixed3 Normal;      // 法線<font></font>
    half3 Emission;     // 発光色<font></font>
    half Metallic;      // 0=非メタル, 1=メタル<font></font>
    half Smoothness;    // 0=粗い, 1=滑らか<font></font>
    half Occlusion;     // オクルージョン (デフォルト 1)<font></font>
    fixed Alpha;        // 透明度のアルファ<font></font>
};<font></font>
</pre>
</div>
<div class="emlist-code">
<p class="caption">ReactionDiffusion2DStandard.shader</p>
<pre class="emlist">void surf(Input IN, inout SurfaceOutputStandard o) {<font></font>
<font></font>
  float2 uv = IN.uv_MainTex;<font></font>
<font></font>
  // 濃度取得<font></font>
  half v0 = tex2D(_MainTex, uv).x;<font></font>
<font></font>
  // 法線取得<font></font>
  float3 norm = UnpackNormal(tex2D(_NormalTex, uv));<font></font>
<font></font>
  // AとBの境界の値を出す<font></font>
  half p = smoothstep(_Threshold, _Threshold + _Fading, v0);<font></font>
<font></font>
  o.Albedo = lerp(_Color0.rgb, _Color1.rgb, p);         // ベース色<font></font>
  o.Alpha = lerp(_Color0.a, _Color1.a, p);              // アルファ値<font></font>
  o.Smoothness = lerp(_Smoothness0, _Smoothness1, p);   // スムースネス<font></font>
  o.Metallic = lerp(_Metallic0, _Metallic1, p);         // メタリック<font></font>
  o.Normal = normalize(float3(norm.x, norm.y, 1 - _NormalStrength));  // 法線<font></font>
<font></font>
  o.Emission = lerp(_Emit0 * _EmitInt0, _Emit1 * _EmitInt1, p).rgb;   // 発光<font></font>
}<font></font>
</pre>
</div>
<p>Unityのビルトイン関数の<b>unpackNormal関数</b>を使ってノーマルマップから法線を取得します。また、濃度差の割合から<b>SurfaceOutputStandard</b>の各種色や質感を設定しています。</p>
<p>実行すると次のような模様ができ上がるはずです。</p>
<div id="id_kaiware_2Frd__surface__shader" class="image">
<img src="./Chapter 5 _ Reaction Diffusion_files/rd_surface_shader.png" alt="SurfaceShader版">
<p class="caption">
図5.11: SurfaceShader版
</p>
</div>
<p>ノーマルマップによって、立体感が生まれています。また、モノクロではわかりませんが、シーン上のRGB３色のポイントライトの光沢も表現されています。</p>

<h2><a id="h5-6"></a><span class="secno">5.6　</span>３次元への拡張</h2>
<p>今まで２次元の平面上でのシミュレーションだったReaction Diffusionを３次元に拡張してみましょう。基本的な流れは２次元のときと同じですが、次元が１つ増えているのでRenderTextureやComputeBufferの作り方、ラプラス演算の仕方が少し変わっています。動作確認できるサンプルシーンは、<b>ReactionDiffusion3D</b>です。</p>

<h3><a id="h5-6-1"></a><span class="secno">5.6.1　</span>バッファの初期化部分</h3>
<p>濃度差の書き込み先のRenderTextureを２次元から３次元にするため、初期化処理をいくつか追加しています。</p>
<div class="emlist-code">
<p class="caption">ReactionDiffusion3D.cs</p>
<pre class="emlist">RenderTexture CreateTexture(int width, int height, int depth)<font></font>
{<font></font>
  RenderTexture tex = new RenderTexture(width, height, 0,<font></font>
    RenderTextureFormat.RFloat, RenderTextureReadWrite.Linear);<font></font>
  tex.volumeDepth = depth;<font></font>
  tex.enableRandomWrite = true;<font></font>
  tex.dimension = UnityEngine.Rendering.TextureDimension.Tex3D;<font></font>
  tex.filterMode = FilterMode.Bilinear;<font></font>
  tex.wrapMode = TextureWrapMode.Repeat;<font></font>
  tex.Create();<font></font>
<font></font>
  return tex;<font></font>
}<font></font>
</pre>
</div>
<p>まず、tex.volumeDepthにＺ方向の深さを入れています。それから、tex.dimensionにUnityEngine.Rendering.TextureDimension.Tex3Dを入れています。これは、RenderTextureが３次元のボリュームテクスチャであることを指定するための設定です。これでRenderTextureが３次元のボリュームテクスチャになりました。同様にReaction Diffusionのシミュレーション結果を格納するComputeBufferも３次元化します。こちらは単純に幅×高さ×深さのサイズを確保するだけです。</p>
<div class="emlist-code">
<p class="caption">ReactionDiffusion3D.cs</p>
<pre class="emlist">void Initialize()<font></font>
{<font></font>
  ...<font></font>
  int whd = texWidth * texHeight * texDepth;<font></font>
  buffers = new ComputeBuffer[2];<font></font>
  ...<font></font>
  for (int i = 0; i &lt; buffers.Length; i++)<font></font>
  {<font></font>
     buffers[i] = new ComputeBuffer(whd, Marshal.SizeOf(typeof(RDData)));<font></font>
  }<font></font>
  ...<font></font>
}<font></font>
</pre>
</div>

<h3><a id="h5-6-2"></a><span class="secno">5.6.2　</span>シミュレーションの３次元化</h3>
<p>続いてComputeShader側の変更点です。まず、結果の書き込み用のRenderTextureが３次元になったため、ComputeShader側のテクスチャの定義が<b>RWTexture2D&lt;float&gt;</b>から<b>RWTexture3D&lt;float&gt;</b>に変わります。</p>
<div class="emlist-code">
<p class="caption">ReactionDiffusion3D.compute</p>
<pre class="emlist">  RWTexture3D&lt;float&gt; _HeightMap;  // ハイトマップ
</pre>
</div>
<p>次にラプラシアン関数の３次元化です。３×３×３の合計２７マスを参照するように変更しています。ちなみにlaplacePowerの影響度はなんとなくで割り出した値です。</p>
<div class="emlist-code">
<p class="caption">ReactionDiffusion3D.compute</p>
<pre class="emlist">// ラプラシアン関数で参照する周囲のインデックス計算用テーブル<font></font>
static const int3 laplaceIndex[27] = {<font></font>
  int3(-1,-1,-1), int3(0,-1,-1), int3( 1,-1,-1),<font></font>
  int3(-1, 0,-1), int3(0, 0,-1), int3(1, 0,-1),<font></font>
  int3(-1, 1,-1), int3(0, 1,-1), int3(1, 1,-1),<font></font>
<font></font>
  int3(-1,-1, 0), int3(0,-1, 0), int3(1,-1, 0),<font></font>
  int3(-1, 0, 0), int3(0, 0, 0), int3(1, 0, 0),<font></font>
  int3(-1, 1, 0), int3(0, 1, 0), int3(1, 1, 0),<font></font>
<font></font>
  int3(-1,-1, 1), int3(0,-1, 1), int3(1,-1, 1),<font></font>
  int3(-1, 0, 1), int3(0, 0, 1), int3(1, 0, 1),<font></font>
  int3(-1, 1, 1), int3(0, 1, 1), int3(1, 1, 1),<font></font>
};<font></font>
<font></font>
// ラプラシアンの周囲のグリッドの影響度<font></font>
static const float laplacePower[27] = {<font></font>
  0.02, 0.02, 0.02,<font></font>
  0.02, 0.1,  0.02,<font></font>
  0.02, 0.02, 0.02,<font></font>
<font></font>
  0.02, 0.1,  0.02,<font></font>
  0.1, -1.0,  0.1,<font></font>
  0.02, 0.1,  0.02,<font></font>
<font></font>
  0.02, 0.02, 0.02,<font></font>
  0.02, 0.1,  0.02,<font></font>
  0.02, 0.02, 0.02<font></font>
};<font></font>
<font></font>
// バッファのインデックス計算<font></font>
int GetIndex(int x, int y, int z) {<font></font>
  x = (x &lt; 0) ? x + _TexWidth : x;<font></font>
  x = (x &gt;= _TexWidth) ? x - _TexWidth : x;<font></font>
<font></font>
  y = (y &lt; 0) ? y + _TexHeight : y;<font></font>
  y = (y &gt;= _TexHeight) ? y - _TexHeight : y;<font></font>
<font></font>
  z = (z &lt; 0) ? z + _TexDepth : z;<font></font>
  z = (z &gt;= _TexDepth) ? z - _TexDepth : z;<font></font>
<font></font>
  return z * _TexWidth * _TexHeight + y * _TexWidth + x;<font></font>
}<font></font>
<font></font>
// Uのラプラシアン関数<font></font>
float LaplaceU(int x, int y, int z) {<font></font>
  float sumU = 0;<font></font>
<font></font>
  for (int i = 0; i &lt; 27; i++) {<font></font>
    int3 pos = laplaceIndex[i];<font></font>
<font></font>
    int idx = GetIndex(x + pos.x, y + pos.y, z + pos.z);<font></font>
    sumU += _BufferRead[idx].u * laplacePower[i];<font></font>
  }<font></font>
  return sumU;<font></font>
}<font></font>
<font></font>
// Vのラプラシアン関数<font></font>
float LaplaceV(int x, int y, int z) {<font></font>
  float sumV = 0;<font></font>
<font></font>
  for (int i = 0; i &lt; 27; i++) {<font></font>
    int3 pos = laplaceIndex[i];<font></font>
    int idx = GetIndex(x + pos.x, y + pos.y, z + pos.z);<font></font>
    sumV += _BufferRead[idx].v * laplacePower[i];<font></font>
  }<font></font>
  return sumV;<font></font>
}<font></font>
</pre>
</div>

<h3><a id="h5-6-3"></a><span class="secno">5.6.3　</span>描画処理</h3>
<p>シミュレーション結果のRenderTextureが３次元のボリュームテクスチャになっているので、今までのようにUnlit ShaderやSurface Shaderにテクスチャを貼り付けても正常に表示されません。サンプルではマーチングキューブス法という手法を使ってポリゴンを生成して描画していますが、紙面の都合上、実装についての説明は省略させていただきます。マーチングキューブス法の解説については、申し訳ありませんがUnity Graphics Programming Vol.1の「第７章 雰囲気で始めるマーチングキューブス法入門」を参照してください。他にも、レイマーチングを使ったボリュームレンダリングで描画する方法もあります。凹さんのブログに非常にわかりやすい実装<a id="fnb-kw_hecomi" href="https://freder.io/files/unity3/kaiware007.html#fn-kw_hecomi" class="noteref" epub:type="noteref">*1</a>が紹介されているので、ぜひとも参考にしてください。</p>
<div class="footnote" epub:type="footnote" id="fn-kw_hecomi"><p class="footnote">[*1] 凹みTips http://tips.hecomi.com/entry/2018/01/05/192332</p></div>
<div id="id_kaiware_2Frd3d" class="image">
<img src="./Chapter 5 _ Reaction Diffusion_files/rd3d.png" alt="3D version Reaction Diffusion">
<p class="caption">
図5.12: ３次元版Reaction Diffusion
</p>
</div>

<h2><a id="h5-7"></a><span class="secno">5.7　</span>まとめ</h2>
<p>Gray-Scottモデルを使って生物のような模様を作る方法を紹介しました。FeedとKillのパラメータを少し変えるだけで全然違う模様ができるので、夢中になるとあっという間に時間が過ぎてしまうので注意しましょう（※個人差があります） <br>また、Reaction Diffusionを使った作品には、Nakama Kouheiさんの「DIFFUSION」<a id="fnb-kw_diffusion" href="https://freder.io/files/unity3/kaiware007.html#fn-kw_diffusion" class="noteref" epub:type="noteref">*2</a>やKitahara Nobutakaさんの「Reaction-Diffusion」<a id="fnb-kw_reaction_diffusion" href="https://freder.io/files/unity3/kaiware007.html#fn-kw_reaction_diffusion" class="noteref" epub:type="noteref">*3</a>があります。みなさんもReaction Diffusionの不思議な魅力に取り憑かれてみませんか？</p>
<div class="footnote" epub:type="footnote" id="fn-kw_diffusion"><p class="footnote">[*2] DIFFUSION https://vimeo.com/145251635</p></div>
<div class="footnote" epub:type="footnote" id="fn-kw_reaction_diffusion"><p class="footnote">[*3] Reaction-Diffusion https://vimeo.com/176261480</p></div>

<h2><a id="h5-8"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.8　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reference</font></font></h2>
<ul>
<li>Reaction-Diffusion Tutorial http://www.karlsims.com/rd.html</li>
<li>Reaction diffusion system（Gray-Scott model） <br>https://pmneila.github.io/jsexp/grayscott/</li>
</ul><div id="goog-gt-tt" class="skiptranslate" dir="ltr"><div style="padding: 8px;"><div><div class="logo"><img src="./Chapter 5 _ Reaction Diffusion_files/translate_24dp.png" width="20" height="20" alt="Google Translate"></div></div></div><div class="top" style="padding: 8px; float: left; width: 100%;"><h1 class="title gray">Original text</h1></div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">Contribute a better translation</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>


<div class="goog-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div><iframe frameborder="0" class="goog-te-menu-frame skiptranslate" title="Language Translate Widget" style="visibility: visible; box-sizing: content-box; width: 1001px; height: 263px; display: none;" src="./Chapter 5 _ Reaction Diffusion_files/saved_resource(1).html"></iframe><iframe frameborder="0" class="goog-te-menu-frame skiptranslate" title="Language Translate Widget" style="visibility: visible; box-sizing: content-box; width: 197px; height: 69px; display: none;" src="./Chapter 5 _ Reaction Diffusion_files/saved_resource(2).html"></iframe></body></html>