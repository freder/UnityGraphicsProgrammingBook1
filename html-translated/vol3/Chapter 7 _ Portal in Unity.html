<!DOCTYPE html>
<!-- saved from url=(0044)https://freder.io/files/unity3/fuqunaga.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="en" class="translated-ltr" style="height: 100%;"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <link rel="stylesheet" type="text/css" href="./Chapter 7 _ Portal in Unity_files/style.scss">
  <meta name="generator" content="Re:VIEW">
  <title>I tried to implement Portal with Unity</title>

			<style>
				img {
					max-width: 80vw;
					max-height: 80vh;
				}
			</style>
			<script>(function(){(function injection() {
  var pageLang = 'ja';
  var userLang = 'en';

  var uid = '1E07F158C6FA4460B352973E9693B329';
  var teId = 'TE_' + uid;
  var cbId = 'TECB_' + uid;

  function show() {
    window.setTimeout(function() {
      window[teId].showBanner(true);
    }, 10);
  }

  function newElem() {
    var elem = new google.translate.TranslateElement({
      autoDisplay: false,
      floatPosition: 0,
      multilanguagePage: true,
      pageLanguage: pageLang
    });
    return elem;
  }

  if (window[teId]) {
    show();
  } else {
    if (!window.google || !google.translate ||
        !google.translate.TranslateElement) {
      if (!window[cbId]) {
        window[cbId] = function() {
          window[teId] = newElem();
          show();
        };
      }
      var s = document.createElement('script');
      s.src = 'https://translate.google.com/translate_a/element.js?cb=' +
              encodeURIComponent(cbId) + '&client=tee&hl=' + userLang;
      document.getElementsByTagName('head')[0].appendChild(s);
    }
  }
})();})();</script><script src="./Chapter 7 _ Portal in Unity_files/f.txt"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="./Chapter 7 _ Portal in Unity_files/translateelement.css"><script type="text/javascript" charset="UTF-8" src="./Chapter 7 _ Portal in Unity_files/main.js"></script><script type="text/javascript" charset="UTF-8" src="./Chapter 7 _ Portal in Unity_files/element_main.js"></script></head>
		
<body style="position: relative; min-height: 100%; top: 40px;"><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:&#39;&#39;" style="visibility:visible" src="./Chapter 7 _ Portal in Unity_files/saved_resource.html"></iframe></div>
<h1><a id="h7"></a><span class="secno"><font style="vertical-align: inherit;"></font></span><font style="vertical-align: inherit;"><font class="" style="vertical-align: inherit;">I tried to implement </font><span class="secno"><font class="" style="vertical-align: inherit;">Chapter 7　</font></span><font class="" style="vertical-align: inherit;"> Portal in Unity</font></font></h1>

<h2><a id="h7-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Introduction</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do you know the game </font><font style="vertical-align: inherit;">Portal </font></font><a id="fnb-portal" href="https://freder.io/files/unity3/fuqunaga.html#fn-portal" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font><font style="vertical-align: inherit;">A puzzle action game released by Valve in 2007. </font><font style="vertical-align: inherit;">It is a god game. </font><font style="vertical-align: inherit;">The feature is a hole called a portal, and you can see the scenery on the other side as if the two holes are connected by a worm home, and you can warp through objects and your character. </font><font style="vertical-align: inherit;">The point is Anywhere Door. </font><font style="vertical-align: inherit;">You can set up a portal on a flat surface with a gun called a portal gun, and use this to advance the game. </font><font style="vertical-align: inherit;">This chapter is an article that tried to implement the function of this portal in Unity while being simple. </font><font style="vertical-align: inherit;">The sample is </font><font style="vertical-align: inherit;">"PortalGate System" of </font></font><br><a href="https://github.com/IndieVisualLab/UnityGraphicsProgramming3" class="link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/IndieVisualLab/UnityGraphicsProgramming3</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p>
<div class="footnote" epub:type="footnote" id="fn-portal"><p class="footnote">[*1] https://ja.wikipedia.org/wiki/Portal_(%E3%82%B2%E3%83%BC%E3%83%A0)</p></div>

<h2><a id="h7-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Project overview</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Think about the necessary elements as a place to play on the portal.</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Own character that can move</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">field</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portal gun (function to make a portal appear at a specified position)</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I want a hit. </font><font style="vertical-align: inherit;">Your character may be visible on the other side of the portal, so it's a first-person perspective, but you'll need a full-body model. </font><font style="vertical-align: inherit;">This time, </font><font style="vertical-align: inherit;">I used the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adam </font></font></b><a id="fnb-adam" href="https://freder.io/files/unity3/fuqunaga.html#fn-adam" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> model </font><font style="vertical-align: inherit;">distributed by Unity </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Also, I want to see the objects warping other than my character, so I can launch a red ball with the E button.</font></font></p>
<div class="footnote" epub:type="footnote" id="fn-adam"><p class="footnote">[*2] https://assetstore.unity.com/packages/essentials/tutorial-projects/adam-character-pack-adam-guard-lu-74842</p></div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The operation method is as follows.</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Move: WASD key or arrow key (hold down shift and dash)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viewpoint movement: Mouse movement</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portal launch: Mouse left and right click</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ball launch: E key</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jump: Spacebar</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From now on, the hole to warp is called a gate. </font><font style="vertical-align: inherit;">The class name </font><font style="vertical-align: inherit;">is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PortalGate in the</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> source code </font><font style="vertical-align: inherit;">.</font></font></p>

<h3><a id="h7-2-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Own character</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">My character was </font><font style="vertical-align: inherit;">created by modifying </font><font style="vertical-align: inherit;">Unity's Standard Assets </font></font><a id="fnb-stdasset" href="https://freder.io/files/unity3/fuqunaga.html#fn-stdasset" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It's like using the animation of ThirdPersonChracter while modifying the control of FirstPersonCharacter. </font><font style="vertical-align: inherit;">Field of view because if (the main camera) to the user's character itself will be reflected polygon is not clean Dari sinks </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Player</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the main camera provided a layer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Player</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we try to not displayed to set the layer to the camera of CullingMask.</font></font></p>
<div class="footnote" epub:type="footnote" id="fn-stdasset"><p class="footnote">[*3] https://assetstore.unity.com/packages/essentials/asset-packs/standard-assets-32351</p></div>

<h3><a id="h7-2-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Field</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the field, I used </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unity3d-jp</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 's level design asset </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">playGROWnd </font></font></b><a id="fnb-playg" href="https://freder.io/files/unity3/fuqunaga.html#fn-playg" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Somehow the atmosphere is like Portal. </font><font style="vertical-align: inherit;">This time, the field is a rectangular parallelepiped room to simplify the rest of the process. </font><font style="vertical-align: inherit;">Collisions are not used as they are, but transparent collisions are placed on each side of the rectangular parallelepiped. </font><font style="vertical-align: inherit;">The floor collision is wider than the room to prevent it from falling, as the post-warp object may be partially outside the room. </font><font style="vertical-align: inherit;">This is the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stage Coll</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> layer.</font></font></p>
<div class="footnote" epub:type="footnote" id="fn-playg"><p class="footnote">[*4] https://github.com/unity3d-jp/playgrownd</p></div>

<h2><a id="h7-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gate generation</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's implement the gate. </font><font style="vertical-align: inherit;">The gate this time is oriented to spread on the XY plane in the local coordinate system and pass through the Z + direction.</font></font></p>
<div id="id_fuqunaga_2Fgate__coorinate" class="image">
<img src="./Chapter 7 _ Portal in Unity_files/gate_coorinate.png" alt="Gate coordinate system" class="width-050per">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 7.1: Gate coordinate system
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The outbreak follows the original portal, so that when you click the mouse, the gate will appear on the plane of the viewpoint, and left-click and right-click will connect each other as a pair. </font><font style="vertical-align: inherit;">If there is already a gate, the old gate will disappear on the spot and a new gate will open. </font><font style="vertical-align: inherit;">Internally, the old gate has been moved to a new location and is the earliest.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PortalGun.cs</font></font></p>
<pre class="emlist">void Shot(int idx)<font></font>
{<font></font>
    RaycastHit hit;<font></font>
    if (Physics.Raycast(transform.position,<font></font>
        transform.forward,<font></font>
        out hit,<font></font>
        float.MaxValue,<font></font>
        LayerMask.GetMask(new[] { "StageColl" })))<font></font>
    {<font></font>
        var gate = gatePair[idx];<font></font>
        if (gate == null)<font></font>
        {<font></font>
            var go = Instantiate(gatePrefab);<font></font>
            gate = gatePair[idx] = go.GetComponent&lt;PortalGate&gt;();<font></font>
<font></font>
            var pair = gatePair[(idx + 1) % 2];<font></font>
            if (pair != null)<font></font>
            {<font></font>
                gate.SetPair(pair);<font></font>
                pair.SetPair(gate);<font></font>
            }<font></font>
        }<font></font>
<font></font>
        gate.hitColl = hit.collider;<font></font>
<font></font>
        var trans = gate.transform;<font></font>
        var normal = hit.normal;<font></font>
        var up = normal.y &gt;= 0f ? transform.up : transform.forward;<font></font>
<font></font>
        trans.position = hit.point + normal * gatePosOffset;<font></font>
        trans.rotation = Quaternion.LookRotation(-normal, up);<font></font>
<font></font>
        gate.Open();<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<p><b>StageColl</b>レイヤーのみの指定で、<code class="inline-code tt">transform.forward</code>方向にレイを飛ばしてヒット確認しています。ヒットがあればゲート操作の処理を行います。まずは既存のゲートがあるのか確認し、なければ生成します。ペアリングもここで行います。あとで使用するためにレイがぶつかったコライダーを<code class="inline-code tt">PortalGate.hitColl</code>にセットし、位置と向きを求めます。位置はぶつかった平面から少し法線方向に浮かせてZファイティング対策をしています。向きの求め方が少し変なのにお気づきでしょうか？Quaternion.LookRotation()のアップベクトルの指定をnormal.yの正負で変えています。通常はtransform.upでよいのですが、天井にゲートを出したときこのままだと前後（PortalGateのY方向）が反転して違和感があるのでこのようにしました。たしかオリジナルのPortalでもこのような挙動だったと思います。</p>
<div id="id_fuqunaga_2Fceil__fall__bad" class="image">
<img src="./Chapter 7 _ Portal in Unity_files/ceil_fall_bad.png" alt="When not up-vector processing">
<p class="caption">
図7.2: アップベクトル処理をしない場合
</p>
</div>
<div id="id_fuqunaga_2Fceil__fall__good" class="image">
<img src="./Chapter 7 _ Portal in Unity_files/ceil_fall_good.png" alt="When up-vector processing is performed">
<p class="caption">
図7.3: アップベクトル処理をした場合
</p>
</div>

<h2><a id="h7-4"></a><span class="secno">7.4　</span>VirtualCamera</h2>

<h3><a id="h7-4-1"></a><span class="secno">7.4.1　</span>初期化</h3>
<p>ゲートが開くとペアになった別のゲート（以降ペアゲートと呼びます）の向こう側が見えるのでこの描画をなんとか実装する必要があります。「向こう側」を描画するための<b>「別のカメラ(VirtualCamera)を用意しRenderTextureにキャプチャ、それをPortalGateに貼り付けてメインカメラで描画」</b>というアプローチにしました。</p>
<p>VirtualCameraはゲートの向こう側の絵をキャプチャするカメラです。</p>
<div id="id_fuqunaga_2Fvirtual__camera" class="image">
<img src="./Chapter 7 _ Portal in Unity_files/virtual_camera.png" alt="VirtualCamera">
<p class="caption">
図7.4: VirtualCamera
</p>
</div>
<p><code class="inline-code tt">PortalGate.OnWillRenderObject()</code>が各カメラごとに呼ばれるのでそのタイミングでVirtualCameraが必要であれば生成します。</p>
<div class="emlist-code">
<p class="caption">PortalGate.cs</p>
<pre class="emlist">private void OnWillRenderObject()<font></font>
{<font></font>
～省略～<font></font>
    VirtualCamera pairVC;<font></font>
    if (!pairVCTable.TryGetValue(cam, out pairVC))<font></font>
    {<font></font>
        if ((vc == null) || vc.generation &lt; maxGeneration)<font></font>
        {<font></font>
            pairVC = pairVCTable[cam] = CreateVirtualCamera(cam, vc);<font></font>
            return;<font></font>
        }<font></font>
    }<font></font>
<font></font>
～省略～<font></font>
}<font></font>
</pre>
</div>
<p>ゲート同士を向かい合わせにすると向こう側の景色にもまたゲートが映り、そのゲートの向こう側にもまたゲートが・・・と、あわせ鏡のように無限に続きます。</p>
<div id="id_fuqunaga_2Fgate__inf" class="image">
<img src="./Chapter 7 _ Portal in Unity_files/gate_inf.png" alt="Facing gate" class="width-050per">
<p class="caption">
図7.5: 向かい合わせのゲート
</p>
</div>
<p>この場合、</p>
<ol>
<li>メインカメラに映るゲートの向こう側の絵を用意するVirtualCamera</li>
<li>そのVirtualCameraに映るゲートの用の第二世代VirtualCamera</li>
<li>さらにそのVirtualCameraに映るゲート用の第三世代VirtualCamera</li>
<li>さらに・・・</li>
</ol>
<p>と愚直に実装するとVirtualCameraも無限に必要になってしまいます。さすがにそうはいかないので<code class="inline-code tt">PortalGate.maxGeneration</code>で世代数を制限し、それ以上は正確な絵ではないものの１フレーム前のテクスチャをゲートに貼り付けることで代用します。</p>
<div class="emlist-code">
<p class="caption">PortalGate.cs</p>
<pre class="emlist">VirtualCamera CreateVirtualCamera(Camera parentCam, VirtualCamera parentVC)<font></font>
{<font></font>
    var rootCam = parentVC?.rootCamera ?? parentCam;<font></font>
    var generation = parentVC?.generation + 1 ?? 1;<font></font>
<font></font>
    var go = Instantiate(virtualCameraPrefab);<font></font>
    go.name = rootCam.name + "_virtual" + generation;<font></font>
    go.transform.SetParent(transform);<font></font>
<font></font>
    var vc = go.GetComponent&lt;VirtualCamera&gt;();<font></font>
    vc.rootCamera = rootCam;<font></font>
    vc.parentCamera = parentCam;<font></font>
    vc.parentGate = this;<font></font>
    vc.generation = generation;<font></font>
<font></font>
    vc.Init();<font></font>
<font></font>
    return vc;<font></font>
}<font></font>
</pre>
</div>
<p><code class="inline-code tt">VirtualCamera.rootCamera</code>はVirtualCameraの世代をさかのぼって大元になるメインカメラです。他に、親のカメラ、対象のゲート、世代などを設定しています。</p>
<div class="emlist-code">
<p class="caption">VirtualCamera.cs</p>
<pre class="emlist">public void Init()<font></font>
{<font></font>
    camera_.aspect = rootCamera.aspect;<font></font>
    camera_.fieldOfView = rootCamera.fieldOfView;<font></font>
    camera_.nearClipPlane = rootCamera.nearClipPlane;<font></font>
    camera_.farClipPlane = rootCamera.farClipPlane;<font></font>
    camera_.cullingMask |= LayerMask.GetMask(new[] { PlayerLayerName });<font></font>
    camera_.depth = parentCamera.depth - 1;<font></font>
<font></font>
    camera_.targetTexture = tex0;<font></font>
    currentTex0 = true;<font></font>
}<font></font>
</pre>
</div>
<p><code class="inline-code tt">VirtualCamera.Init()</code>で親のカメラからパラメータを引き継いでいます。VirtualCameraには自キャラを映すのでCullingMaskから<b>Player</b>レイヤーを削除しています。また親のカメラより先に絵をキャプチャしたいので<code class="inline-code tt">parentCamera.depth - 1</code>しています。</p>
<p>当初<code class="inline-code tt">Camera.CopyFrom()</code>を使っていたのですがどうもCommandBufferもコピーしてしまうようで、ポストエフェクトに使っているPostProcessingStack<a id="fnb-pp" href="https://freder.io/files/unity3/fuqunaga.html#fn-pp" class="noteref" epub:type="noteref">*5</a>との併用でエラーが出てしまったので各プロパティごとにコピーするようにしました。</p>
<div class="footnote" epub:type="footnote" id="fn-pp"><p class="footnote">[*5] https://github.com/Unity-Technologies/PostProcessing</p></div>

<h3><a id="h7-4-2"></a><span class="secno">7.4.2　</span>更新</h3>
<p>VirtualCameraは処理が軽いほど<code class="inline-code tt">PortalGate.maxGeneration</code>を多くできるのでできるだ無駄な処理をしないよう少しパフォーマンスに気を使っています。</p>
<div class="emlist-code">
<p class="caption">VirtualCamera.cs</p>
<pre class="emlist">private void LateUpdate()<font></font>
{<font></font>
    // PreviewCameraなどはこのタイミングでnullになっているようなのでチェック<font></font>
    if (parentCamera == null)<font></font>
    {<font></font>
        Destroy(gameObject);<font></font>
        return;<font></font>
    }<font></font>
<font></font>
    camera_.enabled = parentGate.IsVisible(parentCamera);<font></font>
    if (camera_.enabled)<font></font>
    {<font></font>
        var parentCamTrans = parentCamera.transform;<font></font>
        var parentGateTrans = parentGate.transform;<font></font>
<font></font>
        parentGate.UpdateTransformOnPair(<font></font>
            transform,<font></font>
            parentCamTrans.position,<font></font>
            parentCamTrans.rotation<font></font>
            );<font></font>
<font></font>
<font></font>
        UpdateCamera();<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<p>こちらのコードを詳しく追っていきます。</p>

<h4><a id="h7-4-2-1"></a>カメラの無効化</h4>
<p>親のカメラにゲート映っていなければ向こう側の絵を用意する必要がないのでVirtualCameraのカメラを無効にします。</p>
<div class="emlist-code">
<p class="caption">PortalGate.cs</p>
<pre class="emlist">public bool IsVisible(Camera camera)<font></font>
{<font></font>
    var ret = false;<font></font>
<font></font>
    var pos = transform.position;<font></font>
    var camPos = camera.transform.position;<font></font>
<font></font>
    var camToGateDir = (pos - camPos).normalized;<font></font>
    var dot = Vector3.Dot(camToGateDir, transform.forward);<font></font>
    if (dot &gt; 0f)<font></font>
    {<font></font>
        var planes = GeometryUtility.CalculateFrustumPlanes(camera);<font></font>
        ret = GeometryUtility.TestPlanesAABB(planes, coll.bounds);<font></font>
    }<font></font>
<font></font>
    return ret;<font></font>
}<font></font>
</pre>
</div>
<p>可視判定は次のようになっています。</p>
<ol>
<li>向きの判定。ゲートがカメラの方を向いているかをチェックしています。カメラ→ゲート方向とゲートのZ+方向の内積の符号で判定しています。</li>
<li>視錐台とバウンディングボックスの可視判定。Unityにはまさのこのための関数が用意されておりそのまま使えます。ありがたや。</li>
</ol>

<h4><a id="h7-4-2-2"></a>位置と向きの更新</h4>
<p><code class="inline-code tt">parentGate.UpdateTransformOnPair()</code> で「親ゲートに対する親カメラの位置と向きから、親のペアのゲートに対する位置と向きを求めてtransformを更新する」処理をしています。</p>
<div class="emlist-code">
<p class="caption">PortalGate.cs</p>
<pre class="emlist">public void UpdateTransformOnPair(<font></font>
    Transform trans,<font></font>
    Vector3 worldPos,<font></font>
    Quaternion worldRot<font></font>
    )<font></font>
{<font></font>
    var localPos = transform.InverseTransformPoint(worldPos);<font></font>
    var localRot = Quaternion.Inverse(transform.rotation) * worldRot;<font></font>
<font></font>
    var pairGateTrans = pair.transform;<font></font>
    var gateRot = pair.gateRot;<font></font>
    var pos = pairGateTrans.TransformPoint(gateRot * localPos);<font></font>
    var rot = pairGateTrans.rotation * gateRot * localRot;<font></font>
<font></font>
    trans.SetPositionAndRotation(pos, rot);<font></font>
}<font></font>
</pre>
</div>
<p>実装はこのようになっており、</p>
<ol>
<li>ゲートのローカル座標系に直す</li>
<li>gateRotでゲートの手前→奥の向き変換</li>
<li>ペアのゲートのローカル座標として扱い</li>
<li>ワールド座標系に変換する</li>
</ol>
<p>という手順になっています。gateRotは</p>
<div class="emlist-code">
<pre class="emlist">public Quaternion gateRot { get; } = Quaternion.Euler(0f, 180f, 0f);
</pre>
</div>
<p>と、Y軸で180度回転にしてますが、Z値が反転すればいいので</p>
<div class="emlist-code">
<pre class="emlist">public Quaternion gateRot { get; } =  Quaterion.Euler(180f, 0f, 0f);
</pre>
</div>
<p>のような実装でも一応破綻はしないはずです。ただゲートの手前と奥で上方向が反転するのでゲートを通過すると自キャラの頭が地面側になるなど、やはり違和感が出てしまうのでY軸回転がよさそうです。</p>

<h4><a id="h7-4-2-3"></a>カメラパラメータの更新</h4>
<div class="emlist-code">
<p class="caption">VirtualCamera.cs</p>
<pre class="emlist">void UpdateCamera()<font></font>
{<font></font>
    var pair = parentGate.pair;<font></font>
    var pairTrans = pair.transform;<font></font>
    var mesh = pair.GetComponent&lt;MeshFilter&gt;().sharedMesh;<font></font>
    var vtxList = mesh.vertices<font></font>
                  .Select(vtx =&gt; pairTrans.TransformPoint(vtx)).ToList();<font></font>
<font></font>
    TargetCameraUtility.Update(camera_, vtxList);<font></font>
<font></font>
    // Oblique<font></font>
    // pairGateの奥しか描画しない = nearClipPlane を pairGateと一致させる<font></font>
    var pairGateTrans = parentGate.pair.transform;<font></font>
    var clipPlane = CalcPlane(camera_,<font></font>
                              pairGateTrans.position,<font></font>
                              -pairGateTrans.forward);<font></font>
<font></font>
    camera_.projectionMatrix = camera_.CalculateObliqueMatrix(clipPlane);<font></font>
}<font></font>
<font></font>
Vector4 CalcPlane(Camera cam, Vector3 pos, Vector3 normal)<font></font>
{<font></font>
    var viewMat = cam.worldToCameraMatrix;<font></font>
<font></font>
    var normalOnView = viewMat.MultiplyVector(normal).normalized;<font></font>
    var posOnView = viewMat.MultiplyPoint(pos);<font></font>
<font></font>
    return new Vector4(<font></font>
        normalOnView.x,<font></font>
        normalOnView.y,<font></font>
        normalOnView.z,<font></font>
        -Vector3.Dot(normalOnView, posOnView)<font></font>
        );<font></font>
}<font></font>
</pre>
</div>
<p>VirtualCameraはできるだけ処理を軽くしたいので視錐台もできるだけ狭くします。VirtualCamera越しに見たペアゲートの範囲だけ描画できればいいので、ペアゲートのメッシュの頂点をワールド座標にし、<code class="inline-code tt">TargetCameraUtility.Update()</code>でその頂点群が収まるように視錐台と<code class="inline-code tt">Camera.rect</code>を変更しています。</p>
<p>またVirtualCameraとペアゲートの間のオブジェクトは描画しないのでカメラのニアクリップ面をペアゲートと同じ平面にします。この操作は<code class="inline-code tt">Camera.CalculateObliqueMatrix()</code>で行えます。あまりドキュメントがないのでサンプルコードなどからの判断になりますがニアクリップ面をビュー座標系でxyzに法線、wに距離をいれたVector4で渡すようです。</p>

<h2><a id="h7-5"></a><span class="secno">7.5　</span>ゲートの描画</h2>
<p>状態に合わせて描画するものが違うのですが単一のシェーダーでやりきっています。</p>
<ul>
<li>枠と中身の表示がある</li>
<li>ゲートが生成、移動された直後は円が広がるアニメーションをする</li>
<li>まだペアゲートが無いときは背景（既存の壁や床）をモヤモヤさせる（<span class="imgref"><a href="https://freder.io/files/unity3/fuqunaga.html#id_fuqunaga_2Fgate__no__pair">図7.6</a></span>）</li>
<li>ペアゲートができたらモヤモヤからVirtualCameraの絵にフェードインする</li>
<li><code class="inline-code tt">PortalGate.maxGeneration</code>に達してVirtualCameraが無い場合は１フレーム前の絵をPortalGateに貼り付ける</li>
</ul>
<div id="id_fuqunaga_2Fgate__no__pair" class="image">
<img src="./Chapter 7 _ Portal in Unity_files/gate_no_pair.png" alt="When there is no pair gate, the background is moody" class="width-050per">
<p class="caption">
図7.6: ペアゲートが無いときは背景をモヤモヤ
</p>
</div>
<div class="emlist-code">
<p class="caption">PortalGate.shader</p>
<pre class="emlist">GrabPass<font></font>
{<font></font>
    "_BackgroundTexture"<font></font>
}<font></font>
</pre>
</div>
<p>まずはGrabPass<a id="fnb-grabpass" href="https://freder.io/files/unity3/fuqunaga.html#fn-grabpass" class="noteref" epub:type="noteref">*6</a>で背景をキャプチャしときます。</p>
<div class="footnote" epub:type="footnote" id="fn-grabpass"><p class="footnote">[*6] https://docs.unity3d.com/ja/current/Manual/SL-GrabPass.html</p></div>

<h3><a id="h7-5-1"></a><span class="secno">7.5.1　</span>頂点シェーダー</h3>
<div class="emlist-code">
<p class="caption">PortalGate.shader</p>
<pre class="emlist">v2f vert(appdata_img In)<font></font>
{<font></font>
    v2f o;<font></font>
<font></font>
    float3 posWorld = mul(unity_ObjectToWorld, float4(In.vertex.xyz, 1)).xyz;<font></font>
    float4 clipPos = mul(UNITY_MATRIX_VP, float4(posWorld, 1));<font></font>
    float4 clipPosOnMain = mul(_MainCameraViewProj, float4(posWorld, 1));<font></font>
<font></font>
    o.pos = clipPos;<font></font>
    o.uv = In.texcoord;<font></font>
    o.sposOnMain = ComputeScreenPos(clipPosOnMain);<font></font>
    o.grabPos = ComputeGrabScreenPos(o.pos);<font></font>
    return o;<font></font>
}<font></font>
</pre>
</div>
<p>頂点シェーダーはこんな感じです。スクリーン座標系の位置を2つ求めていて、現在のカメラでの位置<code class="inline-code tt">clipPos</code>と、メインカメラのもの<code class="inline-code tt">clipPosOnMain</code>があります。前者は通常のレンダリングに用い、後者はVirtualCameraでキャプチャしたRenderTextureを参照する際に使用します。またGrabPassを用いるときは専用のポジション計算関数がありますのでこれを使います。</p>

<h3><a id="h7-5-2"></a><span class="secno">7.5.2　</span>フラグメントシェーダー</h3>
<div class="emlist-code">
<p class="caption">PortalGate.shader</p>
<pre class="emlist">float2 uv = In.uv.xy;<font></font>
uv = (uv - 0.5) * 2; // map 0~1 to -1~1<font></font>
float insideRate = (1 - length(uv)) * _OpenRate;<font></font>
</pre>
</div>
<p><code class="inline-code tt">insideRate</code>（円の内側率）を求めています。円の中心が1、円周上が0、それより外はマイナスになります。<code class="inline-code tt">_OpenRate</code>で円の開き具合を変えれます。<b>PortalGate.Open()</b>で制御しています。</p>
<div class="emlist-code">
<p class="caption">PortalGate.shader</p>
<pre class="emlist">// background<font></font>
float4 grabUV = In.grabPos;<font></font>
float2 grabOffset = float2(<font></font>
    snoise(float3(uv, _Time.y     )),<font></font>
    snoise(float3(uv, _Time.y + 10))<font></font>
);<font></font>
grabUV.xy += grabOffset * 0.3 * insideRate;<font></font>
float4 bgColor = tex2Dproj(_BackgroundTexture, grabUV);<font></font>
</pre>
</div>
<p>モヤモヤした背景を生成しています。<code class="inline-code tt">snoise</code>はincludeしているNoise.cgincで定義されている関数でSimplexNoiseです。uv値と時間でgrabUVを揺らしています。insideRateも乗算することで中心付近ほど揺らぎを大きくしています。</p>
<div class="emlist-code">
<p class="caption">PortalGate.shader</p>
<pre class="emlist">// portal other side<font></font>
float2 sUV = In.sposOnMain.xy / In.sposOnMain.w;<font></font>
float4 sideColor = tex2D(_MainTex, sUV);<font></font>
</pre>
</div>
<p>ゲートの向こう側の絵です。<code class="inline-code tt">_MainTex</code>にはVirutualCameraがキャプチャしたテクスチャが入っており、メインカメラのUV値で参照しています。</p>
<div class="emlist-code">
<p class="caption">PortalGate.shader</p>
<pre class="emlist">// color<font></font>
float4 col = lerp(bgColor, sideColor, _ConnectRate);<font></font>
</pre>
</div>
<p><code class="inline-code tt">bgColor</code>（壁や床）と<code class="inline-code tt">sideColor</code>（ゲートの向こう側）をミックスしています。<code class="inline-code tt">_ConnectRate</code>はペアゲートができると0から1に遷移して、その後はずっと1のままです。</p>
<div class="emlist-code">
<p class="caption">PortalGate.shader</p>
<pre class="emlist">// frame<font></font>
float frame = smoothstep(0, 0.1, insideRate);<font></font>
float frameColorRate = 1 - abs(frame - 0.5) * 2;<font></font>
float mixRate = saturate(grabOffset.x + grabOffset.y);<font></font>
float3 frameColor = lerp(_FrameColor0, _FrameColor1, mixRate);<font></font>
col.xyz = lerp(col.xyz, frameColor, frameColorRate);<font></font>
<font></font>
col.a = frame;<font></font>
</pre>
</div>
<p>最後に枠を計算しています。<code class="inline-code tt">insideRate</code>の端っこを、<code class="inline-code tt">_FrameColor0,_FrameColor1</code>を適当にミックスして表示しています。</p>
<p>ここまでで見た目は完成しました。次は物理的な挙動のほうに焦点をあわせてみます。</p>

<h2><a id="h7-6"></a><span class="secno">7.6　</span>オブジェクトのワープ</h2>
<p><b>PortalObjコンポーネント</b>でワープまわりの処理を行うようにしました。これがついているGameObjectはワープできるようになります。</p>

<h3><a id="h7-6-1"></a><span class="secno">7.6.1　</span>既存コリジョンの無効化</h3>
<p>ゲートが設置された平面はもともととおり抜けできない、つまりコリジョンがあります。ゲートを通るときはこれを無効化しなくてはなりません。実はゲートには前後にわりと大きめに飛び出たコライダーをトリガーとして付けています。PortalObjはこのコライダーをトリガーとして平面とのコリジョン無効化を行っています。</p>
<div id="id_fuqunaga_2Fgate__collision" class="image">
<img src="./Chapter 7 _ Portal in Unity_files/gate_collision.png" alt="Gate collider" class="width-050per">
<p class="caption">
図7.7: ゲートのコライダー
</p>
</div>
<div class="emlist-code">
<p class="caption">PortalObj.cs</p>
<pre class="emlist">private void OnTriggerStay(Collider other)<font></font>
{<font></font>
    var gate = other.GetComponent&lt;PortalGate&gt;();<font></font>
    if ((gate != null) &amp;&amp; !touchingGates.Contains(gate) &amp;&amp; (gate.pair != null))<font></font>
    {<font></font>
        touchingGates.Add(gate);<font></font>
        Physics.IgnoreCollision(gate.hitColl, collider_, true);<font></font>
    }<font></font>
}<font></font>
<font></font>
private void OnTriggerExit(Collider other)<font></font>
{<font></font>
    var gate = other.GetComponent&lt;PortalGate&gt;();<font></font>
    if (gate != null)<font></font>
    {<font></font>
        touchingGates.Remove(gate);<font></font>
        Physics.IgnoreCollision(gate.hitColl, collider_, false);<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<p><code class="inline-code tt">OnTriggerEnder()</code>ではなく<code class="inline-code tt">OnTriggerStay()</code>なのは、まだゲートがひとつでペアがない状態のときにEnterしその後ペアができたときにも対応するためです。まずはトリガーとなったゲートを<code class="inline-code tt">tougingGates</code>に登録しておきます。前述の<code class="inline-code tt">PortalGate.hitColl</code>がやっと出てきました。これと自身のコライダーを<code class="inline-code tt">Physics.IgnoreCollision()</code>で衝突無視するようにセットしておきます。</p>
<p><code class="inline-code tt">OnTriggerExit()</code>で衝突を有効に戻しています。お気づきの方も多いかと思いますが、<code class="inline-code tt">PortalGate.hitColl</code>は平面全体のコライダーなので実はPortalGateの枠外でも通り抜けできてしまいます。「OnTriggerStay()をキープしている限り」という条件はつくのであまり目立ちませんがちゃんとしたゲートの形でのコリジョンするにはもうちょっと複雑な処理が必要そうです。</p>

<h3><a id="h7-6-2"></a><span class="secno">7.6.2　</span>ワープ処理</h3>
<div class="emlist-code">
<p class="caption">PortalObj.cs</p>
<pre class="emlist">private void Update()<font></font>
{<font></font>
    var passedGate = touchingGates.FirstOrDefault(gate =&gt;<font></font>
    {<font></font>
        var posOnGate = gate.transform.InverseTransformPoint(center.position);<font></font>
        return posOnGate.z &gt; 0f;<font></font>
    });<font></font>
<font></font>
<font></font>
    if (passedGate != null)<font></font>
    {<font></font>
        PassGate(passedGate);<font></font>
    }<font></font>
<font></font>
    if ((rigidbody_ != null) &amp;&amp; !rigidbody_.useGravity)<font></font>
    {<font></font>
        if ((Time.time - ignoreGravityStartTime)  &gt; ignoreGravityTime)<font></font>
        {<font></font>
            rigidbody_.useGravity = true;<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<p><code class="inline-code tt">center</code>はゲートを通過したかどうかの判定に使うTransformです。基本的にはPortalObjコンポーネントのついているGameObjectのものでいいのですが、自キャラはキャラの中心ではなくカメラが通過した時点でワープしたいので手動で設定できるようにしています。<code class="inline-code tt">center.position</code>が<code class="inline-code tt">z &gt; 0f</code>（ゲートの裏）になっているゲートがないか<code class="inline-code tt">touchingGates</code>をチェックしています。もしそのようなゲートが見つかれば<code class="inline-code tt">PassGate()</code>（ワープ処理）を行います。</p>
<p>また、後述しますがゲート通過直後にPortalObjは重力を無効化しています。これは地面に落ちているオブジェクトの下に別の床に繋がるゲートを開くと、オブジェクトがゲート間を行き来して振動してしまうので通過後は少し慣性をもったような挙動にするために行っています。</p>
<div class="emlist-code">
<p class="caption">PortalObj.cs</p>
<pre class="emlist">void PassGate(PortalGate gate)<font></font>
{<font></font>
    gate.UpdateTransformOnPair(transform);<font></font>
<font></font>
    if (rigidbody_ != null)<font></font>
    {<font></font>
        rigidbody_.velocity = gate.UpdateDirOnPair(rigidbody_.velocity);<font></font>
        rigidbody_.useGravity = false;<font></font>
        ignoreGravityStartTime = Time.time;<font></font>
    }<font></font>
<font></font>
    if (fpController != null)<font></font>
    {<font></font>
        fpController.m_MoveDir = gate.UpdateDirOnPair(fpController.m_MoveDir);<font></font>
        fpController.InitMouseLook();<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<p>ワープ処理はこんな感じになっています。VirtualCameraの位置を求めるときにも使用した<code class="inline-code tt">PortalGate.UpdateTransformOnPair()</code>でTransformをワープさせます。<code class="inline-code tt">RigidBody</code>を持っている場合は速度の向きも変えてやります。<code class="inline-code tt">fpController</code>（自キャラ操作のスクリプト）も同様です。この辺は大規模化するともっと対応が必要なオブジェクトが出てくるので各スクリプトコールバックを用意して通知するほうがいいかもしれません。</p>

<h3><a id="h7-6-3"></a><span class="secno">7.6.3　</span>ワープの問題点</h3>
<p>今回ワープを実装してみていくつかもうちょっと詰めていかないとなという点がありました。</p>

<h4><a id="h7-6-3-1"></a>PortalObjの速度がはやいと一度壁にぶつかる</h4>
<p>物理エンジンが衝突判定をしたあと押出処理をする前になんらかの方法でコリジョンを無効化したかったのですがうまい方法が見つかりませんでした。<code class="inline-code tt">OnTriggerEnter()</code>,<code class="inline-code tt">OnCollisionEnter()</code>内で<code class="inline-code tt">Physics.IgnoreCollision()</code>を呼んでも一度衝突したあとから無効化されるようです。おそらく<code class="inline-code tt">On~Enter()</code>が押出処理後に呼ばれているか<code class="inline-code tt">Physics.IgnoreCollision()</code>の反映されるタイミングが少し遅いのだと思います。このためトリガーへEnterするフレームと壁に衝突するフレームが別になるようにトリガーの範囲をかなり大きく飛び出させています。しかしこの方法では限界があり、より高速で移動するPortalObjには対応できていません。もし「こういう方法あるよ！」という方がいましたらぜひご連絡いただきたいです！</p>

<h4><a id="h7-6-3-2"></a>本当は途中にコピーを挟んだほうがよい</h4>
<p>ワープを<b>「オブジェクトの位置を書き換える」</b>ことで実装しましたが厳密に考えればゲートをくぐってる最中は半分手前で半分向こう側という状態があるはずです。大きいオブジェクトなどを出す場合は目立つのでこのあたりも考える必要がありそうです。さらに手前と向こう両方の衝突物の影響も受ける必要があり、より厳密には物理エンジン内のソルバに介入しないといけなそうな気がします。Unityだと厳しそうなのでうまくごまかす方向が現実的かなーという気がしています。</p>

<h2><a id="h7-7"></a><span class="secno">7.7　</span>まとめ</h2>
<p>以前からやってみたかったPortalの再現をUnityで挑戦してみました。カメラ重ねればいけるっしょーと気楽にはじめてみたものの思いのほか細かいところで大変なことがわかりました。CGやゲーム技術のなかでもリアル寄りにするものは需要が高く定型化してどんどん手軽になっていっています。現実感が簡単に出せるようになると、どこでもドアのような「いままでありがちだったけど現実味がなく眠っていたアイデア」が今後は意外と新しい体験として活きてきたりするかもしれません。</p>

<h2><a id="h7-8"></a><span class="secno">7.8　</span>参考</h2>
<ul>
<li>Portal <a href="http://www.thinkwithportals.com/" class="link">http://www.thinkwithportals.com/</a></li>
<li>Adam Character Pack <a href="https://assetstore.unity.com/packages/essentials/tutorial-projects/adam-character-pack-adam-guard-lu-74842" class="link">https://assetstore.unity.com/packages/essentials/tutorial-projects/adam-character-pack-adam-guard-lu-74842</a></li>
<li>playGROWnd <a href="https://github.com/unity3d-jp/playgrownd" class="link">https://github.com/unity3d-jp/playgrownd</a></li>
<li>PostProcessingStack <a href="https://github.com/Unity-Technologies/PostProcessing" class="link">https://github.com/Unity-Technologies/PostProcessing</a></li>
</ul><div id="goog-gt-tt" class="goog-tooltip skiptranslate" dir="ltr" style="visibility: hidden; left: 19px; top: 26.125px; display: none;"><div style="padding: 8px;"><div><div class="logo"><img src="./Chapter 7 _ Portal in Unity_files/translate_24dp.png" width="20" height="20" alt="Google Translate"></div></div></div><div class="top" style="padding: 8px; float: left; width: 100%;"><h1 class="title gray">Original text</h1></div><div class="middle" style="padding: 8px;"><div class="original-text">第7章　PortalをUnityで実装してみた</div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">Contribute a better translation</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none; opacity: 0;"></div></div>


<div class="goog-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div><iframe frameborder="0" class="goog-te-menu-frame skiptranslate" title="Language Translate Widget" style="visibility: visible; box-sizing: content-box; width: 1001px; height: 263px; display: none;" src="./Chapter 7 _ Portal in Unity_files/saved_resource(1).html"></iframe><iframe frameborder="0" class="goog-te-menu-frame skiptranslate" title="Language Translate Widget" style="visibility: visible; box-sizing: content-box; width: 197px; height: 69px; display: none;" src="./Chapter 7 _ Portal in Unity_files/saved_resource(2).html"></iframe></body></html>