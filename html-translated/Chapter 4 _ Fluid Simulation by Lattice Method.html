<!DOCTYPE html>
<!-- saved from url=(0075)https://freder.github.io/UnityGraphicsProgrammingBook1/articles/sakota.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="en" style="height: 100%;" class="translated-ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <link rel="stylesheet" type="text/css" href="./Chapter 4 _ Fluid Simulation by Lattice Method_files/style.scss">
  <meta name="generator" content="Re:VIEW">
  <title>格子法による流体シミュレーション</title>

			<style>
				img {
					max-width: 80vw;
					max-height: 80vh;
				}
			</style>
			<script>(function(){(function injection() {
  var pageLang = 'ja';
  var userLang = 'en';

  var uid = '1E07F158C6FA4460B352973E9693B329';
  var teId = 'TE_' + uid;
  var cbId = 'TECB_' + uid;

  function show() {
    window.setTimeout(function() {
      window[teId].showBanner(true);
    }, 10);
  }

  function newElem() {
    var elem = new google.translate.TranslateElement({
      autoDisplay: false,
      floatPosition: 0,
      multilanguagePage: true,
      pageLanguage: pageLang
    });
    return elem;
  }

  if (window[teId]) {
    show();
  } else {
    if (!window.google || !google.translate ||
        !google.translate.TranslateElement) {
      if (!window[cbId]) {
        window[cbId] = function() {
          window[teId] = newElem();
          show();
        };
      }
      var s = document.createElement('script');
      s.src = 'https://translate.google.com/translate_a/element.js?cb=' +
              encodeURIComponent(cbId) + '&client=tee&hl=' + userLang;
      document.getElementsByTagName('head')[0].appendChild(s);
    }
  }
})();})();</script><script src="./Chapter 4 _ Fluid Simulation by Lattice Method_files/f.txt"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="./Chapter 4 _ Fluid Simulation by Lattice Method_files/translateelement.css"><script type="text/javascript" charset="UTF-8" src="./Chapter 4 _ Fluid Simulation by Lattice Method_files/main.js"></script><script type="text/javascript" charset="UTF-8" src="./Chapter 4 _ Fluid Simulation by Lattice Method_files/element_main.js"></script></head>
		
<body style="position: relative; min-height: 100%; top: 40px;"><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:&#39;&#39;" style="visibility:visible" src="./Chapter 4 _ Fluid Simulation by Lattice Method_files/saved_resource.html"></iframe></div>
<h1><a id="h4"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;" class="">Chapter 4　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;" class=""> Fluid Simulation by Lattice Method</font></font></h1>

<h2><a id="h4-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> About this chapter</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this chapter, we will explain the fluid simulation by the lattice method using Compute Shader.</font></font></p>

<h2><a id="h4-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sample data</font></font></h2>

<h3><a id="h4-2-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code</font></font></h3>
<p><a href="https://github.com/IndieVisualLab/UnityGraphicsProgramming/" class="link">https://github.com/IndieVisualLab/UnityGraphicsProgramming/</a></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is stored in Assets / StabeFluids of.</font></font></p>

<h3><a id="h4-2-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Execution environment</font></font></h3>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shader model 5.0 compatible environment where ComputeShader can be executed</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operation confirmed in writing environment, Unity5.6.2, Unity2017.1.1</font></font></li>
</ul>

<h2><a id="h4-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Introduction</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this chapter, we will explain the fluid simulation by the lattice method and the calculation method and understanding of mathematical formulas necessary for realizing them. </font><font style="vertical-align: inherit;">First of all, what is the grid method? </font><font style="vertical-align: inherit;">In order to explore its meaning, let's take a closer look at how to analyze "flow" in fluid mechanics.</font></font></p>

<h3><a id="h4-3-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3.1 How　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to understand in fluid mechanics</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fluid mechanics is characterized by formulating a natural phenomenon, "flow," and making it computable. </font><font style="vertical-align: inherit;">How can this "flow" be quantified and analyzed? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you go straight to it, you can quantify it by deriving the "flow velocity when the time advances for a moment". </font><font style="vertical-align: inherit;">To put it a little mathematically, it can be rephrased as an analysis of the amount of change in the flow velocity vector when differentiating with time. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, there are two possible methods for analyzing this flow. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One is to measure the flow velocity vector of each fixed lattice space by dividing the hot water in the bath into a grid when imagining the hot water in the bath. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the other is to float a duck in the bath and analyze the movement of the duck itself. </font><font style="vertical-align: inherit;">Of these two methods, the former is called the "Euler's method" and the latter is called the "Lagrange's method".</font></font></p>

<h3><a id="h4-3-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Various fluid simulations</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, let's get back to computer graphics. </font><font style="vertical-align: inherit;">There are several simulation methods for fluid simulation, such as "Euler's method" and "Lagrange's method", but they can be roughly divided into the following three types.</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lattice method (eg Stable Fluid)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Particle Method (eg SPH)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lattice method + particle method (eg FLIP)</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can imagine from the meaning of Chinese characters, the grid method creates a grid-like "field" when simulating the flow, like the "Euler's method", and when it is differentiated with time, it is It is a method of simulating the speed of each grid. </font><font style="vertical-align: inherit;">In addition, the particle method is a method of simulating the advection of the particles themselves, focusing on the particles, such as the "Lagrange method". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Along with the lattice method and particle method, there are areas of strength and weakness in each other. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The lattice method is good at calculating pressure, viscosity, diffusion, etc. in fluid simulation, but not good at advection calculation. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the contrary, the particle method is good at calculating advection. </font><font style="vertical-align: inherit;">(You can imagine </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">these </font><font style="vertical-align: inherit;">strengths and weaknesses when you think of how to analyze Euler's method and Lagrange's method.) </font><font style="vertical-align: inherit;">To supplement these, the lattice method + particle method represented by the FLIP method. There are also methods that complement each other's areas of expertise.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this paper, we will explain the implementation method of fluid simulation and the necessary mathematical formulas in the simulation based on Stable Fluids, which is a paper on incompressible viscous fluid simulation in the lattice method by Jon Stam published at SIGGRAPH 1999. ..</font></font></p>

<h2><a id="h4-4"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.4　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> About the Navier-Stokes equation</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, let's look at the Navier-Stokes equation in the grid method.</font></font></p>
<div class="equation">
<pre>\dfrac {\partial \overrightarrow {u}} {\partial t}=-\left( \overrightarrow {u} \cdot \nabla \right) \overrightarrow {u} + \nu \nabla ^{2} \overrightarrow {u} + \overrightarrow{f}
</pre>
</div>
<div class="equation">
<pre>\dfrac {\partial \rho} {\partial t}=-\left( \overrightarrow {u} \cdot \nabla \right) \rho + \kappa \nabla ^{2} \rho + S
</pre>
</div>
<div class="equation">
<pre>\nabla \cdot \overrightarrow{u} = 0
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of the above, the first equation represents the velocity field and the second represents the density field. </font><font style="vertical-align: inherit;">The third is the "continuity equation (conservation of mass)". </font><font style="vertical-align: inherit;">Let's unravel these three formulas one by one.</font></font></p>

<h2><a id="h4-5"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.5　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Continuity equation (conservation of mass)</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, let's unravel the "continuity equation (conservation of mass)", which is short as an equation and works as a condition when simulating an "incompressible" fluid. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When simulating a fluid, it is necessary to make a clear distinction between compressible and incompressible objects. </font><font style="vertical-align: inherit;">For example, if the target is a gas whose density changes with pressure, it will be a compressible fluid. </font><font style="vertical-align: inherit;">Conversely, objects with a constant density, such as water, are incompressible fluids. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since this chapter deals with incompressible fluid simulations, the divergence of each cell in the velocity field should be kept at zero. </font><font style="vertical-align: inherit;">That is, it offsets the inflow and outflow of the velocity field and keeps it at zero. </font><font style="vertical-align: inherit;">If there is an inflow, it will flow out, so the flow velocity will propagate. </font><font style="vertical-align: inherit;">This condition can be expressed by the following equation as a continuity equation (conservation of mass).</font></font></p>
<div class="equation">
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\nabla \cdot \overrightarrow{u} = 0
</font></font></pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The above means that "divergence is 0". </font><font style="vertical-align: inherit;">First, let's check the formula of "divergence".</font></font></p>

<h3><a id="h4-5-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.5.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Divergence</font></font></h3>
<div class="equation">
<pre>\nabla \cdot \overrightarrow{u} = \nabla \cdot (u, v) = \dfrac{\partial u}{\partial x} + \dfrac{\partial v}{\partial y}
</pre>
</div>
<p><span class="equation">\nabla</span>（ナブラ演算子）はベクトル微分演算子といいます。例えばベクトル場が2次元と想定した場合に、図のように<span class="equation"> \left( \dfrac {\partial } {\partial x}_, \dfrac {\partial } {\partial y} \right) </span>の偏微分を取る際の、偏微分の表記を簡略化した演算子として作用します。<span class="equation">\nabla</span>演算子は演算子ですので、それだけでは意味を持ちませんが、一緒に組み合わせる式が内積なのか、外積なのか、それとも単に<span class="equation">\nabla f</span>といった関数なのかで演算内容が変わってきます。<br>今回は偏微分の内積をとる「発散（ダイバージェンス）」について説明しておきましょう。まず、なぜこの式が「発散」という意味になるのかを見てみます。</p>
<p>発散を理解する為に、まずは下記のような格子空間の一つのセルを切り出して考えてみましょう。</p>
<div id="divergence-s" class="image">
<img src="./Chapter 4 _ Fluid Simulation by Lattice Method_files/divergence-s.png" alt="ベクトル場から微分区間（Δx,Δy）のセルを抽出" class="width-070per">
<p class="caption">
図4.1: ベクトル場から微分区間（Δx,Δy）のセルを抽出
</p>
</div>
<p>発散とは、ベクトル場の一つのセルにどれくらいのベクトルが流出、流入しているかを算出する事を言います。なお流出を＋、流入を−とします。</p>
<p>発散は上記のように、ベクトル場のセルを切り取った際の偏微分をみた際に、x方向の特定のポイントxと微量に進んだ<span class="equation">\Delta x</span>との変化量、また、y方向の特定のポイントyと微量に進んだ<span class="equation">\Delta y</span>との変化量の内積で求める事ができます。なぜ偏微分との内積で流出が求まるかは、上記の図を微分演算する事で証明できます。</p>
<div class="equation">
<pre>\frac{i(x + \Delta x, y)\Delta y - i(x,y)\Delta y + j(x, y + \Delta y)\Delta x - j(x,y)\Delta x }{\Delta x \Delta y}
</pre>
</div>
<div class="equation">
<pre> = \frac{i(x+\Delta x, y) - i(x,y)}{\Delta x} + \frac{j(x, y+\Delta y) - j(x,y)}{\Delta y}
</pre>
</div>
<p>上記の式から極限をとり、</p>
<div class="equation">
<pre>\lim_{\Delta x \to 0} \frac{i(x+\Delta x, y) - i(x,y)}{\Delta x} + \lim_{\Delta y \to 0} \frac{j(x,y+\Delta y) - j(x,y)}{\Delta y} = \dfrac {\partial i} {\partial x} + \dfrac {\partial j} {\partial y}
</pre>
</div>
<p>とする事で、最終的に偏微分との内積の式と等式になる事がわかります。</p>

<h2><a id="h4-6"></a><span class="secno">4.6　</span>速度場</h2>
<p>次に、格子法の本丸である速度場について説明していきます。その前に、速度場のナビエ・ストークス方程式を実装していくにあたって、先ほど確認した発散（divergence）に加え、勾配（gradient）とラプラシアン（Laplacian）について確認しておきましょう。</p>

<h3><a id="h4-6-1"></a><span class="secno">4.6.1　</span>勾配（Gradient）</h3>
<div class="equation">
<pre>\nabla f(x, y) = \left( \dfrac{\partial f}{\partial x}_,\dfrac{\partial f}{\partial y}\right)
</pre>
</div>
<p><span class="equation">\nabla f (grad \ f)</span>は勾配を求める式となります。意味としては、各偏微分方向に微小に進んだ座標を、関数<span class="equation">f</span>にてサンプリングし、求められた各偏微分方向の値を合成する事によって、最終的にどのベクトルを向くのかを意味しています。つまり、偏微分した際の値の大きい方向に向いたベクトルを算出する事ができます。</p>

<h3><a id="h4-6-2"></a><span class="secno">4.6.2　</span>ラプラシアン（Laplacian）</h3>
<div class="equation">
<pre>\Delta f = \nabla^2 f = \nabla \cdot \nabla f = \frac{\partial^2 f}{\partial x^2} + \frac{\partial^2 f}{\partial y^2}
</pre>
</div>
<p>ラプラシアンはナブラを上下反転させた記号で表されます。(デルタと同じですが、文脈から読み取り、間違えないようにしましょう。)<br><span class="equation">\nabla^2 f</span>、もしくは<span class="equation">\nabla \cdot \nabla f</span>とも書き、二階偏微分として演算されます。<br>また、解体して考えると、関数の勾配をとって、発散を求めた形とも取れるでしょう。<br>意味合い的に考えると、ベクトル場の中で勾配方向に集中した箇所は流入が多い為、発散をとった場合−に、逆に勾配の低い箇所は湧き出しが多いので発散を取った時に＋になる事が想像できます。<br>ラプラシアン演算子にはスカラーラプラシアンとベクトルラプラシアンがあり、ベクトル場に作用させる場合は、勾配・発散・回転（∇とベクトルの外積）を用いた、<br></p>
<div class="equation">
<pre>\nabla^2 \overrightarrow{u} = \nabla \nabla \cdot \overrightarrow{u} - \nabla \times \nabla \times \overrightarrow{u}
</pre>
</div>
<p>といった式で導くのですが、直交座標系の場合のみ、ベクトルの成分毎に勾配と発散を求め、合成する事で求める事ができます。</p>
<div class="equation">
<pre>\nabla^2 \overrightarrow{u} = \left(<font></font>
\dfrac{\partial ^2 u_x}{\partial x^2}+\dfrac{\partial ^2 u_x}{\partial y^2}+\dfrac{\partial ^2 u_x}{\partial z^2}_,<font></font>
\dfrac{\partial ^2 u_y}{\partial x^2}+\dfrac{\partial ^2 u_y}{\partial y^2}+\dfrac{\partial ^2 u_y}{\partial z^2}_,<font></font>
\dfrac{\partial ^2 u_z}{\partial x^2}+\dfrac{\partial ^2 u_z}{\partial y^2}+\dfrac{\partial ^2 u_z}{\partial z^2}<font></font>
\right)<font></font>
</pre>
</div>
<p>以上で、格子法でのナビエ・ストークス方程式を解くための必要な数式の確認は完了しました。ここから、速度場の方程式を各項ごとに見ていきましょう。</p>

<h3><a id="h4-6-3"></a><span class="secno">4.6.3　</span>ナビエ・ストークス方程式から速度場の確認</h3>
<div class="equation">
<pre>\dfrac {\partial \overrightarrow {u}} {\partial t}=-\left( \overrightarrow {u} \cdot \nabla \right) \overrightarrow {u} + \nu \nabla ^{2} \overrightarrow {u} + \overrightarrow {f}
</pre>
</div>
<p>上記の内、<span class="equation">\overrightarrow {u}</span>は流速、<span class="equation">\nu</span>は動粘性係数（kinematic viscosity）、<span class="equation">\overrightarrow{f}</span>は外力（force）になります。<br>左辺側は時間で偏微分をとった際の流速である事がわかります。右辺側は第一項を移流項、第二項を拡散粘性項、第三項を圧力項、第四項を外力項とします。</p>
<p>これらは、計算時には一括でできるものであっても、実装時にはステップに分けて実装して行く必要があります。<br>まず、ステップとして、外力を受けなければ、初期条件のまま変化を起こす事ができませんので、第四項の外力項から考えて見たいと思います。</p>

<h3><a id="h4-6-4"></a><span class="secno">4.6.4　</span>速度場外力項</h3>
<p>これはシンプルに外部からのベクトルを加算する部分となります。つまり初期条件で速度場がベクトル量0の状態に対し、ベクトルの起点としてUIであったりなんらかのイベントから、RWTexture2Dの該当IDにベクトルを加算する部分となります。<br>コンピュートシェーダーの外力項のカーネルは、以下の様に実装しておきます。また、コンピュートシェーダーにて使用予定の各係数やバッファの定義も記述しておきます。</p>
<div class="emlist-code">
<pre class="emlist">float visc;                   //動粘性係数<font></font>
float dt;                     //デルタタイム<font></font>
float velocityCoef;           //速度場外力係数<font></font>
float densityCoef;            //密度場外圧係数<font></font>
<font></font>
//xy = velocity, z = density, 描画シェーダに渡す流体ソルバー<font></font>
RWTexture2D&lt;float4&gt; solver;<font></font>
//density field, 密度場<font></font>
RWTexture2D&lt;float&gt;  density;<font></font>
//velocity field, 速度場<font></font>
RWTexture2D&lt;float2&gt; velocity;<font></font>
//xy = pre vel, z = pre dens. when project, x = p, y = div<font></font>
//1ステップ前のバッファ保存、及び質量保存時の一時バッファ<font></font>
RWTexture2D&lt;float3&gt; prev;<font></font>
//xy = velocity source, z = density source 外力入力バッファ<font></font>
Texture2D source;<font></font>
<font></font>
[numthreads(THREAD_X, THREAD_Y, THREAD_Z)]<font></font>
void AddSourceVelocity(uint2 id : SV_DispatchThreadID)<font></font>
{<font></font>
    uint w, h;<font></font>
    velocity.GetDimensions(w, h);<font></font>
<font></font>
    if (id.x &lt; w &amp;&amp; id.y &lt; h)<font></font>
    {<font></font>
        velocity[id] += source[id].xy * velocityCoef * dt;<font></font>
        prev[id] = float3(source[id].xy * velocityCoef * dt, prev[id].z);<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<p>次のステップとして、第二項の拡散粘性項を実装します。</p>

<h3><a id="h4-6-5"></a><span class="secno">4.6.5　</span>速度場拡散粘性項</h3>
<div class="equation">
<pre>\nu \nabla ^{2} \overrightarrow {u}
</pre>
</div>
<p><span class="equation">\nabla</span>演算子や<span class="equation">\Delta</span>演算子の左右に値がある時には、「右の要素にのみ作用する」というルールがありますので、この場合、動粘性係数は一旦置いておいて、ベクトルラプラシアンの部分を先に考えます。<br>流速<span class="equation">\overrightarrow{u}</span>に対してベクトルラプラシアンで、ベクトルの各成分毎の勾配と発散をとり合成させ、流速を隣接へ拡散させています。そこに動粘性係数を乗算する事によって、拡散の勢いを調整します。<br>ここでは流速の各成分の勾配を取った上に拡散させていますので、隣接からの流入も隣接への流出も起こり、ステップ1で受けたベクトルが隣接へと影響していくという現象が分かるかと思います。<br>実装面においては、少し工夫が必要となります。数式通りに実装すると、粘性係数と微分時間・格子数を乗算させた拡散率が高くなってしまった場合に、振動が起こり、収束が取れず最後にはシミュレーション自体が発散してしまいます。<br>拡散をStableな状態にする為に、ここではガウス・ザイデル法やヤコビ法、SOR法等の反復法が用いられます。ここではガウス・ザイデル法でシミュレーションしてみましょう。<br>ガウス・ザイデル法とは、式を自セルに対する未知数からなる線形方程式に変換し、算出された値をすぐに次の反復時に使い、連鎖させることで近似の答えに収束させていく方法です。反復回数は多ければ多いほど正確な値へと収束していきますが、リアルタイムレンダリングにおけるグラフィックスで必要なのは、正確な結果ではなく、より良いフレームレートと見た目の美しさですので、イテレーション回数はマシンパフォーマンスや見た目を考慮し、調整しましょう。</p>
<div class="emlist-code">
<pre class="emlist">#define GS_ITERATE 4<font></font>
<font></font>
[numthreads(THREAD_X, THREAD_Y, THREAD_Z)]<font></font>
void DiffuseVelocity(uint2 id : SV_DispatchThreadID)<font></font>
{<font></font>
    uint w, h;<font></font>
    velocity.GetDimensions(w, h);<font></font>
<font></font>
    if (id.x &lt; w &amp;&amp; id.y &lt; h)<font></font>
    {<font></font>
        float a = dt * visc * w * h;<font></font>
<font></font>
        [unroll]<font></font>
        for (int k = 0; k &lt; GS_ITERATE; k++) {<font></font>
            velocity[id] = (prev[id].xy + a * (<font></font>
                            velocity[int2(id.x - 1, id.y)] +<font></font>
                            velocity[int2(id.x + 1, id.y)] +<font></font>
                            velocity[int2(id.x, id.y - 1)] +<font></font>
                            velocity[int2(id.x, id.y + 1)]<font></font>
                            )) / (1 + 4 * a);<font></font>
            SetBoundaryVelocity(id, w, h);<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<p>上記のSetBoundaryVelocity関数は境界用のメソッドになります。詳しくはリポジトリをご参照下さい。</p>

<h3><a id="h4-6-6"></a><span class="secno">4.6.6　</span>質量保存</h3>
<div class="equation">
<pre>\nabla \cdot \overrightarrow{u} = 0
</pre>
</div>
<p>ここで一旦、項を進める前に質量保存側に立ち返りましょう。これまでの工程で、外力項で受けた力を速度場に拡散させましたが、現状、各セルの質量は保存されておらず、湧き出しっぱなしの場所と流入が多い場所とで、質量が保存されていない状態になっています。<br>上記の方程式の様に、質量は必ず保存させ各セルの発散を0に持っていかないといけませんから、ここで一旦質量を保存をしておきましょう。<br>なお、質量保存ステップをComputeShaderで行う際、隣接スレッドとの偏微分演算を行う為、場を確定しておかなければなりません。グループシェアードメモリ内で偏微分演算ができれば高速化が見込めたのですが、別のグループスレッドから偏微分を取った時に、やはり値が取得できず汚い結果となってしまった為、ここはバッファを確定しながら、3ステップに分け進めます。<br>速度場から発散算出 &gt; Poisson方程式をガウス・ザイデル法で算出 &gt; 速度場に減算させ質量保存<br>の3ステップにカーネルをわけ、場を確定しながら質量保存に持っていきます。なお、SetBound~系は境界に対するメソッドの呼び出しになります。</p>
<div class="emlist-code">
<pre class="emlist">//質量保存Step1.<font></font>
//step1では、速度場から発散の算出<font></font>
[numthreads(THREAD_X, THREAD_Y, THREAD_Z)]<font></font>
void ProjectStep1(uint2 id : SV_DispatchThreadID)<font></font>
{<font></font>
    uint w, h;<font></font>
    velocity.GetDimensions(w, h);<font></font>
<font></font>
    if (id.x &lt; w &amp;&amp; id.y &lt; h)<font></font>
    {<font></font>
        float2 uvd;<font></font>
        uvd = float2(1.0 / w, 1.0 / h);<font></font>
<font></font>
        prev[id] = float3(0.0,<font></font>
                    -0.5 *<font></font>
                    (uvd.x * (velocity[int2(id.x + 1, id.y)].x -<font></font>
                              velocity[int2(id.x - 1, id.y)].x)) +<font></font>
                    (uvd.y * (velocity[int2(id.x, id.y + 1)].y -<font></font>
                              velocity[int2(id.x, id.y - 1)].y)),<font></font>
                    prev[id].z);<font></font>
<font></font>
        SetBoundaryDivergence(id, w, h);<font></font>
        SetBoundaryDivPositive(id, w, h);<font></font>
    }<font></font>
}<font></font>
<font></font>
//質量保存Step2.<font></font>
//step2では、step1で求めた発散からPoisson方程式をガウス・ザイデル法で解く<font></font>
[numthreads(THREAD_X, THREAD_Y, THREAD_Z)]<font></font>
void ProjectStep2(uint2 id : SV_DispatchThreadID)<font></font>
{<font></font>
    uint w, h;<font></font>
<font></font>
    velocity.GetDimensions(w, h);<font></font>
<font></font>
    if (id.x &lt; w &amp;&amp; id.y &lt; h)<font></font>
    {<font></font>
        for (int k = 0; k &lt; GS_ITERATE; k++)<font></font>
        {<font></font>
            prev[id] = float3(<font></font>
                        (prev[id].y + prev[uint2(id.x - 1, id.y)].x +<font></font>
                                      prev[uint2(id.x + 1, id.y)].x +<font></font>
                                      prev[uint2(id.x, id.y - 1)].x +<font></font>
                                      prev[uint2(id.x, id.y + 1)].x) / 4,<font></font>
                        prev[id].yz);<font></font>
            SetBoundaryDivPositive(id, w, h);<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
//質量保存Step3.<font></font>
//step3で、∇･u = 0にする.<font></font>
[numthreads(THREAD_X, THREAD_Y, THREAD_Z)]<font></font>
void ProjectStep3(uint2 id : SV_DispatchThreadID)<font></font>
{<font></font>
    uint w, h;<font></font>
<font></font>
    velocity.GetDimensions(w, h);<font></font>
<font></font>
    if (id.x &lt; w &amp;&amp; id.y &lt; h)<font></font>
    {<font></font>
        float  velX, velY;<font></font>
        float2 uvd;<font></font>
        uvd = float2(1.0 / w, 1.0 / h);<font></font>
<font></font>
        velX = velocity[id].x;<font></font>
        velY = velocity[id].y;<font></font>
<font></font>
        velX -= 0.5 * (prev[uint2(id.x + 1, id.y)].x -<font></font>
                       prev[uint2(id.x - 1, id.y)].x) / uvd.x;<font></font>
        velY -= 0.5 * (prev[uint2(id.x, id.y + 1)].x -<font></font>
                       prev[uint2(id.x, id.y - 1)].x) / uvd.y;<font></font>
<font></font>
        velocity[id] = float2(velX, velY);<font></font>
        SetBoundaryVelocity(id, w, h);<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<p>これで速度場を質量保存がされた状態にできました。流出した箇所に流入がおき、流入が多い箇所からは流出がおきる為、流体らしい表現になりました。</p>

<h3><a id="h4-6-7"></a><span class="secno">4.6.7　</span>移流項</h3>
<div class="equation">
<pre>-\left( \overrightarrow {u} \cdot \nabla \right) \overrightarrow {u}
</pre>
</div>
<p>移流項はラグランジュの方法的な手法が用いられるのですが、1ステップ前の速度場のバックトレースを行い、該当セルから速度ベクトルを引いた箇所の値を、現在いる場所に移動するといった作業を各セルに対して行います。バックトレースした際に、格子にぴったり収まる場所に遡れる訳ではありませんので、移流の際は近傍4セルとの線形補間を行い、正しい値を移流させます。</p>
<div class="emlist-code">
<pre class="emlist">[numthreads(THREAD_X, THREAD_Y, THREAD_Z)]<font></font>
void AdvectVelocity(uint2 id : SV_DispatchThreadID)<font></font>
{<font></font>
    uint w, h;<font></font>
    density.GetDimensions(w, h);<font></font>
<font></font>
    if (id.x &lt; w &amp;&amp; id.y &lt; h)<font></font>
    {<font></font>
        int ddx0, ddx1, ddy0, ddy1;<font></font>
        float x, y, s0, t0, s1, t1, dfdt;<font></font>
<font></font>
        dfdt = dt * (w + h) * 0.5;<font></font>
<font></font>
        //バックトレースポイント割り出し.<font></font>
        x = (float)id.x - dfdt * prev[id].x;<font></font>
        y = (float)id.y - dfdt * prev[id].y;<font></font>
        //ポイントがシミュレーション範囲内に収まるようにクランプ.<font></font>
        clamp(x, 0.5, w + 0.5);<font></font>
        clamp(y, 0.5, h + 0.5);<font></font>
        //バックトレースポイントの近傍セル割り出し.<font></font>
        ddx0 = floor(x);<font></font>
        ddx1 = ddx0 + 1;<font></font>
        ddy0 = floor(y);<font></font>
        ddy1 = ddy0 + 1;<font></font>
        //近傍セルとの線形補間用の差分を取っておく.<font></font>
        s1 = x - ddx0;<font></font>
        s0 = 1.0 - s1;<font></font>
        t1 = y - ddy0;<font></font>
        t0 = 1.0 - t1;<font></font>
<font></font>
        //バックトレースし、1step前の値を近傍との線形補間をとって、現在の速度場に代入。<font></font>
        velocity[id] = s0 * (t0 * prev[int2(ddx0, ddy0)].xy +<font></font>
                             t1 * prev[int2(ddx0, ddy1)].xy) +<font></font>
                       s1 * (t0 * prev[int2(ddx1, ddy0)].xy +<font></font>
                             t1 * prev[int2(ddx1, ddy1)].xy);<font></font>
        SetBoundaryVelocity(id, w, h);<font></font>
    }<font></font>
}<font></font>
</pre>
</div>

<h2><a id="h4-7"></a><span class="secno">4.7　</span>密度場</h2>
<p>次に密度場の方程式をみてみましょう。</p>
<div class="equation">
<pre>\dfrac {\partial \rho} {\partial t}=-\left( \overrightarrow {u} \cdot \nabla \right) \rho + \kappa \nabla ^{2} \rho + S
</pre>
</div>
<p>上記の内、<span class="equation">\overrightarrow {u}</span>は流速、<span class="equation">\kappa</span>は拡散係数、ρは密度、Sは外圧になります。<br>密度場は必ずしも必要ではありませんが、速度場を求めた際の各ベクトルに対し、密度場で拡散させた画面上のピクセルを乗せる事で、溶けながら流れる様な、より流体らしい表現が可能になります。<br>尚、密度場の数式を見て気づいた方もいらっしゃるかと思いますが、速度場と全く同じフローになっており、違いはベクトルがスカラーになっている点と、動粘性係数<span class="equation">\nu</span>が拡散係数<span class="equation">\kappa</span>になっている点、質量保存則を用いない点の3点のみしかありません。<br>密度場は密度の変化の場ですので、非圧縮性である必要はなく、質量保存の必要がありません。また、動粘性係数と拡散係数は、係数としての使い所は同じになります。<br>ですので、先ほど速度場で用いたカーネルの質量保存則以外のカーネルを、次元を落として作ることによって、密度場を実装する事が可能です。紙面上密度場の解説はしませんが、リポジトリには密度場も実装しておりますので、そちらもご参照ください。</p>

<h2><a id="h4-8"></a><span class="secno">4.8　</span>シミュレーションの各項ステップ</h2>
<p>上記の速度場及び密度場、質量保存則を用いることによって流体をシミュレーションする事ができるのですが、シミュレーションのステップについて、最後に見ておきましょう。</p>
<ul>
<li>外力イベントを発生させ、速度場と密度場の外力項にインプット</li>
<li>速度場を以下のステップで更新<ul>
<li>拡散粘性項</li>
<li>質量保存則</li>
<li>移流項</li>
<li>質量保存則</li>
</ul>
</li>
<li>その後密度場を以下のステップで更新<ul>
<li>拡散項</li>
<li>速度場の速度を用いで密度を移流</li>
</ul>
</li>
</ul>
<p>上記がStableFluidのシミュレーションステップになります。</p>

<h2><a id="h4-9"></a><span class="secno">4.9　</span>結果</h2>
<p>実行して、マウスでスクリーン上をドラッグすると、以下の様な流体シミュレーションを起こす事が可能です。</p>
<div id="fluid-s" class="image">
<img src="./Chapter 4 _ Fluid Simulation by Lattice Method_files/fluid-s.png" alt="実行例" class="width-070per">
<p class="caption">
図4.2: 実行例
</p>
</div>

<h2><a id="h4-10"></a><span class="secno">4.10　</span>まとめ</h2>
<p>流体シミュレーションは、プリレンダリングと違い、Unityの様なリアルタイムゲームエンジンにとっては負荷の高い分野です。しかし、GPU演算能力の向上から、2次元であればある程度の解像度でも耐えうるFPSが出せる様になってきました。また、途中で出てきたGPUにとって負荷の高い演算部分、ガウス・ザイデル反復法を別の処理で実装してみたり、速度場自体をカールノイズで代用してみたり等の工夫をすれば、より軽い演算での流体表現も可能になる事でしょう。</p>
<p>もしこの章をお読みいただいて、少しでも流体に興味を持たれた方は、ぜひ次章の「粒子法による流体シミュレーション」にもトライして見て下さい。格子法とはまた違った角度から流体に迫れますので、流体シミュレーションの奥深さや実装の面白さを体験できる事かと思います。</p>

<h2><a id="h4-11"></a><span class="secno">4.11　</span>参考</h2>
<ul>
<li>Jos Stam. SIGGRAPH 1999. Stable Fluids</li>
</ul><div id="goog-gt-tt" class="goog-tooltip skiptranslate" dir="ltr" style="visibility: hidden; left: 380px; top: 33.125px; display: none;"><div style="padding: 8px;"><div><div class="logo"><img src="./Chapter 4 _ Fluid Simulation by Lattice Method_files/translate_24dp.png" width="20" height="20" alt="Google Translate"></div></div></div><div class="top" style="padding: 8px; float: left; width: 100%;"><h1 class="title gray">Original text</h1></div><div class="middle" style="padding: 8px;"><div class="original-text">第4章　格子法による流体シミュレーション</div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">Contribute a better translation</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none; opacity: 0;"></div></div>


<div class="goog-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div><iframe frameborder="0" class="goog-te-menu-frame skiptranslate" title="Language Translate Widget" style="visibility: visible; box-sizing: content-box; width: 1001px; height: 263px; display: none;" src="./Chapter 4 _ Fluid Simulation by Lattice Method_files/saved_resource(1).html"></iframe><iframe frameborder="0" class="goog-te-menu-frame skiptranslate" title="Language Translate Widget" style="visibility: visible; box-sizing: content-box; width: 197px; height: 69px; display: none;" src="./Chapter 4 _ Fluid Simulation by Lattice Method_files/saved_resource(2).html"></iframe></body></html>