<!DOCTYPE html>
<!-- saved from url=(0041)https://freder.io/files/unity4/oishi.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="en" class="translated-ltr" style="height: 100%;"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <link rel="stylesheet" type="text/css" href="./Chapter 3 _ GPU-Based Cloth Simulation_files/style.scss">
  <meta name="generator" content="Re:VIEW">
  <title>GPU-Based Cloth Simulation</title>

			<style>
				img {
					max-width: 80vw;
					max-height: 80vh;
				}
			</style>
			<script>(function(){(function injection() {
  var pageLang = 'ja';
  var userLang = 'en';

  var uid = '1E07F158C6FA4460B352973E9693B329';
  var teId = 'TE_' + uid;
  var cbId = 'TECB_' + uid;

  function show() {
    window.setTimeout(function() {
      window[teId].showBanner(true);
    }, 10);
  }

  function newElem() {
    var elem = new google.translate.TranslateElement({
      autoDisplay: false,
      floatPosition: 0,
      multilanguagePage: true,
      pageLanguage: pageLang
    });
    return elem;
  }

  if (window[teId]) {
    show();
  } else {
    if (!window.google || !google.translate ||
        !google.translate.TranslateElement) {
      if (!window[cbId]) {
        window[cbId] = function() {
          window[teId] = newElem();
          show();
        };
      }
      var s = document.createElement('script');
      s.src = 'https://translate.google.com/translate_a/element.js?cb=' +
              encodeURIComponent(cbId) + '&client=tee&hl=' + userLang;
      document.getElementsByTagName('head')[0].appendChild(s);
    }
  }
})();})();</script><script src="./Chapter 3 _ GPU-Based Cloth Simulation_files/f.txt"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="./Chapter 3 _ GPU-Based Cloth Simulation_files/translateelement.css"><script type="text/javascript" charset="UTF-8" src="./Chapter 3 _ GPU-Based Cloth Simulation_files/main.js"></script><script type="text/javascript" charset="UTF-8" src="./Chapter 3 _ GPU-Based Cloth Simulation_files/element_main.js"></script></head>
		
<body style="position: relative; min-height: 100%; top: 40px;"><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:&#39;&#39;" style="visibility:visible" src="./Chapter 3 _ GPU-Based Cloth Simulation_files/saved_resource.html"></iframe></div>
<h1><a id="h3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chapter 3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GPU-Based Cloth Simulation</font></font></h1>

<h2><a id="h3-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Introduction</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simulation of the shape of a planar object that is deformed by an external force such as a flag or clothes </font><font style="vertical-align: inherit;">is called </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cloth Simulation</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and much research has been done in the CG field as it is essential for animation creation. .. </font><font style="vertical-align: inherit;">Already implemented in Unity, this chapter introduces a simple cloth simulation theory and GPU implementation for the purpose of learning parallel computing using GPU and understanding the nature of simulation and the meaning of parameters. I will do it.</font></font></p>
<div id="gcs_result" class="image">
<img src="./Chapter 3 _ GPU-Based Cloth Simulation_files/gcs_result.png" alt="Cloth simulation">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.1: Cloth simulation
</font></font></p>
</div>

<h2><a id="h3-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithm explanation</font></font></h2>

<h3><a id="h3-2-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mass-Spring System</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An object such as a spring, rubber, or cushion that deforms when a force is applied and returns to its original shape when the force is stopped is called an </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elastic body</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Since such elastic bodies cannot be represented by a single position or orientation, they represent an object by points and connections between them, and the movement of each point simulates the entire shape. </font><font style="vertical-align: inherit;">This point is called a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mass point</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and is considered to be a mass of mass without size. </font><font style="vertical-align: inherit;">In addition, the connection between mass points has the property of a spring. </font><font style="vertical-align: inherit;">The method of simulating an elastic body by calculating the expansion and contraction of each spring is called the mass-spring system, and it is a flag by calculating the motion of a set of mass points arranged in a two-dimensional shape. Simulation of clothes etc. is called Cloth Simulation.</font></font></p>
<div id="gcs_mass-spring_system" class="image">
<img src="./Chapter 3 _ GPU-Based Cloth Simulation_files/gcs_mass-spring_system.png" alt="Mass point-Spring system">
<p class="caption">
図3.2: 質点-バネ系
</p>
</div>

<h3><a id="h3-2-2"></a><span class="secno">3.2.2　</span>布シミュレーションに使用するアルゴリズム</h3>

<h4><a id="h3-2-2-1"></a>バネの力</h4>
<p>それぞれのバネは、接続された質点に対して、以下の式に従った力を与えます。</p>
<div class="equation">
<pre>F_{spring} = -k \left( I-I_{0} \right) - b v
</pre>
</div>
<p>ここで、<span class="equation">I</span>は、バネの現在の長さ（接続された質点同士の距離）、<span class="equation">I_{0}</span>は、シミュレーション開始時のバネの自然長（バネに何も荷重がかかっていない時の長さ）を表します。<span class="equation">k</span>は、バネの硬さを表す定数で、<span class="equation">v</span>は質点の速度、<span class="equation">b</span>は速度の減衰度合いを決定する定数です。この方程式は、バネは接続された質点同士の距離がバネの初期の自然長に戻ろうとする力が常に働くということを意味します。バネの現在の距離が、バネの自然長と大きく異なっていればそれだけ大きな力が働き、質点の現在の速度に比例して減衰します。</p>
<div id="gcs_force_spring" class="image">
<img src="./Chapter 3 _ GPU-Based Cloth Simulation_files/gcs_force_spring.png" alt="Spring force">
<p class="caption">
図3.3: バネの力
</p>
</div>

<h4><a id="h3-2-2-2"></a>バネの構造</h4>
<p>このシミュレーションでは、横・縦方向に、基本構造を作るバネを接続し、斜め方向の極端なズレを防ぐため、対角線状に位置する質点間にもバネを接続します。それぞれ、構造バネ（Structure Spring）、せん断バネ（Shear Spring）と呼び、1つの質点は近隣の12個の質点に対してバネを接続します。</p>
<div id="gcs_spring_structure" class="image">
<img src="./Chapter 3 _ GPU-Based Cloth Simulation_files/gcs_spring_structure.png" alt="Spring structure">
<p class="caption">
図3.4: バネの構造
</p>
</div>

<h4><a id="h3-2-2-3"></a>ベレ法（Verlet Method）による位置計算</h4>
<p>このシミュレーションでは、ベレ法というリアルタイムアプリケーションによく用いられる手法で質点の位置の計算を行います。ベレ法は、ニュートンの運動方程式の数値解法の一つであり、分子動力学において原子の動きなどを計算する時に用いられる手法です。物体の運動を計算する際、通常は速度から位置を求めますが、ベレ法では、<strong>現在の位置</strong>と、<strong>前のタイムステップでの位置</strong>から<strong>次のタイムステップにおける位置</strong>を求めます。</p>
<p>以下、ベレ法の代数方程式の導出を示します。<span class="equation">F</span>は質点に適用される力、<span class="equation">m</span>は質点の質量、<span class="equation">v</span>は速度、<span class="equation">x</span>は位置、<span class="equation">t</span>は時刻、<span class="equation">\Delta t</span>はシミュレーションのタイムステップ（シミュレーション１回の計算につき、どれだけの時間を進めるのか）とすると、質点の運動方程式は、</p>
<div class="equation">
<pre>m\dfrac {d^{2}x\left( t\right) }{dt^{2}}=F
</pre>
</div>
<p>と書けます。この運動方程式を、次の2つのテイラー展開を用いて、代数方程式にすると、</p>
<div class="equation">
<pre>x\left( t+\Delta t\right) =x\left( t\right) +\Delta t\dfrac {dx\left( t\right) }{dt}+\dfrac {1}{2!}\Delta t^{2}\dfrac {dx^{2}\left( t\right) }{dt^{2}}+\dfrac {1}{3!}\Delta t^{3}\dfrac {dx^{3}\left( t\right) }{dt^{3}}+\ldots
</pre>
</div>
<div class="equation">
<pre>x\left( t-\Delta t\right) =x\left( t\right) -\Delta t\dfrac {dx\left( t\right) }{dt}+\dfrac {1}{2!}\Delta t^{2}\dfrac {dx^{2}\left( t\right) }{dt^{2}}-\dfrac {1}{3!}\Delta t^{3}\dfrac {dx^{3}\left( t\right) }{dt^{3}}+\ldots
</pre>
</div>
<p>となります。この2つのテイラー展開式から、2階の微分項について解き、<span class="equation">\Delta t</span>の2次以上の項を十分に小さいものとして無視すると、次のように書けます。</p>
<div class="equation">
<pre>\dfrac {dx^{2}\left( t\right) }{dt^{2}}=\dfrac {x\left( t+\Delta t\right) -2x\left( t\right) +x\left( t-\Delta t\right) }{\Delta t^{2}}<br>
</pre>
</div>
<p>2階の微分項を、運動方程式より質量<span class="equation">m</span>と力<span class="equation">F</span>で表して整理すると、</p>
<div class="equation">
<pre>x\left( t+\Delta t\right) =2x\left( t\right) -x\left( t-\Delta t\right) +\dfrac {\Delta t^{2}}{m}F\left( t\right)
</pre>
</div>
<p>という代数方程式が得られます。このように1つ後のタイムステップにおける位置を、現在の位置、一つ前のタイムステップにおける位置、質量、力、タイムステップの値から求める式が得られます。</p>
<p>速度については、現在の位置と、時間的に一つ前の位置から求めます。</p>
<div class="equation">
<pre>v\left( t\right) =\dfrac {x\left( t\right) -x\left( t-\Delta t\right) }{\Delta t}
</pre>
</div>
<p>この計算によって求められる速度は、精度が高いとは言えませんが、バネの減衰の計算に用いるのみであるので、問題ではないと言えます。</p>

<h4><a id="h3-2-2-4"></a>衝突の計算</h4>

<h5><a id="h3-2-2-4-1"></a>布と球の衝突の計算</h5>
<p>衝突の処理は、「衝突の検出」と「それに対する反応」との二つのフェーズで行います。</p>
<p>衝突の検出は以下の式で行います。</p>
<div class="equation">
<pre>\left\| x\left( t+\Delta t\right) -c\right\| -r &lt; 0
</pre>
</div>
<p><span class="equation">c</span>と<span class="equation">r</span>は、球の<strong>中心</strong>と<strong>半径</strong>、<span class="equation">x\left( t+\Delta t\right)</span>は、ベレ法によって求められた次のタイムステップにおける位置です。もし衝突が検出されたら、質点を球の表面上に移動させることによって、球と布が衝突しない状態にします。詳細には、衝突点の表面の法線方向に、球の内部にある質点をずらすことによって行います。質点の位置の更新は、以下の式に従って行います。</p>
<div class="equation">
<pre>\begin{aligned}<font></font>
d=\dfrac {x\left( t+\Delta t\right) -c}{\left\| x\left( t+\Delta t\right) -c\right\|}<font></font>
\\<font></font>
x^{\prime}\left(t + \Delta t\right) = c + dr<font></font>
\end{aligned}<font></font>
</pre>
</div>
<p><span class="equation">x^{\prime}\left(t + \Delta t\right)</span>は、衝突の後更新された位置です。<span class="equation">d</span>は、質点が深く貫通しないとすると、衝突点における表面への法線の許容できる精度の近似とみなすことができます。</p>
<div id="gcs_collision_sphere" class="image">
<img src="./Chapter 3 _ GPU-Based Cloth Simulation_files/gcs_collision_sphere.png" alt="Collision calculation">
<p class="caption">
図3.5: 衝突の計算
</p>
</div>

<h2><a id="h3-3"></a><span class="secno">3.3　</span>サンプルプログラム</h2>

<h3><a id="h3-3-1"></a><span class="secno">3.3.1　</span>リポジトリ</h3>
<p>サンプルプログラムは、下記リポジトリ内の、<strong>Assets/GPUClothSimulation</strong>フォルダ内にあります。</p>
<p><a href="https://github.com/IndieVisualLab/UnityGraphicsProgramming4" class="link">https://github.com/IndieVisualLab/UnityGraphicsProgramming4</a></p>

<h4><a id="h3-3-1-1"></a>実行条件</h4>
<p>このサンプルプログラムでは、ComputeShaderを使用しています。ComputeShaderの動作環境についてはこちらをご確認下さい。</p>
<p><a href="https://docs.unity3d.com/ja/2018.3/Manual/class-ComputeShader.html" class="link">https://docs.unity3d.com/ja/2018.3/Manual/class-ComputeShader.html</a></p>

<h2><a id="h3-4"></a><span class="secno">3.4　</span>実装の解説</h2>

<h3><a id="h3-4-1"></a><span class="secno">3.4.1　</span>処理の概略</h3>
<p>それぞれのコンポーネントやコードがどのように関連して処理を行うかを示した概略図です。</p>
<div id="gcs_calculation_flow" class="image">
<img src="./Chapter 3 _ GPU-Based Cloth Simulation_files/gcs_calculation_flow.png" alt="Structure and processing flow of each component and code">
<p class="caption">
図3.6: 各コンポーネント, コードの構造と処理の流れ
</p>
</div>
<p>GPUClothSimulation.csはシミュレーションに使用するデータや処理を管理するC#スプリプトです。このスクリプトは、シミュレーションに使用する位置や法線のデータをRenderTextureの形式で作成し管理します。また、Kernels.computeに記述されたカーネルを呼び出すことによって処理を行います。計算結果の視覚化は、GPUClothRenderer.csスクリプトが行います。このスクリプトによって生成されたMeshオブジェクトは、計算結果である位置データ、法線データが格納されたRenderTextureを参照したClothSurface.shaderの処理によって、ジオメトリを変形して描画されます。</p>

<h4><a id="h3-4-1-1"></a>GPUClothSimulation.cs</h4>
<p>シミュレーションを制御するC#スクリプトです。</p>
<div class="emlist-code">
<pre class="emlist">using System.Collections;<font></font>
using System.Collections.Generic;<font></font>
using UnityEngine;<font></font>
<font></font>
public class GPUClothSimulation : MonoBehaviour<font></font>
{<font></font>
    [Header("Simulation Parameters")]<font></font>
    // タイムステップ<font></font>
    public float   TimeStep = 0.01f;<font></font>
    // シミュレーションの反復回数<font></font>
    [Range(1, 16)]<font></font>
    public int     VerletIterationNum = 4;<font></font>
    // 布の解像度（横, 縦)<font></font>
    public Vector2Int ClothResolution = new Vector2Int(128, 128);<font></font>
    // 布のグリッドの間隔（バネの自然長）<font></font>
    public float   RestLength = 0.02f;<font></font>
    // 布の伸縮性を決定する定数<font></font>
    public float   Stiffness = 10000.0f;<font></font>
    // 速度の減衰定数<font></font>
    public float   Damp = 0.996f;<font></font>
    // 質量<font></font>
    public float   Mass = 1.0f;<font></font>
    // 重力<font></font>
    public Vector3 Gravity = new Vector3(0.0f, -9.81f, 0.0f);<font></font>
<font></font>
    [Header("References")]<font></font>
    // 衝突用球体のTransformの参照<font></font>
    public Transform CollisionSphereTransform;<font></font>
    [Header("Resources")]<font></font>
    // シミュレーションを行うカーネル<font></font>
    public ComputeShader KernelCS;<font></font>
<font></font>
    // 布シミュレーション 位置データのバッファ<font></font>
    private RenderTexture[] _posBuff;<font></font>
    // 布シミュレーション 位置データ（ひとつ前のタイムステップ）のバッファ<font></font>
    private RenderTexture[] _posPrevBuff;<font></font>
    // 布シミュレーション 法線データのバッファ<font></font>
    private RenderTexture _normBuff;<font></font>
<font></font>
    // 布の長さ (横, 縦)<font></font>
    private Vector2 _totalClothLength;<font></font>
<font></font>
    [Header("Debug")]<font></font>
    // デバッグ用にシミュレーションバッファを表示する<font></font>
    public bool EnableDebugOnGUI = true;<font></font>
    // デバッグ表示時のバッファの表示スケール<font></font>
    private float _debugOnGUIScale = 1.0f;<font></font>
<font></font>
    // シミュレーションリソースを初期化したか<font></font>
    public bool IsInit { private set; get; }<font></font>
<font></font>
    // 位置データのバッファを取得<font></font>
    public RenderTexture GetPositionBuffer()<font></font>
    {<font></font>
        return this.IsInit ? _posBuff[0] : null;<font></font>
    }<font></font>
    // 法線データのバッファを取得<font></font>
    public RenderTexture GetNormalBuffer()<font></font>
    {<font></font>
        return this.IsInit ? _normBuff : null;<font></font>
    }<font></font>
    // 布の解像度を取得<font></font>
    public Vector2Int GetClothResolution()<font></font>
    {<font></font>
        return ClothResolution;<font></font>
    }<font></font>
<font></font>
    // ComputeShaderカーネルのX, Y次元のスレッドの数<font></font>
    const int numThreadsXY = 32;<font></font>
<font></font>
    void Start()<font></font>
    {<font></font>
        var w = ClothResolution.x;<font></font>
        var h = ClothResolution.y;<font></font>
        var format = RenderTextureFormat.ARGBFloat;<font></font>
        var filter = FilterMode.Point; // テクセル間の補間がなされないように<font></font>
        // シミュレーション用のデータを格納するRenderTextureを作成<font></font>
        CreateRenderTexture(ref _posBuff,     w, h, format, filter);<font></font>
        CreateRenderTexture(ref _posPrevBuff, w, h, format, filter);<font></font>
        CreateRenderTexture(ref _normBuff,    w, h, format, filter);<font></font>
        // シミュレーション用のデータをリセット<font></font>
        ResetBuffer();<font></font>
        // 初期化済みのフラグを True<font></font>
        IsInit = true;<font></font>
    }<font></font>
<font></font>
    void Update()<font></font>
    {<font></font>
        // rキーを押したら, シミュレーション用のデータをリセットする<font></font>
        if (Input.GetKeyUp("r"))<font></font>
            ResetBuffer();<font></font>
<font></font>
        // シミュレーションを行う<font></font>
        Simulation();<font></font>
    }<font></font>
<font></font>
    void OnDestroy()<font></font>
    {<font></font>
        // シミュレーション用のデータを格納するRenderTextureを削除<font></font>
        DestroyRenderTexture(ref _posBuff    );<font></font>
        DestroyRenderTexture(ref _posPrevBuff);<font></font>
        DestroyRenderTexture(ref _normBuff   );<font></font>
    }<font></font>
<font></font>
    void OnGUI()<font></font>
    {<font></font>
        // デバッグ用にシミュレーション用データを格納したRenderTextureを描画<font></font>
        DrawSimulationBufferOnGUI();<font></font>
    }<font></font>
<font></font>
    // シミュレーション用データをリセット<font></font>
    void ResetBuffer()<font></font>
    {<font></font>
        ComputeShader cs = KernelCS;<font></font>
        // カーネルIDを取得<font></font>
        int kernelId = cs.FindKernel("CSInit");<font></font>
        // ComputeShaderカーネルの実行スレッドグループの数を計算<font></font>
        int groupThreadsX =<font></font>
            Mathf.CeilToInt((float)ClothResolution.x / numThreadsXY);<font></font>
        int groupThreadsY =<font></font>
            Mathf.CeilToInt((float)ClothResolution.y / numThreadsXY);<font></font>
        // 布の長さ（横, 縦）の計算<font></font>
        _totalClothLength = new Vector2(<font></font>
            RestLength * ClothResolution.x,<font></font>
            RestLength * ClothResolution.y<font></font>
        );<font></font>
        // パラメータ, バッファをセット<font></font>
        cs.SetInts  ("_ClothResolution",<font></font>
            new int[2] { ClothResolution.x, ClothResolution.y });<font></font>
        cs.SetFloats("_TotalClothLength",<font></font>
            new float[2] { _totalClothLength.x, _totalClothLength.y });<font></font>
        cs.SetFloat ("_RestLength", RestLength);<font></font>
        cs.SetTexture(kernelId, "_PositionBufferRW",     _posBuff[0]);<font></font>
        cs.SetTexture(kernelId, "_PositionPrevBufferRW", _posPrevBuff[0]);<font></font>
        cs.SetTexture(kernelId, "_NormalBufferRW",       _normBuff);<font></font>
        // カーネルを実行<font></font>
        cs.Dispatch(kernelId, groupThreadsX, groupThreadsY, 1);<font></font>
        // バッファをコピー<font></font>
        Graphics.Blit(_posBuff[0],     _posBuff[1]);<font></font>
        Graphics.Blit(_posPrevBuff[0], _posPrevBuff[1]);<font></font>
    }<font></font>
<font></font>
    // シミュレーション<font></font>
    void Simulation()<font></font>
    {<font></font>
        ComputeShader cs = KernelCS;<font></font>
        // CSSimulationの計算1回あたりのタイムステップの値の計算<font></font>
        float timestep = (float)TimeStep / VerletIterationNum;<font></font>
        // カーネルIDを取得<font></font>
        int kernelId = cs.FindKernel("CSSimulation");<font></font>
        // ComputeShaderカーネルの実行スレッドグループの数を計算<font></font>
        int groupThreadsX =<font></font>
            Mathf.CeilToInt((float)ClothResolution.x / numThreadsXY);<font></font>
        int groupThreadsY =<font></font>
            Mathf.CeilToInt((float)ClothResolution.y / numThreadsXY);<font></font>
<font></font>
        // パラメータをセット<font></font>
        cs.SetVector("_Gravity", Gravity);<font></font>
        cs.SetFloat ("_Stiffness", Stiffness);<font></font>
        cs.SetFloat ("_Damp", Damp);<font></font>
        cs.SetFloat ("_InverseMass", (float)1.0f / Mass);<font></font>
        cs.SetFloat ("_TimeStep", timestep);<font></font>
        cs.SetFloat ("_RestLength", RestLength);<font></font>
        cs.SetInts  ("_ClothResolution",<font></font>
            new int[2] { ClothResolution.x, ClothResolution.y });<font></font>
<font></font>
        // 衝突用球のパラメータをセット<font></font>
        if (CollisionSphereTransform != null)<font></font>
        {<font></font>
            Vector3 collisionSpherePos = CollisionSphereTransform.position;<font></font>
            float collisionSphereRad =<font></font>
                CollisionSphereTransform.localScale.x * 0.5f + 0.01f;<font></font>
            cs.SetBool  ("_EnableCollideSphere", true);<font></font>
            cs.SetFloats("_CollideSphereParams",<font></font>
                new float[4] {<font></font>
                    collisionSpherePos.x,<font></font>
                    collisionSpherePos.y,<font></font>
                    collisionSpherePos.z,<font></font>
                    collisionSphereRad<font></font>
                });<font></font>
        }<font></font>
        else<font></font>
            cs.SetBool("_EnableCollideSphere", false);<font></font>
<font></font>
        for (var i = 0; i &lt; VerletIterationNum; i++)<font></font>
        {<font></font>
            // バッファをセット<font></font>
            cs.SetTexture(kernelId, "_PositionBufferRO",     _posBuff[0]);<font></font>
            cs.SetTexture(kernelId, "_PositionPrevBufferRO", _posPrevBuff[0]);<font></font>
            cs.SetTexture(kernelId, "_PositionBufferRW",     _posBuff[1]);<font></font>
            cs.SetTexture(kernelId, "_PositionPrevBufferRW", _posPrevBuff[1]);<font></font>
            cs.SetTexture(kernelId, "_NormalBufferRW",       _normBuff);<font></font>
            // スレッドを実行<font></font>
            cs.Dispatch(kernelId, groupThreadsX, groupThreadsY, 1);<font></font>
            // 読み込み用バッファ, 書き込み用バッファを入れ替え<font></font>
            SwapBuffer(ref _posBuff[0],     ref _posBuff[1]    );<font></font>
            SwapBuffer(ref _posPrevBuff[0], ref _posPrevBuff[1]);<font></font>
        }<font></font>
    }<font></font>
<font></font>
    // シミュレーション用のデータを格納するRenderTextureを作成<font></font>
    void CreateRenderTexture(ref RenderTexture buffer, int w, int h,<font></font>
        RenderTextureFormat format, FilterMode filter)<font></font>
    {<font></font>
        buffer = new RenderTexture(w, h, 0, format)<font></font>
        {<font></font>
            filterMode = filter,<font></font>
            wrapMode   = TextureWrapMode.Clamp,<font></font>
            hideFlags  = HideFlags.HideAndDontSave,<font></font>
            enableRandomWrite = true<font></font>
        };<font></font>
        buffer.Create();<font></font>
    }<font></font>
<font></font>
    // シミュレーション用のデータを格納するRenderTexture[]を作成<font></font>
    void CreateRenderTexture(ref RenderTexture[] buffer, int w, int h,<font></font>
        RenderTextureFormat format, FilterMode filter)<font></font>
    {<font></font>
        // 〜 略 〜<font></font>
    }<font></font>
<font></font>
    // シミュレーション用のデータを格納するRenderTextureを削除<font></font>
    void DestroyRenderTexture(ref RenderTexture buffer)<font></font>
    {<font></font>
        // 〜 略 〜<font></font>
    }<font></font>
<font></font>
    // シミュレーション用のデータを格納するRenderTexture[]を削除<font></font>
    void DestroyRenderTexture(ref RenderTexture[] buffer)<font></font>
    {<font></font>
        // 〜 略 〜<font></font>
    }<font></font>
<font></font>
    // マテリアルを削除<font></font>
    void DestroyMaterial(ref Material mat)<font></font>
    {<font></font>
        // 〜 略 〜<font></font>
    }<font></font>
<font></font>
    // バッファを入れ替え<font></font>
    void SwapBuffer(ref RenderTexture ping, ref RenderTexture pong)<font></font>
    {<font></font>
        RenderTexture temp = ping;<font></font>
        ping = pong;<font></font>
        pong = temp;<font></font>
    }<font></font>
<font></font>
    // デバッグ用に、シミュレーションのためのバッファをOnGUI関数内で描画<font></font>
    void DrawSimulationBufferOnGUI()<font></font>
    {<font></font>
        // 〜 略 〜<font></font>
    }<font></font>
}<font></font>
<font></font>
</pre>
</div>
<p>冒頭では、シミュレーションに必要なパラメータを宣言しています。また、シミュレーションの結果を保持するものとしてRenderTextureを用います。このシミュレーションに使用し、また得られるデータは</p>
<ol>
<li>位置</li>
<li>一つ前のタイムステップにおける位置</li>
<li>法線</li>
</ol>
<p>です。</p>

<h5><a id="h3-4-1-1-1"></a>InitBuffer関数</h5>
<p>InitBuffer関数では、計算に必要なデータを格納するRenderTextureを作成します。位置と、一つ前のタイムステップにおける位置については、それぞれ、一つ前のタイムステップにおけるデータを使用し、それをもとに計算を行うので、読み込み用と書き込み用に2つ作成します。このように、読み込み用のデータと書き込み用のデータを作成し、効率良くシェーダに計算させる手法を、<strong>Ping Pong Buffering</strong>と呼びます。</p>
<p>RenderTextureの作成ですが、formatでは、テクスチャの精度（チャンネル数やそれぞれのチャンネルのbit数）を設定します。一般には低い方が処理は高速になりますが、ARGBHalf（チャンネルあたり16bit）では精度が低く、計算結果が不安定になるので、ARGBFloat（チャンネルあたり32bit）に設定します。また、ComputeShaderで計算結果の書き込みを可能にするため、enableRandomWriteは、trueにします。RenderTextureは、コンストラクタの呼び出しだけではハードウェア上に作成されないので、Create関数を実行し、シェーダで使用できる状態にします。</p>

<h5><a id="h3-4-1-1-2"></a>ResetBuffer関数</h5>
<p>ResetBuffer関数では、シミュレーションに必要なデータを格納するRenderTextureを初期化します。カーネルIDの取得、スレッドグループ数の計算、布の長さなど各種パラメータ、計算に使用するRenderTextureのセットをComputeShaderに対して行い、Kernels.compute内に書かれたCSInitカーネルを呼び出して処理を行います。CSInitカーネルの内容については、次のKernels.computeの詳細の中で説明します。</p>

<h5><a id="h3-4-1-1-3"></a>Simulation関数</h5>
<p>Simulation関数は、実際の布のシミュレーションを行います。冒頭では、ResetBuffer関数同様、カーネルIDの取得、スレッドグループ数の計算、シミュレーションに使用する各種パラメータやRenderTextureのセットを行います。一度に大きなタイムステップで計算すると、シミュレーションが不安定になるので、Update()内で、タイムステップを小さな値に細かく分けて、シミュレーションを何回かに分割して安定して計算できるようにしています。反復回数については、<strong>VerletIterationNum</strong>で設定します。</p>

<h4><a id="h3-4-1-2"></a>Kernels.compute</h4>
<p>実際のシミュレーションなどの処理を記述したComputeShaderです。</p>
<p>このComputeShaderには、</p>
<ol>
<li>CSInit</li>
<li>CSSimulation</li>
</ol>
<p>の二つのカーネルがあります。</p>
<p>カーネルは、それぞれ以下のような処理を行います。</p>

<h5><a id="h3-4-1-2-1"></a>CSInit</h5>
<p>位置と法線の初期値の計算を行います。質点の位置については、スレッドのID（2次元）をもとに、X-Y平面上に格子状に配置されるように計算します。</p>

<h5><a id="h3-4-1-2-2"></a>CSSimulation</h5>
<p>シミュレーションを行います。CSSimulationカーネルの処理の流れを概略的に示すと下記の図のようになります。</p>
<div id="gcs_compute_shader_flow" class="image">
<img src="./Chapter 3 _ GPU-Based Cloth Simulation_files/gcs_compute_shader_flow.png" alt="Calculation flow in CSSimulation kernel">
<p class="caption">
図3.7: CSSimulationカーネルにおける計算の流れ
</p>
</div>
<p>以下、コードを示します。</p>
<div class="emlist-code">
<pre class="emlist">#pragma kernel CSInit<font></font>
#pragma kernel CSSimulation<font></font>
<font></font>
#define NUM_THREADS_XY 32 // カーネルのスレッド数<font></font>
<font></font>
// 位置データ（1つ前のタイムステップ）読み込み用<font></font>
Texture2D&lt;float4&gt;   _PositionPrevBufferRO;<font></font>
// 位置データ 読み込み用<font></font>
Texture2D&lt;float4&gt;   _PositionBufferRO;<font></font>
// 位置データ（1つ前のタイムステップ）書き込み用<font></font>
RWTexture2D&lt;float4&gt; _PositionPrevBufferRW;<font></font>
// 位置データ 書き込み用<font></font>
RWTexture2D&lt;float4&gt; _PositionBufferRW;<font></font>
// 法線データ 書き込み用<font></font>
RWTexture2D&lt;float4&gt; _NormalBufferRW;<font></font>
<font></font>
int2   _ClothResolution;  // 布の解像度（パーティクル数）（横, 縦）<font></font>
float2 _TotalClothLength; // 布の総合的な長さ<font></font>
<font></font>
float  _RestLength;       // バネの自然長<font></font>
<font></font>
float3 _Gravity;          // 重力<font></font>
float  _Stiffness;        // 布の伸縮度合いを決定する定数<font></font>
float  _Damp;             // 布の速度の減衰率<font></font>
float  _InverseMass;      // 1.0/質量<font></font>
<font></font>
float  _TimeStep;         // タイムステップの大きさ<font></font>
<font></font>
bool   _EnableCollideSphere; // 衝突処理を行うかのフラグ<font></font>
float4 _CollideSphereParams; // 衝突処理用パラメータ（pos.xyz, radius）<font></font>
<font></font>
// 近傍のパーティクルのIDオフセット（x, y）の配列<font></font>
static const int2 m_Directions[12] =<font></font>
{<font></font>
    int2(-1, -1), //  0<font></font>
    int2( 0, -1), //  1<font></font>
    int2( 1, -1), //  2<font></font>
    int2( 1,  0), //  3<font></font>
    int2( 1,  1), //  4<font></font>
    int2( 0,  1), //  5<font></font>
    int2(-1,  1), //  6<font></font>
    int2(-1,  0), //  7<font></font>
    int2(-2, -2), //  8<font></font>
    int2( 2, -2), //  9<font></font>
    int2( 2,  2), // 10<font></font>
    int2(-2,  2)  // 11<font></font>
};<font></font>
// 近傍のパーティクルのIDのオフセットを返す<font></font>
int2 NextNeigh(int n)<font></font>
{<font></font>
    return m_Directions[n];<font></font>
}<font></font>
<font></font>
// シミュレーション用バッファの初期化を行うカーネル<font></font>
[numthreads(NUM_THREADS_XY, NUM_THREADS_XY, 1)]<font></font>
void CSInit(uint3 DTid : SV_DispatchThreadID)<font></font>
{<font></font>
    uint2 idx = DTid.xy;<font></font>
<font></font>
    // 位置<font></font>
    float3 pos = float3(idx.x * _RestLength, idx.y * _RestLength, 0);<font></font>
    pos.xy -= _TotalClothLength.xy * 0.5;<font></font>
    // 法線<font></font>
    float3 nrm = float3(0, 0, -1);<font></font>
    // バッファに書き込み<font></font>
    _PositionPrevBufferRW[idx] = float4(pos.xyz, 1.0);<font></font>
    _PositionBufferRW[idx]     = float4(pos.xyz, 1.0);<font></font>
    _NormalBufferRW[idx]       = float4(nrm.xyz, 1.0);<font></font>
}<font></font>
<font></font>
// シミュレーションを行うカーネル<font></font>
[numthreads(NUM_THREADS_XY, NUM_THREADS_XY, 1)]<font></font>
void CSSimulation(uint2 DTid : SV_DispatchThreadID)<font></font>
{<font></font>
    int2 idx = (int2)DTid.xy;<font></font>
    // 布の解像度（パーティクル数）（横, 縦）<font></font>
    int2   res = _ClothResolution.xy;<font></font>
    // 位置を読み込み<font></font>
    float3 pos = _PositionBufferRO[idx.xy].xyz;<font></font>
    // 位置（ひとつ前のタイムステップ）の読み込み<font></font>
    float3 posPrev = _PositionPrevBufferRO[idx.xy].xyz;<font></font>
    // 位置とひとつ前のタイムステップの位置より, 速度を計算<font></font>
    float3 vel = (pos - posPrev) / _TimeStep;<font></font>
<font></font>
    float3 normal   = (float3)0; // 法線<font></font>
    float3 lastDiff = (float3)0; // 法線計算時に使用する方向ベクトル格納用変数<font></font>
    float  iters    = 0.0;       // 法線計算時のイテレーション数加算用変数<font></font>
<font></font>
    // パーティクルにかかる力, 初期値として重力の値を代入<font></font>
    float3 force = _Gravity.xyz;<font></font>
    // 1.0 / 質量<font></font>
    float  invMass = _InverseMass;<font></font>
<font></font>
    // 布の上辺であれば位置を固定するために計算しない<font></font>
    if (idx.y == _ClothResolution.y - 1)<font></font>
        return;<font></font>
<font></font>
    // 近傍のパーティクル（12個）についての計算を行う<font></font>
    [unroll]<font></font>
    for (int k = 0; k &lt; 12; k++)<font></font>
    {<font></font>
        // 近傍パーティクルのID（座標）のオフセット<font></font>
        int2 neighCoord = NextNeigh(k);<font></font>
        // X軸, 端のパーティクルについては計算しない<font></font>
        if (((idx.x+neighCoord.x) &lt; 0) || ((idx.x+neighCoord.x) &gt; (res.x-1)))<font></font>
            continue;<font></font>
        // Y軸, 端のパーティクルについては計算しない<font></font>
        if (((idx.y+neighCoord.y) &lt; 0) || ((idx.y+neighCoord.y) &gt; (res.y-1)))<font></font>
            continue;<font></font>
        // 近傍のパーティクルのID<font></font>
        int2   idxNeigh = int2(idx.x + neighCoord.x, idx.y + neighCoord.y);<font></font>
        // 近傍のパーティクルの位置<font></font>
        float3 posNeigh = _PositionBufferRO[idxNeigh].xyz;<font></font>
        // 近傍のパーティクルの位置の差<font></font>
        float3 posDiff = posNeigh - pos;<font></font>
<font></font>
        // 法線の計算<font></font>
        // 基点から近傍のパーティクルへの方向ベクトル<font></font>
        float3 currDiff = normalize(posDiff);<font></font>
        if ((iters &gt; 0.0) &amp;&amp; (k &lt; 8))<font></font>
        {<font></font>
            // 1つ前に調べた近傍パーティクルとの方向ベクトルと<font></font>
            // 現在のものの角度が鈍角であれば<font></font>
            float a = dot(currDiff, lastDiff);<font></font>
            if (a &gt; 0.0) {<font></font>
                // 外積による直行するベクトルを求めて加算<font></font>
                normal += cross(lastDiff, currDiff);<font></font>
            }<font></font>
        }<font></font>
        lastDiff = currDiff; // 次の近傍パーティクルとの計算時のために保持<font></font>
<font></font>
        // 近傍パーティクルとのバネの自然長を計算<font></font>
        float  restLength = length(neighCoord * _RestLength);<font></font>
        // バネの力を計算<font></font>
        force += (currDiff*(length(posDiff)-restLength))*_Stiffness-vel*_Damp;<font></font>
        // 加算<font></font>
        if (k &lt; 8) iters += 1.0;<font></font>
    }<font></font>
    // 法線ベクトルを計算<font></font>
    normal = normalize(normal / -(iters - 1.0));<font></font>
<font></font>
    // 加速度<font></font>
    float3 acc = (float3)0.0;<font></font>
    // 運動の法則を適用（加速度の大きさは,力の大きさに比例し質量に反比例する）<font></font>
    acc = force * invMass;<font></font>
<font></font>
    // ベレ法による位置計算<font></font>
    float3 tmp = pos;<font></font>
    pos = pos * 2.0 - posPrev + acc * (_TimeStep * _TimeStep);<font></font>
    posPrev = tmp; // ひとつ前のタイムステップの位置<font></font>
<font></font>
    // 衝突を計算<font></font>
    if (_EnableCollideSphere)<font></font>
    {<font></font>
        float3 center = _CollideSphereParams.xyz; // 中心位置<font></font>
        float  radius = _CollideSphereParams.w;   // 半径<font></font>
<font></font>
        if (length(pos - center) &lt; radius)<font></font>
        {<font></font>
            // 衝突球の中心から,布のパーティクルの位置への単位ベクトルを計算<font></font>
            float3 collDir = normalize(pos - center);<font></font>
            // 衝突球の表面にパーティクルの位置を移動<font></font>
            pos = center + collDir * radius;<font></font>
        }<font></font>
    }<font></font>
<font></font>
    // 書き込み<font></font>
    _PositionBufferRW[idx.xy]     = float4(pos.xyz,     1.0);<font></font>
    _PositionPrevBufferRW[idx.xy] = float4(posPrev.xyz, 1.0);<font></font>
    _NormalBufferRW[idx.xy]       = float4(normal.xyz,  1.0);<font></font>
}<font></font>
<font></font>
</pre>
</div>

<h4><a id="h3-4-1-3"></a>GPUClothRenderer.cs</h4>
<p>このコンポーネントでは、</p>
<ol>
<li>MeshRendererを取得、または作成</li>
<li>布のシミュレーションの解像度と一致したMeshオブジェクトを生成</li>
<li>Meshを描画するマテリアルに、シミュレーション結果（位置, 法線）を代入</li>
</ol>
<p>を行います。</p>
<p>詳細はサンプルコードをご確認ください。</p>

<h4><a id="h3-4-1-4"></a>ClothSurface.shader</h4>
<p>このシェーダでは、シミュレーションによって得られた位置、法線データを頂点シェーダ内で取得し、頂点の書き換えることによって、Meshの形状を変化させます。</p>
<p>詳細はサンプルコードをご確認ください</p>

<h3><a id="h3-4-2"></a><span class="secno">3.4.2　</span>実行結果</h3>
<p>実行をすると、球に対して衝突をする布のような動きをするオブジェクトが確認できます。シミュレーションに用いる各種パラメータを変更すると、動き方の変化がみられます。</p>
<p><strong>TimeStep</strong>は、Update関数が1回実行されるときに進むシミュレーションの時間です。大きくすると、動きの変化が大きくなりますが、大きすぎる値を設定すると、シミュレーションが不安定になり、値が発散してしまいます。</p>
<p><strong>VerletIterationNum</strong>は、Simulation関数内で実行するCSSimulationカーネルの回数で、同じタイムステップの値でも、この値を大きくするとシミュレーションは安定しやすくなりますが、計算負荷は増大してしまいます。</p>
<p><strong>ClothResolution</strong>は、布の解像度です。大きくすると、しわなどのディティールが多く見られるようになりますが、大きくしすぎるとシミュレーションが不安定になります。ComputeShader上で、スレッドサイズを32で設定しているので32の倍数であることが望ましいです。</p>
<p><strong>RestLength</strong>は、バネの自然長です。バネ同士の距離になりますので、布の長さはClothResolution × RestLengthとなります。</p>
<p><strong>Stiffness</strong>は、バネの硬さです。この値を大きくすると、布の伸縮が小さくなりますが、あまり大きくするとシミュレーションが不安定になります。</p>
<p><strong>Damp</strong>は、バネの動く速度の減衰値です。この値を大きくすると、質点が速く動かなくなるようになり振動しにくくなりますが、変化が小さくなってしまいます。</p>
<p><strong>Mass</strong>は、質点の質量です。この値を大きくすると、布が重たくなったような大きな動きをするようになります。</p>
<p><strong>Gravity</strong>は、布にかかる重力です。布の加速度は、この重力とバネの力が合わさったものとなります。</p>
<p><strong>EnableDebugOnGUI</strong>のチェックを入れると、スクリーンの左上に確認用に、シミュレーションの結果である位置・一つ前のタイムステップにおける位置・法線のデータを格納したテクスチャが描画されるようになっています。</p>
<p><strong>R</strong>キーを押すと、布を初期状態に戻るようにしています。シミュレーションが不安定になり、値が発散してしまったときは初期状態に戻すようにしてください。</p>
<div id="gcs_result_debug_on_gui" class="image">
<img src="./Chapter 3 _ GPU-Based Cloth Simulation_files/gcs_result_debug_on_gui.png" alt="Execution result (calculation result RenderTexture is drawn in screen space)">
<p class="caption">
図3.8: 実行結果（計算結果RenderTextureをスクリーンスペースに描画）
</p>
</div>

<h4><a id="h3-4-2-1"></a>デバッグとしてスプリングを描画</h4>
<p>Assets/GPUClothSimulation/Debug/<strong>GPUClothSimulationDebugRender.unity</strong>を開くと、質点と質点間を接続したバネをパーティクルとラインで描画したものが確認できます。</p>
<div id="gcs_debug_draw_spring" class="image">
<img src="./Chapter 3 _ GPU-Based Cloth Simulation_files/gcs_debug_draw_spring.png" alt="Draw mass points and springs with particles and lines">
<p class="caption">
図3.9: 質点とバネをパーティクルとラインで描画
</p>
</div>

<h2><a id="h3-5"></a><span class="secno">3.5　</span>まとめ</h2>
<p>質点-バネ系のシミュレーションで得られる動きは、力の加え方によっては複雑に変化し、面白い形状が作成できます。この章で紹介した布シミュレーションは非常に単純なものです。球のような単純なものではなく複雑なジオメトリのオブジェクトとの衝突、布同士の衝突、摩擦、布の繊維構造の考慮、大きなタイムステップをとったときのシミュレーションの安定性など、様々な課題を克服するために、多くの研究がなされています。物理エンジンに興味のある方は追究してみてはいかがでしょうか。</p>

<h2><a id="h3-6"></a><span class="secno">3.6　</span>参考</h2>
<ul>
<li>[1] Marco Fratarcangeli, "Game Engine Gems 2, GPGPU Cloth simulation using GLSL, OpenCL, and CUDA", (参照 2019-04-06) - <a href="http://www.cse.chalmers.se/~marcof/publication/geg2011/" class="link">http://www.cse.chalmers.se/~marcof/publication/geg2011/</a></li>
<li>[2] Wikipedia - Verlet integration, (参照 2019-04-06) -<a href="https://en.wikipedia.org/wiki/Verlet_integration" class="link">https://en.wikipedia.org/wiki/Verlet_integration</a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3] Makoto Fujisawa, Basics of Physical Simulation for CG, Mynavi Corporation, 2013</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[4] Yukiichi Sakai, Physical Simulation by WebGL, Engineering Co., Ltd., 2014</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[5] Koichi Sakai, Introduction to Dynamic Animation Made with OpenGL, Morikita Publishing Co., Ltd., 2005</font></font></li>
</ul><div id="goog-gt-tt" class="skiptranslate" dir="ltr"><div style="padding: 8px;"><div><div class="logo"><img src="./Chapter 3 _ GPU-Based Cloth Simulation_files/translate_24dp.png" width="20" height="20" alt="Google Translate"></div></div></div><div class="top" style="padding: 8px; float: left; width: 100%;"><h1 class="title gray">Original text</h1></div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">Contribute a better translation</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div>


<div class="goog-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div><iframe frameborder="0" class="goog-te-menu-frame skiptranslate" title="Language Translate Widget" style="visibility: visible; box-sizing: content-box; width: 1001px; height: 263px; display: none;" src="./Chapter 3 _ GPU-Based Cloth Simulation_files/saved_resource(1).html"></iframe><iframe frameborder="0" class="goog-te-menu-frame skiptranslate" title="Language Translate Widget" style="visibility: visible; box-sizing: content-box; width: 197px; height: 69px; display: none;" src="./Chapter 3 _ GPU-Based Cloth Simulation_files/saved_resource(2).html"></iframe></body></html>