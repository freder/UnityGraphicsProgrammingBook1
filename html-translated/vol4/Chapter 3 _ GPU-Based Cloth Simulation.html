<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="en" class="translated-ltr" style="height: 100%;"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <link rel="stylesheet" type="text/css" href="./Chapter 3 _ GPU-Based Cloth Simulation_files/style.scss">
  <meta name="generator" content="Re:VIEW">
  <title>GPU-Based Cloth Simulation</title>

			<style>
				img {
					max-width: 80vw;
					max-height: 80vh;
				}
			</style><style>
					.goog-te-banner-frame {
						display: none;
					}
				</style>
			<script>(function(){(function injection() {
  var pageLang = 'ja';
  var userLang = 'en';

  var uid = '1E07F158C6FA4460B352973E9693B329';
  var teId = 'TE_' + uid;
  var cbId = 'TECB_' + uid;

  function show() {
    window.setTimeout(function() {
      window[teId].showBanner(true);
    }, 10);
  }

  function newElem() {
    
  }

  if (window[teId]) {
    show();
  } else {
    if (!window.google || !google.translate ||
        !google.translate.TranslateElement) {
      if (!window[cbId]) {
        window[cbId] = function() {
          window[teId] = newElem();
          show();
        };
      }
      
    }
  }
})();})();</script><script src="https://translate.google.com/translate_a/element.js?cb=TECB_1E07F158C6FA4460B352973E9693B329&amp;client=tee&amp;hl=en"></script><script src="./Chapter 3 _ GPU-Based Cloth Simulation_files/f.txt"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://translate.googleapis.com/translate_static/css/translateelement.css"><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/translate_static/js/element/main.js"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="./Chapter 3 _ GPU-Based Cloth Simulation_files/translateelement.css"><script type="text/javascript" charset="UTF-8" src="./Chapter 3 _ GPU-Based Cloth Simulation_files/main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script><script type="text/javascript" charset="UTF-8" src="./Chapter 3 _ GPU-Based Cloth Simulation_files/element_main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://translate.googleapis.com/translate_static/css/translateelement.css"><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/translate_static/js/element/main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script></head>
		
<body style="position: relative; min-height: 100%; top: 40px;"><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div>
<h1><a id="h3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chapter 3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GPU-Based Cloth Simulation</font></font></h1>

<h2><a id="h3-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Introduction</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simulation of the shape of a planar object that is deformed by an external force such as a flag or clothes </font><font style="vertical-align: inherit;">is called </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cloth Simulation</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and much research has been done in the CG field as it is essential for animation creation. .. </font><font style="vertical-align: inherit;">Already implemented in Unity, this chapter introduces a simple cloth simulation theory and GPU implementation for the purpose of learning parallel computing using GPU and understanding the nature of simulation and the meaning of parameters. I will do it.</font></font></p>
<div id="gcs_result" class="image">
<img src="./Chapter 3 _ GPU-Based Cloth Simulation_files/gcs_result.png" alt="Cloth simulation">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.1: Cloth simulation
</font></font></p>
</div>

<h2><a id="h3-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithm explanation</font></font></h2>

<h3><a id="h3-2-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mass-Spring System</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An object such as a spring, rubber, or cushion that deforms when a force is applied and returns to its original shape when the force is stopped is called an </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elastic body</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Since such elastic bodies cannot be represented by a single position or orientation, they represent an object by points and connections between them, and the movement of each point simulates the entire shape. </font><font style="vertical-align: inherit;">This point is called a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mass point</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and is considered to be a mass of mass without size. </font><font style="vertical-align: inherit;">In addition, the connection between mass points has the property of a spring. </font><font style="vertical-align: inherit;">The method of simulating an elastic body by calculating the expansion and contraction of each spring is called the mass-spring system, and it is a flag by calculating the motion of a set of mass points arranged in a two-dimensional shape. Simulation of clothes etc. is called Cloth Simulation.</font></font></p>
<div id="gcs_mass-spring_system" class="image">
<img src="./Chapter 3 _ GPU-Based Cloth Simulation_files/gcs_mass-spring_system.png" alt="Mass point-Spring system">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.2: Mass-Spring system
</font></font></p>
</div>

<h3><a id="h3-2-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithm used for cloth simulation</font></font></h3>

<h4><a id="h3-2-2-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring force</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each spring applies a force to the connected mass points according to the following equation.</font></font></p>
<div class="equation">
<pre>F_{spring} = -k \left( I-I_{0} \right) - b v
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the current length of the spring (distance between the connected mass </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">points</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), and </font><span class="equation"><font style="vertical-align: inherit;">I_ {0}</font></span><font style="vertical-align: inherit;"> is the natural length of the spring at the start of the simulation (the length when no load is applied to the spring). ). </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a constant that represents the hardness of the spring, </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the velocity of the mass point, and </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the constant that determines the degree of velocity attenuation. </font><font style="vertical-align: inherit;">This equation means that the spring always exerts a force that tries to return the distance between the connected mass points to the initial natural length of the spring. </font><font style="vertical-align: inherit;">If the current distance of the spring is significantly different from the natural length of the spring, a larger force will be applied and it will be attenuated in proportion to the current velocity of the mass point.</font></font></p>
<div id="gcs_force_spring" class="image">
<img src="./Chapter 3 _ GPU-Based Cloth Simulation_files/gcs_force_spring.png" alt="Spring force">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.3: Spring force
</font></font></p>
</div>

<h4><a id="h3-2-2-2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring structure</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this simulation, the springs that make up the basic structure are connected in the horizontal and vertical directions, and the springs are also connected between the mass points located diagonally to prevent extreme deviation in the diagonal direction. </font><font style="vertical-align: inherit;">They are called Structure Spring and Shear Spring, respectively, and one mass point connects the spring to 12 adjacent mass points, respectively.</font></font></p>
<div id="gcs_spring_structure" class="image">
<img src="./Chapter 3 _ GPU-Based Cloth Simulation_files/gcs_spring_structure.png" alt="Spring structure">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.4: Spring structure
</font></font></p>
</div>

<h4><a id="h3-2-2-3"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Position calculation by Verlet Method</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this simulation, the position of the mass point is calculated by the Verlet method, which is a method often used in real-time applications. </font><font style="vertical-align: inherit;">The Verlet method is one of the numerical solutions of Newton's equation of motion, and is a method used in molecular dynamics to calculate the movement of atoms. </font><font style="vertical-align: inherit;">In calculating the motion of the object, but usually seek position from the speed, the Belle method, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the current position</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the position of the previous time step</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the position at the next time step</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will seek.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The derivation of the Verlet algebraic equation is shown below. </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the force applied to </font><font style="vertical-align: inherit;">the mass point </font><font style="vertical-align: inherit;">, </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the mass of the mass point, </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the velocity, </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the position, </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the time, and </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ Delta t</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the time step of the simulation (how much time is advanced per simulation calculation). ) Then, the equation of motion of the mass point is</font></font></p>
<div class="equation">
<pre>m\dfrac {d^{2}x\left( t\right) }{dt^{2}}=F
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Can be written. </font><font style="vertical-align: inherit;">If this equation of motion is made into an algebraic equation using the following two Taylor expansions,</font></font></p>
<div class="equation">
<pre>x\left( t+\Delta t\right) =x\left( t\right) +\Delta t\dfrac {dx\left( t\right) }{dt}+\dfrac {1}{2!}\Delta t^{2}\dfrac {dx^{2}\left( t\right) }{dt^{2}}+\dfrac {1}{3!}\Delta t^{3}\dfrac {dx^{3}\left( t\right) }{dt^{3}}+\ldots
</pre>
</div>
<div class="equation">
<pre>x\left( t-\Delta t\right) =x\left( t\right) -\Delta t\dfrac {dx\left( t\right) }{dt}+\dfrac {1}{2!}\Delta t^{2}\dfrac {dx^{2}\left( t\right) }{dt^{2}}-\dfrac {1}{3!}\Delta t^{3}\dfrac {dx^{3}\left( t\right) }{dt^{3}}+\ldots
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It will be. </font><font style="vertical-align: inherit;">From these two Taylor expansion equations, if we solve the second-order derivative term </font><font style="vertical-align: inherit;">and ignore the terms of </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ Delta t</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> of the second order or higher as sufficiently small, we can write as follows.</font></font></p>
<div class="equation">
<pre>\dfrac {dx^{2}\left( t\right) }{dt^{2}}=\dfrac {x\left( t+\Delta t\right) -2x\left( t\right) +x\left( t-\Delta t\right) }{\Delta t^{2}}<br>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the second-order differential term is </font><font style="vertical-align: inherit;">expressed </font><font style="vertical-align: inherit;">by mass </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and force </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from the equation of motion </font><font style="vertical-align: inherit;">,</font></font></p>
<div class="equation">
<pre>x\left( t+\Delta t\right) =2x\left( t\right) -x\left( t-\Delta t\right) +\dfrac {\Delta t^{2}}{m}F\left( t\right)
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The algebraic equation is obtained. </font><font style="vertical-align: inherit;">In this way, the formula for calculating the position in the next time step from the current position, the position in the previous time step, the mass, the force, and the value of the time step can be obtained.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The speed is calculated from the current position and the previous position in time.</font></font></p>
<div class="equation">
<pre>v\left( t\right) =\dfrac {x\left( t\right) -x\left( t-\Delta t\right) }{\Delta t}
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The speed obtained by this calculation is not very accurate, but it is not a problem as it is only used to calculate the damping of the spring.</font></font></p>

<h4><a id="h3-2-2-4"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Collision calculation</font></font></h4>

<h5><a id="h3-2-2-4-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculating the collision of cloth and sphere</font></font></h5>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Collision processing is performed in two phases: "collision detection" and "reaction to it".</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Collision detection is performed by the following formula.</font></font></p>
<div class="equation">
<pre>\left\| x\left( t+\Delta t\right) -c\right\| -r &lt; 0
</pre>
</div>
<p><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are the sphere of </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">center</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">radius</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , x </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ left (t + \ Delta t \. right)</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the position at the next time step is determined by Belle method. </font><font style="vertical-align: inherit;">If a collision is detected, move the mass point onto the surface of the sphere to prevent the sphere from colliding with the cloth. </font><font style="vertical-align: inherit;">Specifically, this is done by shifting the mass points inside the sphere in the direction normal to the surface of the collision point. </font><font style="vertical-align: inherit;">The position of the mass point is updated according to the following formula.</font></font></p>
<div class="equation">
<pre>\begin{aligned}<font></font>
d=\dfrac {x\left( t+\Delta t\right) -c}{\left\| x\left( t+\Delta t\right) -c\right\|}<font></font>
\\<font></font>
x^{\prime}\left(t + \Delta t\right) = c + dr<font></font>
\end{aligned}<font></font>
</pre>
</div>
<p><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x ^ {\ prime} \ left (t + \ Delta t \ right)</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the updated position after the collision. </font></font><span class="equation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> can be regarded as an approximation of the acceptable accuracy of the normal to the surface at the collision point, provided that the mass does not penetrate deeply.</font></font></p>
<div id="gcs_collision_sphere" class="image">
<img src="./Chapter 3 _ GPU-Based Cloth Simulation_files/gcs_collision_sphere.png" alt="Collision calculation">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.5: Collision calculation
</font></font></p>
</div>

<h2><a id="h3-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sample program</font></font></h2>

<h3><a id="h3-3-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Repository</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The sample program is in the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assets / GPUClothSimulation</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> folder in the </font><font style="vertical-align: inherit;">repository below </font><font style="vertical-align: inherit;">.</font></font></p>
<p><a href="https://github.com/IndieVisualLab/UnityGraphicsProgramming4" class="link">https://github.com/IndieVisualLab/UnityGraphicsProgramming4</a></p>

<h4><a id="h3-3-1-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Execution condition</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This sample program uses the Compute Shader. </font><font style="vertical-align: inherit;">Please check here for the operating environment of Compute Shader.</font></font></p>
<p><a href="https://docs.unity3d.com/ja/2018.3/Manual/class-ComputeShader.html" class="link">https://docs.unity3d.com/ja/2018.3/Manual/class-ComputeShader.html</a></p>

<h2><a id="h3-4"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.4　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implementation description</font></font></h2>

<h3><a id="h3-4-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.4.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Outline of processing</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is a schematic diagram showing how each component and code work in relation to each other.</font></font></p>
<div id="gcs_calculation_flow" class="image">
<img src="./Chapter 3 _ GPU-Based Cloth Simulation_files/gcs_calculation_flow.png" alt="Structure and processing flow of each component and code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.6: Structure and processing flow of each component and code
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUClothSimulation.cs is a C # script that manages the data and processing used for simulation. </font><font style="vertical-align: inherit;">This script creates and manages position and normal data used for simulation in RenderTexture format. </font><font style="vertical-align: inherit;">In addition, processing is performed by calling the kernel described in Kernels.compute. </font><font style="vertical-align: inherit;">The GPUClothRenderer.cs script provides visualization of the calculation results. </font><font style="vertical-align: inherit;">The Mesh object generated by this script is drawn by transforming the geometry by the processing of ClothSurface.shader that refers to the RenderTexture that stores the position data and normal data that are the calculation results.</font></font></p>

<h4><a id="h3-4-1-1"></a>GPUClothSimulation.cs</h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A C # script that controls the simulation.</font></font></p>
<div class="emlist-code">
<pre class="emlist">using System.Collections;<font></font>
using System.Collections.Generic;<font></font>
using UnityEngine;<font></font>
<font></font>
public class GPUClothSimulation : MonoBehaviour<font></font>
{<font></font>
    [Header("Simulation Parameters")]<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Time step</font></font><font></font>
    public float   TimeStep = 0.01f;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Number of simulation iterations</font></font><font></font>
    [Range(1, 16)]<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public int VerletIterationNum = 4;</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Cloth resolution (horizontal, vertical)</font></font><font></font>
    public Vector2Int ClothResolution = new Vector2Int(128, 128);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Cloth grid spacing (natural length of spring)</font></font><font></font>
    public float   RestLength = 0.02f;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Constants that determine the elasticity of the fabric</font></font><font></font>
    public float   Stiffness = 10000.0f;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Velocity decay constant</font></font><font></font>
    public float   Damp = 0.996f;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // quality</font></font><font></font>
    public float   Mass = 1.0f;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // gravity</font></font><font></font>
    public Vector3 Gravity = new Vector3(0.0f, -9.81f, 0.0f);<font></font>
<font></font>
    [Header("References")]<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Reference to Transform of collision sphere</font></font><font></font>
    public Transform CollisionSphereTransform;<font></font>
    [Header("Resources")]<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Kernel to simulate</font></font><font></font>
    public ComputeShader KernelCS;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Cloth simulation position data buffer</font></font><font></font>
    private RenderTexture[] _posBuff;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Cloth simulation position data (previous time step) buffer</font></font><font></font>
    private RenderTexture[] _posPrevBuff;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Cloth simulation normal data buffer</font></font><font></font>
    private RenderTexture _normBuff;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Cloth length (horizontal, vertical)</font></font><font></font>
    private Vector2 _totalClothLength;<font></font>
<font></font>
    [Header("Debug")]<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Show simulation buffer for debugging</font></font><font></font>
    public bool EnableDebugOnGUI = true;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Buffer display scale during debug display</font></font><font></font>
    private float _debugOnGUIScale = 1.0f;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Did you initialize the simulation resource?</font></font><font></font>
    public bool IsInit { private set; get; }<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Get the position data buffer</font></font><font></font>
    public RenderTexture GetPositionBuffer()<font></font>
    {<font></font>
        return this.IsInit ? _posBuff[0] : null;<font></font>
    }<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Get a buffer of normal data</font></font><font></font>
    public RenderTexture GetNormalBuffer()<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    {</font></font></font></font><font></font>
        return this.IsInit ? _normBuff : null;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Get the resolution of the cloth</font></font><font></font>
    public Vector2Int GetClothResolution()<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    {</font></font></font></font><font></font>
        return ClothResolution;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Number of X, Y dimensional threads in the Compute Shader kernel</font></font><font></font>
    const int numThreadsXY = 32;<font></font>
<font></font>
    void Start()<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    {</font></font></font></font><font></font>
        var w = ClothResolution.x;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        var h = ClothResolution.y;</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        var format = RenderTextureFormat.ARGBFloat;</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        var filter = FilterMode.Point; // Prevent interpolation between texels</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Create RenderTexture to store data for simulation</font></font><font></font>
        CreateRenderTexture(ref _posBuff,     w, h, format, filter);<font></font>
        CreateRenderTexture(ref _posPrevBuff, w, h, format, filter);<font></font>
        CreateRenderTexture(ref _normBuff,    w, h, format, filter);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Reset the data for simulation</font></font><font></font>
        ResetBuffer();<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Set the initialized flag to True</font></font><font></font>
        IsInit = true;<font></font>
    }<font></font>
<font></font>
    void Update()<font></font>
    {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Press the r key to reset the simulation data</font></font><font></font>
        if (Input.GetKeyUp("r"))<font></font>
            ResetBuffer();<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Perform a simulation</font></font><font></font>
        Simulation();<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font>
<font></font>
    void OnDestroy()<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    {</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Removed RenderTexture that stores data for simulation</font></font><font></font>
        DestroyRenderTexture(ref _posBuff    );<font></font>
        DestroyRenderTexture(ref _posPrevBuff);<font></font>
        DestroyRenderTexture(ref _normBuff   );<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    void OnGUI ()</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    {</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Draw RenderTexture containing simulation data for debugging</font></font><font></font>
        DrawSimulationBufferOnGUI();<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Reset simulation data</font></font><font></font>
    void ResetBuffer()<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    {</font></font></font></font><font></font>
        ComputeShader cs = KernelCS;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Get kernel ID</font></font><font></font>
        int kernelId = cs.FindKernel("CSInit");<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Calculate the number of execution thread groups in the Compute Shader kernel</font></font><font></font>
        int groupThreadsX =<font></font>
            Mathf.CeilToInt((float)ClothResolution.x / numThreadsXY);<font></font>
        int groupThreadsY =<font></font>
            Mathf.CeilToInt((float)ClothResolution.y / numThreadsXY);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Calculation of cloth length (horizontal, vertical)</font></font><font></font>
        _totalClothLength = new Vector2(<font></font>
            RestLength * ClothResolution.x,<font></font>
            RestLength * ClothResolution.y<font></font>
        );<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Set parameters and buffers</font></font><font></font>
        cs.SetInts  ("_ClothResolution",<font></font>
            new int[2] { ClothResolution.x, ClothResolution.y });<font></font>
        cs.SetFloats("_TotalClothLength",<font></font>
            new float[2] { _totalClothLength.x, _totalClothLength.y });<font></font>
        cs.SetFloat ("_RestLength", RestLength);<font></font>
        cs.SetTexture(kernelId, "_PositionBufferRW",     _posBuff[0]);<font></font>
        cs.SetTexture(kernelId, "_PositionPrevBufferRW", _posPrevBuff[0]);<font></font>
        cs.SetTexture(kernelId, "_NormalBufferRW",       _normBuff);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // run the kernel</font></font><font></font>
        cs.Dispatch(kernelId, groupThreadsX, groupThreadsY, 1);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // copy the buffer</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        Graphics.Blit (_posBuff [0], _posBuff [1]);</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        Graphics.Blit (_posPrevBuff [0], _posPrevBuff [1]);</font></font></font></font><font></font>
    }<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // simulation</font></font><font></font>
    void Simulation()<font></font>
    {<font></font>
        ComputeShader cs = KernelCS;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Calculation of CSSimulation Calculation of the value of the time step per time</font></font><font></font>
        float timestep = (float)TimeStep / VerletIterationNum;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Get kernel ID</font></font><font></font>
        int kernelId = cs.FindKernel("CSSimulation");<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Calculate the number of execution thread groups in the Compute Shader kernel</font></font><font></font>
        int groupThreadsX =<font></font>
            Mathf.CeilToInt((float)ClothResolution.x / numThreadsXY);<font></font>
        int groupThreadsY =<font></font>
            Mathf.CeilToInt((float)ClothResolution.y / numThreadsXY);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // set parameters</font></font><font></font>
        cs.SetVector("_Gravity", Gravity);<font></font>
        cs.SetFloat ("_Stiffness", Stiffness);<font></font>
        cs.SetFloat ("_Damp", Damp);<font></font>
        cs.SetFloat ("_InverseMass", (float)1.0f / Mass);<font></font>
        cs.SetFloat ("_TimeStep", timestep);<font></font>
        cs.SetFloat ("_RestLength", RestLength);<font></font>
        cs.SetInts  ("_ClothResolution",<font></font>
            new int[2] { ClothResolution.x, ClothResolution.y });<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Set the parameters of the collision sphere</font></font><font></font>
        if (CollisionSphereTransform != null)<font></font>
        {<font></font>
            Vector3 collisionSpherePos = CollisionSphereTransform.position;<font></font>
            float collisionSphereRad =<font></font>
                CollisionSphereTransform.localScale.x * 0.5f + 0.01f;<font></font>
            cs.SetBool  ("_EnableCollideSphere", true);<font></font>
            cs.SetFloats("_CollideSphereParams",<font></font>
                new float[4] {<font></font>
                    collisionSpherePos.x,<font></font>
                    collisionSpherePos.y,<font></font>
                    collisionSpherePos.z,<font></font>
                    collisionSphereRad<font></font>
                });<font></font>
        }<font></font>
        else<font></font>
            cs.SetBool("_EnableCollideSphere", false);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        for (var i = 0; i &lt;VerletIterationNum; i ++)</font></font></font></font><font></font>
        {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // set the buffer</font></font><font></font>
            cs.SetTexture(kernelId, "_PositionBufferRO",     _posBuff[0]);<font></font>
            cs.SetTexture(kernelId, "_PositionPrevBufferRO", _posPrevBuff[0]);<font></font>
            cs.SetTexture(kernelId, "_PositionBufferRW",     _posBuff[1]);<font></font>
            cs.SetTexture(kernelId, "_PositionPrevBufferRW", _posPrevBuff[1]);<font></font>
            cs.SetTexture(kernelId, "_NormalBufferRW",       _normBuff);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // run thread</font></font><font></font>
            cs.Dispatch(kernelId, groupThreadsX, groupThreadsY, 1);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // Swap the read buffer and write buffer</font></font><font></font>
            SwapBuffer(ref _posBuff[0],     ref _posBuff[1]    );<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            SwapBuffer (ref _posPrevBuff [0], ref _posPrevBuff [1]);</font></font></font></font><font></font>
        }<font></font>
    }<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Create RenderTexture to store data for simulation</font></font><font></font>
    void CreateRenderTexture(ref RenderTexture buffer, int w, int h,<font></font>
        RenderTextureFormat format, FilterMode filter)<font></font>
    {<font></font>
        buffer = new RenderTexture(w, h, 0, format)<font></font>
        {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            filterMode = filter,</font></font></font></font><font></font>
            wrapMode   = TextureWrapMode.Clamp,<font></font>
            hideFlags  = HideFlags.HideAndDontSave,<font></font>
            enableRandomWrite = true<font></font>
        };<font></font>
        buffer.Create();<font></font>
    }<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Create RenderTexture [] to store data for simulation</font></font><font></font>
    void CreateRenderTexture(ref RenderTexture[] buffer, int w, int h,<font></font>
        RenderTextureFormat format, FilterMode filter)<font></font>
    {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // ~ slightly~</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Removed RenderTexture that stores data for simulation</font></font><font></font>
    void DestroyRenderTexture(ref RenderTexture buffer)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    {</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // ~ slightly~</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Remove RenderTexture [] to store data for simulation</font></font><font></font>
    void DestroyRenderTexture(ref RenderTexture[] buffer)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    {</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // ~ slightly~</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Delete material</font></font><font></font>
    void DestroyMaterial(ref Material mat)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    {</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // ~ slightly~</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Swap buffers</font></font><font></font>
    void SwapBuffer(ref RenderTexture ping, ref RenderTexture pong)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    {</font></font></font></font><font></font>
        RenderTexture temp = ping;<font></font>
        ping = pong;<font></font>
        pong = temp;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Draw a buffer for simulation in the OnGUI function for debugging</font></font><font></font>
    void DrawSimulationBufferOnGUI()<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    {</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // ~ slightly~</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font>
}<font></font>
<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the beginning, the parameters required for the simulation are declared. </font><font style="vertical-align: inherit;">In addition, RenderTexture is used to hold the simulation results. </font><font style="vertical-align: inherit;">The data used and obtained for this simulation</font></font></p>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">position</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Position in the previous time step</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normal</font></font></li>
</ol>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is.</font></font></p>

<h5><a id="h3-4-1-1-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitBuffer function</font></font></h5>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The InitBuffer function creates a RenderTexture that stores the data needed for the calculation. </font><font style="vertical-align: inherit;">For the position and the position in the previous time step, the data in the previous time step is used and the calculation is performed based on it, so create two for reading and one for writing. </font><font style="vertical-align: inherit;">In this way, the method of creating data for reading and data for writing and letting the shader calculate efficiently </font><font style="vertical-align: inherit;">is called </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ping Pong Buffering</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regarding the creation of RenderTexture, in format, the precision of the texture (the number of channels and the number of bits of each channel) is set. </font><font style="vertical-align: inherit;">Generally, the lower the value, the faster the processing, but ARGBHalf (16bit per channel) has low accuracy and the calculation result becomes unstable, so set it to ARGBFloat (32bit per channel). </font><font style="vertical-align: inherit;">Also, enableRandomWrite should be true to allow ComputeShader to write the calculation result. </font><font style="vertical-align: inherit;">RenderTexture is not created on the hardware just by calling the constructor, so execute the Create function to make it available in the shader.</font></font></p>

<h5><a id="h3-4-1-1-2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ResetBuffer function</font></font></h5>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ResetBuffer function initializes the RenderTexture that stores the data needed for the simulation. </font><font style="vertical-align: inherit;">Get kernel ID, calculate number of thread groups, set various parameters such as cloth length, RenderTexture used for calculation for Compute Shader, and call CSInit kernel written in Kernels.compute for processing. .. </font><font style="vertical-align: inherit;">The contents of the CSInit kernel are described in the following Kernels.compute details.</font></font></p>

<h5><a id="h3-4-1-1-3"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simulation function</font></font></h5>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Simulation function simulates the actual cloth. </font><font style="vertical-align: inherit;">At the beginning, like the ResetBuffer function, get the kernel ID, calculate the number of thread groups, set various parameters used for simulation and RenderTexture. </font><font style="vertical-align: inherit;">If you calculate with a large time step at a time, the simulation becomes unstable, so in Update (), divide the time step into small values ​​so that the simulation can be calculated stably by dividing it into several times. I will. </font><font style="vertical-align: inherit;">The number of iterations is </font><font style="vertical-align: inherit;">set in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VerletIterationNum</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p>

<h4><a id="h3-4-1-2"></a>Kernels.compute</h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compute Shader that describes processing such as actual simulation.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This Compute Shader has</font></font></p>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CSInit</font></font></li>
<li>CSSimulation</li>
</ol>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are two kernels.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each kernel performs the following processing.</font></font></p>

<h5><a id="h3-4-1-2-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CSInit</font></font></h5>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculates the initial values ​​of position and normal. </font><font style="vertical-align: inherit;">The position of the mass point is calculated so that it is arranged in a grid pattern on the XY plane based on the thread ID (2D).</font></font></p>

<h5><a id="h3-4-1-2-2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CSSimulation</font></font></font></font></h5>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perform a simulation. </font><font style="vertical-align: inherit;">The figure below outlines the processing flow of the CSSimulation kernel.</font></font></p>
<div id="gcs_compute_shader_flow" class="image">
<img src="./Chapter 3 _ GPU-Based Cloth Simulation_files/gcs_compute_shader_flow.png" alt="Calculation flow in CSSimulation kernel">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.7: Calculation flow in CSSimulation kernel
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The code is shown below.</font></font></p>
<div class="emlist-code">
<pre class="emlist">#pragma kernel CSInit<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
#pragma kernel CSSimulation</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
#define NUM_THREADS_XY 32 // Number of kernel threads</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// For reading position data (previous time step)</font></font><font></font>
Texture2D&lt;float4&gt;   _PositionPrevBufferRO;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// For reading position data</font></font><font></font>
Texture2D&lt;float4&gt;   _PositionBufferRO;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// For writing position data (previous time step)</font></font><font></font>
RWTexture2D&lt;float4&gt; _PositionPrevBufferRW;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// For writing position data</font></font><font></font>
RWTexture2D&lt;float4&gt; _PositionBufferRW;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// For writing normal data</font></font><font></font>
RWTexture2D&lt;float4&gt; _NormalBufferRW;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int2 _ClothResolution; // Cloth resolution (number of particles) (horizontal, vertical)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
float2 _TotalClothLength; // Overall length of the cloth</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
float _RestLength; // Natural length of the spring</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
float3 _Gravity; // Gravity</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
float _Stiffness; // Constant that determines the degree of expansion and contraction of the cloth</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
float _Damp; // Attenuation rate of cloth speed</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
float _InverseMass; // 1.0/quality</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
float _TimeStep; // Size of time step</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bool _EnableCollideSphere; // Flag for collision handling</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
float4 _CollideSphereParams; // Collision handling parameters (pos.xyz, radius)</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Array of ID offsets (x, y) of nearby particles</font></font><font></font>
static const int2 m_Directions[12] =<font></font>
{<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    int2 (-1, -1), // 0</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    int2 (0, -1), // 1</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    int2 (1, -1), // 2</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    int2 (1, 0), // 3</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    int2 (1, 1), // 4</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    int2 (0, 1), // 5</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    int2 (-1, 1), // 6</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    int2 (-1, 0), // 7</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    int2 (-2, -2), // 8</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    int2 (2, -2), // 9</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    int2 (2, 2), // 10</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    int2 (-2, 2) // 11</font></font></font></font><font></font>
};<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Returns the offset of the ID of nearby particles</font></font><font></font>
int2 NextNeigh(int n)<font></font>
{<font></font>
    return m_Directions[n];<font></font>
}<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Kernel that initializes the simulation buffer</font></font><font></font>
[numthreads(NUM_THREADS_XY, NUM_THREADS_XY, 1)]<font></font>
void CSInit(uint3 DTid : SV_DispatchThreadID)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{</font></font></font></font><font></font>
    uint2 idx = DTid.xy;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // location</font></font><font></font>
    float3 pos = float3(idx.x * _RestLength, idx.y * _RestLength, 0);<font></font>
    pos.xy -= _TotalClothLength.xy * 0.5;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // normal</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    float3 nrm = float3 (0, 0, -1);</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // write to buffer</font></font><font></font>
    _PositionPrevBufferRW[idx] = float4(pos.xyz, 1.0);<font></font>
    _PositionBufferRW[idx]     = float4(pos.xyz, 1.0);<font></font>
    _NormalBufferRW[idx]       = float4(nrm.xyz, 1.0);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Kernel to simulate</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[numthreads(NUM_THREADS_XY, NUM_THREADS_XY, 1)]</font></font><font></font>
void CSSimulation(uint2 DTid : SV_DispatchThreadID)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{</font></font></font></font><font></font>
    int2 idx = (int2)DTid.xy;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Cloth resolution (number of particles) (horizontal, vertical)</font></font><font></font>
    int2   res = _ClothResolution.xy;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // read position</font></font><font></font>
    float3 pos = _PositionBufferRO[idx.xy].xyz;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Read position (previous time step)</font></font><font></font>
    float3 posPrev = _PositionPrevBufferRO[idx.xy].xyz;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Calculate the speed from the position and the position of the previous time step</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    float3 vel = (pos - posPrev) / _TimeStep;</font></font></font></font><font></font>
<font></font>
    float3 normal   = (float3)0; // 法線<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    float3 lastDiff = (float3) 0; // Variable for storing direction vector used when calculating normal</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    float iters = 0.0; // Variable for adding the number of iterations when calculating normals</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Substitute the force applied to the particles and the value of gravity as the initial value</font></font><font></font>
    float3 force = _Gravity.xyz;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // 1.0 / quality</font></font><font></font>
    float  invMass = _InverseMass;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // If it is the top side of the cloth, do not calculate to fix the position</font></font><font></font>
    if (idx.y == _ClothResolution.y - 1)<font></font>
        return;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Calculate for nearby particles (12)</font></font><font></font>
    [unroll]<font></font>
    for (int k = 0; k &lt; 12; k++)<font></font>
    {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Offset of ID (coordinates) of neighboring particles</font></font><font></font>
        int2 neighCoord = NextNeigh(k);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Do not calculate for X-axis, edge particles</font></font><font></font>
        if (((idx.x+neighCoord.x) &lt; 0) || ((idx.x+neighCoord.x) &gt; (res.x-1)))<font></font>
            continue;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Do not calculate for Y-axis, edge particles</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        if (((idx.y + neighCoord.y) &lt;0) || ((idx.y + neighCoord.y)&gt; (res.y-1)))</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            continue;</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // ID of nearby particles</font></font><font></font>
        int2   idxNeigh = int2(idx.x + neighCoord.x, idx.y + neighCoord.y);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Position of nearby particles</font></font><font></font>
        float3 posNeigh = _PositionBufferRO[idxNeigh].xyz;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Difference in the position of nearby particles</font></font><font></font>
        float3 posDiff = posNeigh - pos;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Normal calculation</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Direction vector from the base point to nearby particles</font></font><font></font>
        float3 currDiff = normalize(posDiff);<font></font>
        if ((iters &gt; 0.0) &amp;&amp; (k &lt; 8))<font></font>
        {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // With the direction vector with the neighboring particles examined one time ago</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // If the current angle is obtuse</font></font><font></font>
            float a = dot(currDiff, lastDiff);<font></font>
            if (a &gt; 0.0) {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                // Find and add orthogonal vectors by cross product</font></font><font></font>
                normal += cross(lastDiff, currDiff);<font></font>
            }<font></font>
        }<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        lastDiff = currDiff; // Keep for calculation with next neighbor particles</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Calculate the natural length of the spring with neighboring particles</font></font><font></font>
        float  restLength = length(neighCoord * _RestLength);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Calculate the force of the spring</font></font><font></font>
        force += (currDiff*(length(posDiff)-restLength))*_Stiffness-vel*_Damp;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Addition</font></font><font></font>
        if (k &lt; 8) iters += 1.0;<font></font>
    }<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Calculate normal vector</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    normal = normalize (normal / - (iters - 1.0));</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // acceleration</font></font><font></font>
    float3 acc = (float3)0.0;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Apply the law of motion (the magnitude of acceleration is proportional to the magnitude of force and inversely proportional to mass)</font></font><font></font>
    acc = force * invMass;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Position calculation by Verlet method</font></font><font></font>
    float3 tmp = pos;<font></font>
    pos = pos * 2.0 - posPrev + acc * (_TimeStep * _TimeStep);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    posPrev = tmp; // Position of the previous time step</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Calculate collision</font></font><font></font>
    if (_EnableCollideSphere)<font></font>
    {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        float3 center = _CollideSphereParams.xyz; // Center position</font></font><font></font>
        float  radius = _CollideSphereParams.w;   // 半径<font></font>
<font></font>
        if (length(pos - center) &lt; radius)<font></font>
        {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // Calculate the unit vector from the center of the collision sphere to the position of the particles on the cloth</font></font><font></font>
            float3 collDir = normalize(pos - center);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            // Move the position of particles to the surface of the collision sphere</font></font><font></font>
            pos = center + collDir * radius;<font></font>
        }<font></font>
    }<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // write</font></font><font></font>
    _PositionBufferRW[idx.xy]     = float4(pos.xyz,     1.0);<font></font>
    _PositionPrevBufferRW[idx.xy] = float4(posPrev.xyz, 1.0);<font></font>
    _NormalBufferRW[idx.xy]       = float4(normal.xyz,  1.0);<font></font>
}<font></font>
<font></font>
</pre>
</div>

<h4><a id="h3-4-1-3"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUClothRenderer.cs</font></font></font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this component</font></font></p>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get or create MeshRenderer</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generate a Mesh object that matches the resolution of the cloth simulation</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Substitute simulation results (position, normal) for the material that draws the mesh</font></font></li>
</ol>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to hold.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Please check the sample code for details.</font></font></p>

<h4><a id="h3-4-1-4"></a>ClothSurface.shader</h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this shader, the position and normal data obtained by simulation are acquired in the vertex shader, and the shape of the mesh is changed by rewriting the vertices.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Please check the sample code for details</font></font></p>

<h3><a id="h3-4-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.4.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Execution result</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When you run it, you'll see an object that behaves like a cloth that collides with the sphere. </font><font style="vertical-align: inherit;">If you change the various parameters used in the simulation, you can see the change in the movement.</font></font></p>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TimeStep</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the time of the simulation that progresses when the Update function is executed once. </font><font style="vertical-align: inherit;">If you increase it, the change in movement will be large, but if you set a value that is too large, the simulation will become unstable and the value will diverge.</font></font></p>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VerletIterationNum</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the number of CSSimulation kernels to execute in the Simulation function. Even if the value of the same time step is increased, increasing this value will make the simulation easier to stabilize, but will increase the calculation load.</font></font></p>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ClothResolution</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the resolution of the cloth. </font><font style="vertical-align: inherit;">If you increase it, you will see many details such as wrinkles, but if you increase it too much, the simulation will become unstable. </font><font style="vertical-align: inherit;">Since the thread size is set to 32 on ComputeShader, it is desirable to be a multiple of 32.</font></font></p>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RestLength</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the natural length of the spring. </font><font style="vertical-align: inherit;">Since it is the distance between the springs, the length of the cloth is Cloth Resolution x Rest Length.</font></font></p>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stiffness</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the hardness of the spring. </font><font style="vertical-align: inherit;">Increasing this value will reduce the stretch of the fabric, but increasing it too much will make the simulation unstable.</font></font></p>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the attenuation value of the moving speed of the spring. </font><font style="vertical-align: inherit;">Increasing this value will make the mass point stagnant faster and less likely to vibrate, but will reduce the change.</font></font></p>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mass</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the mass of the mass point. </font><font style="vertical-align: inherit;">Increasing this value will cause the cloth to move as if it were heavy.</font></font></p>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gravity</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the gravity on the cloth. </font><font style="vertical-align: inherit;">The acceleration of the cloth is the combination of this gravity and the force of the spring.</font></font></p>
<p><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you check </font><strong><font style="vertical-align: inherit;">EnableDebugOnGUI</font></strong><font style="vertical-align: inherit;"> , a texture that stores the position that is the result of the simulation, the position in the previous time step, and the normal data is drawn in the upper left of the screen for confirmation.</font></font></p>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> you press the </font><strong><font style="vertical-align: inherit;">R</font></strong><font style="vertical-align: inherit;"> key, the cloth returns to its initial state. </font><font style="vertical-align: inherit;">If the simulation becomes unstable and the values ​​diverge, please return to the initial state.</font></font></p>
<div id="gcs_result_debug_on_gui" class="image">
<img src="./Chapter 3 _ GPU-Based Cloth Simulation_files/gcs_result_debug_on_gui.png" alt="Execution result (calculation result RenderTexture is drawn in screen space)">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.8: Execution result (calculation result RenderTexture is drawn in screen space)
</font></font></p>
</div>

<h4><a id="h3-4-2-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Draw springs as debug</font></font></h4>
<p><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> you open </font><font style="vertical-align: inherit;">Assets / GPUClothSimulation / Debug / </font><strong><font style="vertical-align: inherit;">GPUClothSimulationDebugRender.unity</font></strong><font style="vertical-align: inherit;"> , you can see the spring that connects the mass </font><strong><font style="vertical-align: inherit;">points</font></strong><font style="vertical-align: inherit;"> with particles and lines.</font></font></p>
<div id="gcs_debug_draw_spring" class="image">
<img src="./Chapter 3 _ GPU-Based Cloth Simulation_files/gcs_debug_draw_spring.png" alt="Draw mass points and springs with particles and lines">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3.9: Draw mass points and springs with particles and lines
</font></font></p>
</div>

<h2><a id="h3-5"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.5　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Summary</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The movement obtained by the mass point-spring system simulation changes in a complicated manner depending on how the force is applied, and an interesting shape can be created. </font><font style="vertical-align: inherit;">The cloth simulation presented in this chapter is very simple. </font><font style="vertical-align: inherit;">Challenges such as collisions with objects of complex geometry rather than simple things like spheres, collisions between cloths, friction, consideration of the fiber structure of cloths, stability of simulations when taking large time steps, etc. Much research has been done to overcome it. </font><font style="vertical-align: inherit;">If you are interested in physics engine, why not pursue it?</font></font></p>

<h2><a id="h3-6"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.6　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reference</font></font></h2>
<ul>
<li>[1] Marco Fratarcangeli, "Game Engine Gems 2, GPGPU Cloth simulation using GLSL, OpenCL, and CUDA", (参照 2019-04-06) - <a href="http://www.cse.chalmers.se/~marcof/publication/geg2011/" class="link">http://www.cse.chalmers.se/~marcof/publication/geg2011/</a></li>
<li>[2] Wikipedia - Verlet integration, (参照 2019-04-06) -<a href="https://en.wikipedia.org/wiki/Verlet_integration" class="link">https://en.wikipedia.org/wiki/Verlet_integration</a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3] Makoto Fujisawa, Basics of Physical Simulation for CG, Mynavi Corporation, 2013</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[4] Yukiichi Sakai, Physical Simulation by WebGL, Engineering Co., Ltd., 2014</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[5] Koichi Sakai, Introduction to Dynamic Animation Made with OpenGL, Morikita Publishing Co., Ltd., 2005</font></font></li>
</ul></body></html>