<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ops="http://www.idpf.org/2007/ops" xml:lang="en" class="translated-ltr" style="height: 100%;"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <link rel="stylesheet" type="text/css" href="./Chapter 1 _ GPU-Based Space Colonization Algorithm_files/style.scss">
  <meta name="generator" content="Re:VIEW">
  <title>GPU-Based Space Colonization Algorithm</title>

			<style>
				img {
					max-width: 80vw;
					max-height: 80vh;
				}
			</style><style>
					.goog-te-banner-frame {
						display: none;
					}
				</style>
			<script>(function(){(function injection() {
  var pageLang = 'ja';
  var userLang = 'en';

  var uid = '1E07F158C6FA4460B352973E9693B329';
  var teId = 'TE_' + uid;
  var cbId = 'TECB_' + uid;

  function show() {
    window.setTimeout(function() {
      window[teId].showBanner(true);
    }, 10);
  }

  function newElem() {
    
  }

  if (window[teId]) {
    show();
  } else {
    if (!window.google || !google.translate ||
        !google.translate.TranslateElement) {
      if (!window[cbId]) {
        window[cbId] = function() {
          window[teId] = newElem();
          show();
        };
      }
      
    }
  }
})();})();</script><script src="https://translate.google.com/translate_a/element.js?cb=TECB_1E07F158C6FA4460B352973E9693B329&amp;client=tee&amp;hl=en"></script><script src="./Chapter 1 _ GPU-Based Space Colonization Algorithm_files/f.txt"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://translate.googleapis.com/translate_static/css/translateelement.css"><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/translate_static/js/element/main.js"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="./Chapter 1 _ GPU-Based Space Colonization Algorithm_files/translateelement.css"><script type="text/javascript" charset="UTF-8" src="./Chapter 1 _ GPU-Based Space Colonization Algorithm_files/main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script><script type="text/javascript" charset="UTF-8" src="./Chapter 1 _ GPU-Based Space Colonization Algorithm_files/element_main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://translate.googleapis.com/translate_static/css/translateelement.css"><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/translate_static/js/element/main.js"></script><script type="text/javascript" charset="UTF-8" src="https://translate.googleapis.com/element/TE_20201130_00/e/js/element/element_main.js"></script></head>
		
<body style="position: relative; min-height: 100%; top: 40px;"><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div><div class="skiptranslate" style=""><iframe id=":0.container" class="goog-te-banner-frame skiptranslate" frameborder="0" src="javascript:''" style="visibility:visible"></iframe></div>
<h1><a id="h1"></a><span class="secno">第1章　</span>GPU-Based Space Colonization Algorithm</h1>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This chapter introduces the GPU implementation of the Space Colonization Algorithm, an algorithm that generates a shape that blanchs along a point cloud, and its application examples.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The sample in this chapter is </font><font style="vertical-align: inherit;">"Space Colonization" at </font></font><br><a href="https://github.com/IndieVisualLab/UnityGraphicsProgramming4" class="link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/IndieVisualLab/UnityGraphicsProgramming4</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p>
<div id="id_nakamura_2FSkinnedAnimationScene" class="image">
<img src="./Chapter 1 _ GPU-Based Space Colonization Algorithm_files/SkinnedAnimationScene.png" alt="SkinnedAnimation.scene">
<p class="caption">
図1.1: SkinnedAnimation.scene
</p>
</div>

<h2><a id="h1-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Introduction</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Space Colonization Algorithm was </font><font style="vertical-align: inherit;">developed by </font><font style="vertical-align: inherit;">Adam et al. </font></font><a id="fnb-Adam" href="https://freder.io/files/unity4/nakamura.html#fn-Adam" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 1 as</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a tree modeling method.</font></font></p>
<div class="footnote" epub:type="footnote" id="fn-Adam"><p class="footnote">[*1] http://algorithmicbotany.org/papers/colonization.egwnp2007.html</p></div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A method of generating a branching shape from a given point cloud,</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The branches do not stick together too much and can be blanched while being properly separated.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the arrangement of branches is determined by the initial point cloud arrangement, it is easy to control the shape.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can control the density of branches with simple parameters</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It has the feature.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This chapter introduces the GPU implementation of this algorithm and application examples combined with skinning animation.</font></font></p>

<h2><a id="h1-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithm</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, I will explain the Space Colonization Algorithm. </font><font style="vertical-align: inherit;">The general steps of the algorithm are divided as follows.</font></font></p>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setup-Initialization</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Search --Search for affected attractions</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attract-Attracting branches</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connect-Create a new node and connect to an existing node</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remove --Remove Attraction</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grow-Node Growth</font></font></li>
</ol>

<h3><a id="h1-2-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setup-Initialization</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the initialization phase, the point cloud is prepared as an attraction (point that will be the seed of the branch). </font><font style="vertical-align: inherit;">Place one or more Nodes (branch branch points) in the attraction. </font><font style="vertical-align: inherit;">This first placed Node will be the starting point for your branch.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the figure below, Attraction is represented by a round dot and Node is represented by a square dot.</font></font></p>
<div id="id_nakamura_2FStep1" class="image">
<img src="./Chapter 1 _ GPU-Based Space Colonization Algorithm_files/Step1.png" alt="Setup --Attraction and Node initialization Round dots represent Attraction and square dots represent Node.">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.2: Setup --Attraction and Node Initialization Round dots represent Attraction and square dots represent Node.
</font></font></p>
</div>

<h3><a id="h1-2-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Search-Search for affected Attractions</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For each attraction, find the closest Node within the influence distance.</font></font></p>
<div id="id_nakamura_2FStep2-gpu" class="image">
<img src="./Chapter 1 _ GPU-Based Space Colonization Algorithm_files/Step2-gpu.png" alt="Search --Search the nearest Node within the range of influence from each attraction">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.3: Search-Search for the nearest Node in the area of ​​influence from each Attraction
</font></font></p>
</div>

<h3><a id="h1-2-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Attract-Attracting branches</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For each Node, determine the direction to extend the branch based on the attraction within the range of influence, and the point beyond the extension by the growth distance is the candidate point (Candidate) for the point to generate a new Node. )will do.</font></font></p>
<div id="id_nakamura_2FStep3-gpu" class="image">
<img src="./Chapter 1 _ GPU-Based Space Colonization Algorithm_files/Step3-gpu.png" alt="Attract-Extend a branch from each Node and decide a candidate point to generate a new Node">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.4: Attract-Extend a branch from each Node and determine candidate points to generate new Nodes
</font></font></p>
</div>

<h3><a id="h1-2-4"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2.4　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Connect-Connecting a new node to an existing node</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create a new Node at the Candidate position and connect the original Node with Edge to extend the branch.</font></font></p>
<div id="id_nakamura_2FStep4" class="image">
<img src="./Chapter 1 _ GPU-Based Space Colonization Algorithm_files/Step4.png" alt="Connect-Connect a new node to an existing node to extend a branch">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.5: Connect-Connecting a new node to an existing node to extend a branch
</font></font></p>
</div>

<h3><a id="h1-2-5"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2.5</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Remove </font><span class="secno"><font style="vertical-align: inherit;">--Remove　</font></span><font style="vertical-align: inherit;"> Attraction within the removal range</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deletes an attraction that is within the kill distance from the node.</font></font></p>
<div id="id_nakamura_2FStep5__1" class="image">
<img src="./Chapter 1 _ GPU-Based Space Colonization Algorithm_files/Step5_1.png" alt="Remove --Search Node for Attractions within the removal range">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.6: Remove --Search Node for attractions within the removal range
</font></font></p>
</div>
<div id="id_nakamura_2FStep5__2" class="image">
<img src="./Chapter 1 _ GPU-Based Space Colonization Algorithm_files/Step5_2.png" alt="Remove-Removes Attraction found within the removal range">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.7: Remove-Removes Attraction found within the removal range
</font></font></p>
</div>

<h3><a id="h1-2-6"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2.6</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grow </font><span class="secno"><font style="vertical-align: inherit;">--Node　</font></span><font style="vertical-align: inherit;"> Growth</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grow Node and go back to Step.2.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The general flow of the entire algorithm is shown in the figure below.</font></font></p>
<div id="id_nakamura_2FFlow" class="image">
<img src="./Chapter 1 _ GPU-Based Space Colonization Algorithm_files/Flow.png" alt="Rough flow of the algorithm">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.8: Rough flow of the algorithm
</font></font></p>
</div>

<h2><a id="h1-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implementation</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, I will explain the concrete implementation of the algorithm.</font></font></p>

<h3><a id="h1-3-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Preparation of resources</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As an element that increases or decreases in the Space Colonization Algorithm</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attraction: Point cloud to seed the branch</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Node: Branch branch point (node)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Candidate: Candidate points for creating new nodes</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Edge: An edge that connects the nodes of a branch</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is required, but in order to express these on GPGPU, Append / ConsumeStructuredBuffer is used for some elements.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Append / ConsumeStructuredBuffer is explained in Unity Graphics Programming vol.3 "GPU-Based Cellular Growth Simulation".</font></font></p>

<h4><a id="h1-3-1-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attraction (branch seed point)</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The structure of Attraction is defined as follows.</font></font></p>
<div class="emlist-code">
<p class="caption">Attraction.cs</p>
<pre class="emlist">public struct Attraction {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public Vector3 position; // position</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public int nearest; // index of the nearest Node</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public uint found; // Whether a nearby Node was found</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public uint active; // Whether it is a valid attraction (1 is valid, 0 is deleted)</font></font><font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The increase / decrease of attraction is expressed by determining whether it is a deleted attraction by the active flag.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Space Colonization, it is necessary to prepare a point cloud of Attraction in the initialization phase. </font><font style="vertical-align: inherit;">In the sample SpaceColonization.cs, point clouds are randomly scattered inside the sphere and used as the position of Attraction.</font></font></p>
<div class="emlist-code">
<p class="caption">SpaceColonization.cs</p>
<pre class="emlist"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">    // Randomly sprinkle points inside the sphere to generate an attraction</font></font><font></font>
    var attractions = GenerateSphereAttractions();<font></font>
    count = attractions.Length;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Initialize the Attraction buffer</font></font><font></font>
    attractionBuffer = new ComputeBuffer(<font></font>
        count,<font></font>
        Marshal.SizeOf(typeof(Attraction)),<font></font>
        ComputeBufferType.Default<font></font>
    );<font></font>
    attractionBuffer.SetData(attractions);<font></font>
</pre>
</div>

<h4><a id="h1-3-1-2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Node (branch branch point)</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The structure of Node is defined as follows.</font></font></p>
<div class="emlist-code">
<p class="caption">Node.cs</p>
<pre class="emlist">public struct Node {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public Vector3 position; // position</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public float t; // Growth rate (0.0 ~ 1.0)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public float offset; // Distance from Root (Node depth)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public float mass; // mass</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public int from; // index of branch source Node</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public uint active; // Whether it is a valid Node (1 is valid)</font></font><font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Node resources</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buffer representing the actual data of Node</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A buffer that manages the index of inactive Nodes used as an object pool</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is managed by two buffers.</font></font></p>
<div class="emlist-code">
<p class="caption">SpaceColonization.cs</p>
<pre class="emlist"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">  // Actual Node data</font></font><font></font>
  nodeBuffer = new ComputeBuffer(<font></font>
    count,<font></font>
    Marshal.SizeOf(typeof(Node)),<font></font>
    ComputeBufferType.Default<font></font>
  );<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Object pool</font></font><font></font>
  nodePoolBuffer = new ComputeBuffer(<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    count,</font></font></font></font><font></font>
    Marshal.SizeOf(typeof(int)),<font></font>
    ComputeBufferType.Append<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  );</font></font></font></font><font></font>
  nodePoolBuffer.SetCounterValue(0);<font></font>
</pre>
</div>

<h4><a id="h1-3-1-3"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Candidate (candidate for new Node)</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The structure of Candidate is defined as follows.</font></font></p>
<div class="emlist-code">
<p class="caption">Candidate.cs</p>
<pre class="emlist">public struct Candidate<font></font>
{<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public Vector3 position; // position</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public int node; // index of the original Node of the candidate point</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Candidate is represented by Append / ConsumeStructuredBuffer.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SpaceColonization.cs</font></font></font></font></p>
<pre class="emlist">    candidateBuffer = new ComputeBuffer(<font></font>
        count,<font></font>
        Marshal.SizeOf(typeof(Candidate)),<font></font>
        ComputeBufferType.Append<font></font>
    );<font></font>
    candidateBuffer.SetCounterValue(0);<font></font>
</pre>
</div>

<h4><a id="h1-3-1-4"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Edge (Edge that connects Nodes)</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The structure of Edge is defined as follows.</font></font></p>
<div class="emlist-code">
<p class="caption">Edge.cs</p>
<pre class="emlist">public struct Edge {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public int a, b; // index of two Nodes connected by Edge</font></font><font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Edge is represented by Append / Consume Structured Buffer like Candidate.</font></font></p>
<div class="emlist-code">
<p class="caption">SpaceColonization.cs</p>
<pre class="emlist">    edgeBuffer = new ComputeBuffer(<font></font>
        count * 2,<font></font>
        Marshal.SizeOf(typeof(Edge)),<font></font>
        ComputeBufferType.Append<font></font>
    );<font></font>
    edgeBuffer.SetCounterValue(0);<font></font>
</pre>
</div>

<h3><a id="h1-3-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implementing the algorithm in Compute Shader</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we have the necessary resources, we will implement each step of the algorithm in GPGPU with Compute Shader.</font></font></p>

<h4><a id="h1-3-2-1"></a>Setup</h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the initialization phase</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Node object pool initialization</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add initial Node as seed</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to hold.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pick up some from the prepared Attraction and generate an initial Node at that position.</font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SpaceColonization.cs</font></font></font></font></p>
<pre class="emlist">    var seeds = Enumerable.Range(0, seedCount).Select((_) =&gt; {<font></font>
        return attractions[Random.Range(0, count)].position;<font></font>
    }).ToArray();<font></font>
    Setup(seeds);<font></font>
</pre>
</div>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SpaceColonization.cs</font></font></font></font></p>
<pre class="emlist">protected void Setup(Vector3[] seeds)<font></font>
{<font></font>
    var kernel = compute.FindKernel("Setup");<font></font>
    compute.SetBuffer(kernel, "_NodesPoolAppend", nodePoolBuffer);<font></font>
    compute.SetBuffer(kernel, "_Nodes", nodeBuffer);<font></font>
    GPUHelper.Dispatch1D(compute, kernel, count);<font></font>
<font></font>
    ...<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Setup kernel initializes the object pool. </font><font style="vertical-align: inherit;">Store the index in the Node's object pool and turn off the active flag for that Node.</font></font></p>
<div class="emlist-code">
<p class="caption">SpaceColonization.compute</p>
<pre class="emlist">void Setup (uint3 id : SV_DispatchThreadID)<font></font>
{<font></font>
  uint idx = id.x;<font></font>
  uint count, stride;<font></font>
  _Nodes.GetDimensions(count, stride);<font></font>
  if (idx &gt;= count)<font></font>
    return;<font></font>
<font></font>
  _NodesPoolAppend.Append(idx);<font></font>
<font></font>
  Node n = _Nodes[idx];<font></font>
  n.active = false;<font></font>
  _Nodes[idx] = n;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This will turn off the active flags for all Nodes and create an object pool with Node indexes.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that the object pool has been initialized, it's time to create the initial seed node.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The initial node is generated by executing the Seed kernel with the seed position (Vector3 []) prepared earlier as input.</font></font></p>
<div class="emlist-code">
<p class="caption">SpaceColonization.cs</p>
<pre class="emlist">...<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// seedBuffer is automatically disposed when it goes out of scope</font></font><font></font>
using(<font></font>
    ComputeBuffer seedBuffer = new ComputeBuffer(<font></font>
        seeds.Length,<font></font>
        Marshal.SizeOf(typeof(Vector3))<font></font>
    )<font></font>
)<font></font>
{<font></font>
    seedBuffer.SetData(seeds);<font></font>
    kernel = compute.FindKernel("Seed");<font></font>
    compute.SetFloat("_MassMin", massMin);<font></font>
    compute.SetFloat("_MassMax", massMax);<font></font>
    compute.SetBuffer(kernel, "_Seeds", seedBuffer);<font></font>
    compute.SetBuffer(kernel, "_NodesPoolConsume", nodePoolBuffer);<font></font>
    compute.SetBuffer(kernel, "_Nodes", nodeBuffer);<font></font>
    GPUHelper.Dispatch1D(compute, kernel, seedBuffer.count);<font></font>
}<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Initialize the number of Nodes and Edges</font></font><font></font>
nodesCount = nodePoolBuffer.count;<font></font>
edgesCount = 0;<font></font>
<font></font>
...<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Seed kernel takes a position from the Seeds buffer and creates a Node at that position.</font></font></p>
<div class="emlist-code">
<p class="caption">SpaceColonization.compute</p>
<pre class="emlist">void Seed (uint3 id : SV_DispatchThreadID)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{</font></font></font></font><font></font>
  uint idx = id.x;<font></font>
<font></font>
  uint count, stride;<font></font>
  _Seeds.GetDimensions(count, stride);<font></font>
  if (idx &gt;= count)<font></font>
    return;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  Node n;</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Create a new Node (see below)</font></font><font></font>
  uint i = CreateNode(n);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Set Seed position to Node position</font></font><font></font>
  n.position = _Seeds[idx];<font></font>
  n.t = 1;<font></font>
  n.offset = 0;<font></font>
  n.from = -1;<font></font>
  n.mass = lerp(_MassMin, _MassMax, nrand(id.xy));<font></font>
  _Nodes[i] = n;<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create a new Node with the CreateNode function. </font><font style="vertical-align: inherit;">Extracts the index from the object pool ConsumeStructuredBuffer and returns the initialized Node.</font></font></p>
<div class="emlist-code">
<p class="caption">SpaceColonization.compute</p>
<pre class="emlist">uint CreateNode(out Node node)<font></font>
{<font></font>
  uint i = _NodesPoolConsume.Consume();<font></font>
  node.position = float3(0, 0, 0);<font></font>
  node.t = 0;<font></font>
  node.offset = 0;<font></font>
  node.from = -1;<font></font>
  node.mass = 0;<font></font>
  node.active = true;<font></font>
  return i;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the end of the initialization phase.</font></font></p>
<p><span class="imgref"><a href="https://freder.io/files/unity4/nakamura.html#id_nakamura_2FFlow"><font style="vertical-align: inherit;"></font></a></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each step of the looping algorithm shown in</font><span class="imgref"><a href="https://freder.io/files/unity4/nakamura.html#id_nakamura_2FFlow"><font style="vertical-align: inherit;"> Figure 1.8</font></a></span><font style="vertical-align: inherit;"> is performed within the Step function.</font></font></p>
<div class="emlist-code">
<p class="caption">SpaceColonization.cs</p>
<pre class="emlist">protected void Step(float dt)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Do not run when the object pool is empty</font></font><font></font>
    if (nodesCount &gt; 0)<font></font>
    {<font></font>
        Search();   // Step.2<font></font>
        Attract();  // Step.3<font></font>
        Connect();  // Step.4<font></font>
        Remove();   // Step.5<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Get the number of data that Append / ConsumeStructuredBuffer has</font></font><font></font>
        CopyNodesCount();<font></font>
        CopyEdgesCount();<font></font>
    }<font></font>
    Grow(dt);       // Step.6<font></font>
}<font></font>
<font></font>
</pre>
</div>

<h4><a id="h1-3-2-2"></a>Search</h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From each attraction, find the closest Node within the influence distance.</font></font></p>
<div class="emlist-code">
<p class="caption">SpaceColonization.cs</p>
<pre class="emlist">protected void Search()<font></font>
{<font></font>
    var kernel = compute.FindKernel("Search");<font></font>
    compute.SetBuffer(kernel, "_Attractions", attractionBuffer);<font></font>
    compute.SetBuffer(kernel, "_Nodes", nodeBuffer);<font></font>
    compute.SetFloat("_InfluenceDistance", unitDistance * influenceDistance);<font></font>
    GPUHelper.Dispatch1D(compute, kernel, count);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The GPU kernel implementation is as follows.</font></font></p>
<div class="emlist-code">
<p class="caption">SpaceColonization.compute</p>
<pre class="emlist">void Search (uint3 id : SV_DispatchThreadID)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{</font></font></font></font><font></font>
  uint idx = id.x;<font></font>
  uint count, stride;<font></font>
  _Attractions.GetDimensions(count, stride);<font></font>
  if (idx &gt;= count)<font></font>
    return;<font></font>
<font></font>
  Attraction attr = _Attractions[idx];<font></font>
<font></font>
  attr.found = false;<font></font>
  if (attr.active)<font></font>
  {<font></font>
    _Nodes.GetDimensions(count, stride);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Search for Nodes closer than influence distance</font></font><font></font>
    float min_dist = _InfluenceDistance;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // index of the nearest Node</font></font><font></font>
    uint nearest = -1;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Execute a loop for all Nodes</font></font><font></font>
    for (uint i = 0; i &lt; count; i++)<font></font>
    {<font></font>
      Node n = _Nodes[i];<font></font>
<font></font>
      if (n.active)<font></font>
      {<font></font>
        float3 dir = attr.position - n.position;<font></font>
        float d = length(dir);<font></font>
        if (d &lt; min_dist)<font></font>
        {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
          // Update the nearest Node</font></font><font></font>
          min_dist = d;<font></font>
          nearest = i;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
          // Set the index of the neighboring Node</font></font><font></font>
          attr.found = true;<font></font>
          attr.nearest = nearest;<font></font>
        }<font></font>
      }<font></font>
    }<font></font>
<font></font>
    _Attractions[idx] = attr;<font></font>
  }<font></font>
}<font></font>
</pre>
</div>

<h4><a id="h1-3-2-3"></a>Attract</h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For each Node, determine the direction to extend the branch based on the attraction within the range of influence, and the point beyond the extension by the growth distance is the candidate point (Candidate) for the point to generate a new Node. )will do.</font></font></font></font></p>
<div class="emlist-code">
<p class="caption">SpaceColonization.cs</p>
<pre class="emlist">protected void Attract()<font></font>
{<font></font>
    var kernel = compute.FindKernel("Attract");<font></font>
    compute.SetBuffer(kernel, "_Attractions", attractionBuffer);<font></font>
    compute.SetBuffer(kernel, "_Nodes", nodeBuffer);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    candidateBuffer.SetCounterValue (0); // Initialize the buffer that stores the candidate points</font></font><font></font>
    compute.SetBuffer(kernel, "_CandidatesAppend", candidateBuffer);<font></font>
<font></font>
    compute.SetFloat("_GrowthDistance", unitDistance * growthDistance);<font></font>
<font></font>
    GPUHelper.Dispatch1D(compute, kernel, count);<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The GPU kernel implementation is as follows. </font><font style="vertical-align: inherit;">Please refer to the code contents and comments of the Attract kernel for the calculation method of the position of the candidate point.</font></font></p>
<div class="emlist-code">
<p class="caption">SpaceColonization.compute</p>
<pre class="emlist">void Attract (uint3 id : SV_DispatchThreadID)<font></font>
{<font></font>
  uint idx = id.x;<font></font>
  uint count, stride;<font></font>
  _Nodes.GetDimensions(count, stride);<font></font>
  if (idx &gt;= count)<font></font>
    return;<font></font>
<font></font>
  Node n = _Nodes[idx];<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Node is valid and</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Create a new Node if the growth rate (t) is greater than or equal to the threshold (1.0)</font></font><font></font>
  if (n.active &amp;&amp; n.t &gt;= 1.0)<font></font>
  {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Accumulation variable to extend the branch</font></font><font></font>
    float3 dir = (0.0).xxx;<font></font>
    uint counter = 0;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Run a loop for all attractions</font></font><font></font>
    _Attractions.GetDimensions(count, stride);<font></font>
    for (uint i = 0; i &lt; count; i++)<font></font>
    {<font></font>
      Attraction attr = _Attractions[i];<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      // Search for the attraction whose node is the nearest neighbor</font></font><font></font>
      if (attr.active &amp;&amp; attr.found &amp;&amp; attr.nearest == idx)<font></font>
      {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Normalize the vector from Node to Attraction and add it to the accumulation variable</font></font><font></font>
        float3 dir2 = (attr.position - n.position);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        dir + = normalize (dir2);</font></font></font></font><font></font>
        counter++;<font></font>
      }<font></font>
    }<font></font>
<font></font>
    if (counter &gt; 0)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    {</font></font></font></font><font></font>
      Candidate c;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      // Take the average of the unit vectors from Node to Attraction</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      // Set it as the position of the candidate point extended from the Node by the growth distance</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      dir = dir / counter;</font></font></font></font><font></font>
      c.position = n.position + (dir * _GrowthDistance);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      // Set the index of the original Node that extends to the candidate point</font></font><font></font>
      c.node = idx;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      // Add to candidate point buffer</font></font><font></font>
      _CandidatesAppend.Append(c);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    }</font></font></font></font><font></font>
  }<font></font>
}<font></font>
</pre>
</div>

<h4><a id="h1-3-2-4"></a>Connect</h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create a new Node based on the candidate point buffer generated by the Attract kernel, and extend the branch by connecting the Nodes with Edge.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the Connect function, the number of kernel executions is determined by comparing the remaining number of object pools (nodesCount) with the size of the candidate point buffer so that data retrieval (Consume) is not executed when the Node object pool (nodePoolBuffer) is empty. I am.</font></font></p>
<div class="emlist-code">
<p class="caption">SpaceColonization.cs</p>
<pre class="emlist">protected void Connect()<font></font>
{<font></font>
    var kernel = compute.FindKernel("Connect");<font></font>
    compute.SetFloat("_MassMin", massMin);<font></font>
    compute.SetFloat("_MassMax", massMax);<font></font>
    compute.SetBuffer(kernel, "_Nodes", nodeBuffer);<font></font>
    compute.SetBuffer(kernel, "_NodesPoolConsume", nodePoolBuffer);<font></font>
    compute.SetBuffer(kernel, "_EdgesAppend", edgeBuffer);<font></font>
    compute.SetBuffer(kernel, "_CandidatesConsume", candidateBuffer);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // The number of data (nodeCount) of the Node object pool acquired by CopyNodeCount</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Restrict so that it does not exceed</font></font><font></font>
    var connectCount = Mathf.Min(nodesCount, CopyCount(candidateBuffer));<font></font>
    if (connectCount &gt; 0)<font></font>
    {<font></font>
        compute.SetInt("_ConnectCount", connectCount);<font></font>
        GPUHelper.Dispatch1D(compute, kernel, connectCount);<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below is the implementation of the GPU kernel.</font></font></p>
<div class="emlist-code">
<p class="caption">SpaceColonization.compute</p>
<pre class="emlist">void Connect (uint3 id : SV_DispatchThreadID)<font></font>
{<font></font>
  uint idx = id.x;<font></font>
  if (idx &gt;= _ConnectCount)<font></font>
    return;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Extract candidate points from the candidate point buffer</font></font><font></font>
  Candidate c = _CandidatesConsume.Consume();<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  Node n1 = _Nodes [c.node];</font></font></font></font><font></font>
  Node n2;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Generate Node at the position of the candidate point</font></font><font></font>
  uint idx2 = CreateNode(n2);<font></font>
  n2.position = c.position;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  n2.offset = n1.offset + 1.0; // Set the distance from Root (original Node + 1.0)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  n2.from = c.node; // Set the index of the original Node</font></font><font></font>
  n2.mass = lerp(_MassMin, _MassMax, nrand(float2(c.node, idx2)));<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Update Node buffer</font></font><font></font>
  _Nodes[c.node] = n1;<font></font>
  _Nodes[idx2] = n2;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Connect two Nodes with Edge (see below)</font></font><font></font>
  CreateEdge(c.node, idx2);<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The CreateEdge function creates an Edge based on the indexes of the two Nodes passed and adds it to the Edge buffer.</font></font></p>
<div class="emlist-code">
<p class="caption">SpaceColonization.compute</p>
<pre class="emlist">void CreateEdge(int a, int b)<font></font>
{<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  Edge e;</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  ea = a;</font></font></font></font><font></font>
  e.b = b;<font></font>
  _EdgesAppend.Append(e);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
</pre>
</div>

<h4><a id="h1-3-2-5"></a>Remove</h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remove the Attraction that is within the kill distance from the Node.</font></font></p>
<div class="emlist-code">
<p class="caption">SpaceColonization.cs</p>
<pre class="emlist">protected void Remove()<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{</font></font></font></font><font></font>
    var kernel = compute.FindKernel("Remove");<font></font>
    compute.SetBuffer(kernel, "_Attractions", attractionBuffer);<font></font>
    compute.SetBuffer(kernel, "_Nodes", nodeBuffer);<font></font>
    compute.SetFloat("_KillDistance", unitDistance * killDistance);<font></font>
    GPUHelper.Dispatch1D(compute, kernel, count);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The GPU kernel implementation is as follows.</font></font></font></font></p>
<div class="emlist-code">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SpaceColonization.compute</font></font></font></font></p>
<pre class="emlist">void Remove(uint3 id : SV_DispatchThreadID)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{</font></font></font></font><font></font>
  uint idx = id.x;<font></font>
  uint count, stride;<font></font>
  _Attractions.GetDimensions(count, stride);<font></font>
  if (idx &gt;= count)<font></font>
    return;<font></font>
<font></font>
  Attraction attr = _Attractions[idx];<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Do not execute if the attraction has been deleted</font></font><font></font>
  if (!attr.active)<font></font>
    return;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Execute a loop for all Nodes</font></font><font></font>
  _Nodes.GetDimensions(count, stride);<font></font>
  for (uint i = 0; i &lt; count; i++)<font></font>
  {<font></font>
    Node n = _Nodes[i];<font></font>
    if (n.active)<font></font>
    {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      // If there is a Node within the deletion range, turn off the active flag of Attraction and delete it</font></font><font></font>
      float d = distance(attr.position, n.position);<font></font>
      if (d &lt; _KillDistance)<font></font>
      {<font></font>
        attr.active = false;<font></font>
        _Attractions[idx] = attr;<font></font>
        return;<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
}<font></font>
</pre>
</div>

<h4><a id="h1-3-2-6"></a>Grow</h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grow Node.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When generating candidate points with the Attract kernel, it is used as a condition whether the growth rate (t) of Node is above the threshold value (if it is below the threshold value, no candidate points are generated), but the growth rate parameter is in this Grow kernel. I'm incrementing.</font></font></p>
<div class="emlist-code">
<p class="caption">SpaceColonization.cs</p>
<pre class="emlist">protected void Grow(float dt)<font></font>
{<font></font>
    var kernel = compute.FindKernel("Grow");<font></font>
    compute.SetBuffer(kernel, "_Nodes", nodeBuffer);<font></font>
<font></font>
    var delta = dt * growthSpeed;<font></font>
    compute.SetFloat("_DT", delta);<font></font>
<font></font>
    GPUHelper.Dispatch1D(compute, kernel, count);<font></font>
}<font></font>
</pre>
</div>
<div class="emlist-code">
<p class="caption">SpaceColonization.compute</p>
<pre class="emlist">void Grow (uint3 id : SV_DispatchThreadID)<font></font>
{<font></font>
  uint idx = id.x;<font></font>
  uint count, stride;<font></font>
  _Nodes.GetDimensions(count, stride);<font></font>
  if (idx &gt;= count)<font></font>
    return;<font></font>
<font></font>
  Node n = _Nodes[idx];<font></font>
<font></font>
  if (n.active)<font></font>
  {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Disperse the growth rate with the mass parameter randomly set for each Node</font></font><font></font>
    n.t = saturate(n.t + _DT * n.mass);<font></font>
    _Nodes[idx] = n;<font></font>
  }<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
</pre>
</div>

<h3><a id="h1-3-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rendering</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we have a blanched shape with the above implementation, let's talk about how to render that shape.</font></font></p>

<h4><a id="h1-3-3-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering with Line Topology</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, simply render using Line Mesh.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generate a simple Line Topology Mesh to draw a Line that represents a single Edge.</font></font></p>
<div class="emlist-code">
<p class="caption">SpaceColonization.cs</p>
<pre class="emlist">protected Mesh BuildSegment()<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    var mesh = new Mesh ();</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    mesh.hideFlags = HideFlags.DontSave;</font></font></font></font><font></font>
    mesh.vertices = new Vector3[2] { Vector3.zero, Vector3.up };<font></font>
    mesh.uv = new Vector2[2] { new Vector2(0f, 0f), new Vector2(0f, 1f) };<font></font>
    mesh.SetIndices(new int[2] { 0, 1 }, MeshTopology.Lines, 0);<font></font>
    return mesh;<font></font>
}<font></font>
</pre>
</div>
<div id="id_nakamura_2FSegment" class="image">
<img src="./Chapter 1 _ GPU-Based Space Colonization Algorithm_files/Segment.png" alt="Line Topology Mesh with only two simple vertices">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.9: Line Topology Mesh with only two simple vertices
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Display the branches generated by rendering a Segment (line segment) with only two vertices using GPU instancing for the number of Edges.</font></font></p>
<div class="emlist-code">
<p class="caption">SpaceColonization.cs</p>
<pre class="emlist"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Generate a buffer that determines the number of meshes to render, required for GPU instancing</font></font><font></font>
protected void SetupDrawArgumentsBuffers(int count)<font></font>
{<font></font>
    if (drawArgs[1] == (uint)count) return;<font></font>
<font></font>
    drawArgs[0] = segment.GetIndexCount(0);<font></font>
    drawArgs[1] = (uint)count;<font></font>
<font></font>
    if (drawBuffer != null) drawBuffer.Dispose();<font></font>
    drawBuffer = new ComputeBuffer(<font></font>
        1,<font></font>
        sizeof(uint) * drawArgs.Length,<font></font>
        ComputeBufferType.IndirectArguments<font></font>
    );<font></font>
    drawBuffer.SetData(drawArgs);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
<font></font>
...<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Perform rendering with GPU instancing</font></font><font></font>
protected void Render(float extents = 100f)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{</font></font></font></font><font></font>
    block.SetBuffer("_Nodes", nodeBuffer);<font></font>
    block.SetBuffer("_Edges", edgeBuffer);<font></font>
    block.SetInt("_EdgesCount", edgesCount);<font></font>
    block.SetMatrix("_World2Local", transform.worldToLocalMatrix);<font></font>
    block.SetMatrix("_Local2World", transform.localToWorldMatrix);<font></font>
    Graphics.DrawMeshInstancedIndirect(<font></font>
        segment, 0,<font></font>
        material, new Bounds(Vector3.zero, Vector3.one * extents),<font></font>
        drawBuffer, 0, block<font></font>
    );<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The shader for rendering (Edge.shader) generates an animation of the branch extending from the branch point by controlling the length of the Edge according to the growth rate parameter (t) of the Node.</font></font></p>
<div class="emlist-code">
<p class="caption">Edge.shader</p>
<pre class="emlist">v2f vert(appdata IN, uint iid : SV_InstanceID)<font></font>
{<font></font>
  v2f OUT;<font></font>
  UNITY_SETUP_INSTANCE_ID(IN);<font></font>
  UNITY_TRANSFER_INSTANCE_ID(IN, OUT);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Get the corresponding Edge from the instance ID</font></font><font></font>
  Edge e = _Edges[iid];<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Get 2 Nodes from the index of Edge</font></font><font></font>
  Node a = _Nodes[e.a];<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  Node b = _Nodes [eb];</font></font><font></font>
<font></font>
  float3 ap = a.position;<font></font>
  float3 bp = b.position;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  float3 dir = bp - ap;</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Determine the length of Edge from a to b according to the growth rate (t) of Node b</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  bp = ap + normalize (dir) * length (dir) * bt;</font></font></font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Since the vertex ID (IN.vid) is 0 or 1, if it is 0, it refers to the node of a, and if it is 1, it refers to the position of Node of b.</font></font><font></font>
  float3 position = lerp(ap, bp, IN.vid);<font></font>
<font></font>
  float4 vertex = float4(position, 1);<font></font>
  OUT.position = UnityObjectToClipPos(vertex);<font></font>
  OUT.uv = IN.uv;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // If Node is inactive or the instance ID is outside the total number of Edges, set alpha to 0 and do not draw</font></font><font></font>
  OUT.alpha = (a.active &amp;&amp; b.active) &amp;&amp; (iid &lt; _EdgesCount);<font></font>
<font></font>
  return OUT;<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With these implementations, the shape obtained by the Space Colonization Algorithm can be rendered using Line Topology. </font><font style="vertical-align: inherit;">You can get the following picture by executing Line.scene.</font></font></p>
<div id="id_nakamura_2FLineScene" class="image">
<img src="./Chapter 1 _ GPU-Based Space Colonization Algorithm_files/LineScene.png" alt="Line.scene --Example of rendering by Edge.shader">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.10: Line.scene --Example of rendering with Edge.shader
</font></font></p>
</div>

<h4><a id="h1-3-3-2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering with Geometry Shader</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By converting the Line Topology Segment to a Capsule shape with the Geometry Shader, you can draw thick lines.</font></font></p>
<div id="id_nakamura_2FSegmentToCapsule" class="image">
<img src="./Chapter 1 _ GPU-Based Space Colonization Algorithm_files/SegmentToCapsule.png" alt="Convert Line Topology Segment to Capsule shape with Geometry Shader">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.11: Convert Line Topology Segment to Capsule shape with Geometry Shader
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The vertex shader is almost the same as Edge.shader, and Geometry Shader builds the Capsule shape. </font><font style="vertical-align: inherit;">Only the important Geometry Shader implementations are listed below.</font></font></p>
<div class="emlist-code">
<p class="caption">TubularEdge.shader</p>
<pre class="emlist">...<font></font>
[maxvertexcount(64)]<font></font>
void geom(line v2g IN[2], inout TriangleStream&lt;g2f&gt; OUT) {<font></font>
  v2g p0 = IN[0];<font></font>
  v2g p1 = IN[1];<font></font>
<font></font>
  float alpha = p0.alpha;<font></font>
<font></font>
  float3 t = normalize(p1.position - p0.position);<font></font>
  float3 n = normalize(p0.viewDir);<font></font>
  float3 bn = cross(t, n);<font></font>
  n = cross(t, bn);<font></font>
<font></font>
  float3 tp = lerp(p0.position, p1.position, alpha);<font></font>
  float thickness = _Thickness * alpha;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Definition of Capsule mesh resolution</font></font><font></font>
  static const uint rows = 6, cols = 6;<font></font>
  static const float rows_inv = 1.0 / rows, cols_inv = 1.0 / (cols - 1);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  g2f00, o1;</font></font><font></font>
  o0.uv = p0.uv; o0.uv2 = p0.uv2;<font></font>
  o1.uv = p1.uv; o1.uv2 = p1.uv2;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Build aspects of the Capsule</font></font><font></font>
  for (uint i = 0; i &lt; cols; i++) {<font></font>
    float r = (i * cols_inv) * UNITY_TWO_PI;<font></font>
<font></font>
    float s, c;<font></font>
    sincos(r, s, c);<font></font>
    float3 normal = normalize(n * c + bn * s);<font></font>
<font></font>
    float3 w0 = p0.position + normal * thickness;<font></font>
    float3 w1 = p1.position + normal * thickness;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    o0.normal = o1.normal = normal;</font></font></font></font><font></font>
<font></font>
    o0.position = UnityWorldToClipPos(w0);<font></font>
    OUT.Append(o0);<font></font>
<font></font>
    o1.position = UnityWorldToClipPos(w1);<font></font>
    OUT.Append(o1);<font></font>
  }<font></font>
  OUT.RestartStrip();<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Construction of Capsule tip (hemispherical)</font></font><font></font>
  uint row, col;<font></font>
  for (row = 0; row &lt; rows; row++)<font></font>
  {<font></font>
    float s0 = sin((row * rows_inv) * UNITY_HALF_PI);<font></font>
    float s1 = sin(((row + 1) * rows_inv) * UNITY_HALF_PI);<font></font>
    for (col = 0; col &lt; cols; col++)<font></font>
    {<font></font>
      float r = (col * cols_inv) * UNITY_TWO_PI;<font></font>
<font></font>
      float s, c;<font></font>
      sincos(r, s, c);<font></font>
<font></font>
      float3 n0 = normalize(n * c * (1.0 - s0) + bn * s * (1.0 - s0) + t * s0);<font></font>
      float3 n1 = normalize(n * c * (1.0 - s1) + bn * s * (1.0 - s1) + t * s1);<font></font>
<font></font>
      o0.position = UnityWorldToClipPos(float4(tp + n0 * thickness, 1));<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      o0.normal = n0;</font></font></font></font><font></font>
      OUT.Append(o0);<font></font>
<font></font>
      o1.position = UnityWorldToClipPos(float4(tp + n1 * thickness, 1));<font></font>
      o1.normal = n1;<font></font>
      OUT.Append(o1);<font></font>
    }<font></font>
    OUT.RestartStrip();<font></font>
  }<font></font>
}<font></font>
<font></font>
...<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result looks like this: </font><font style="vertical-align: inherit;">(TubularEdge.scene)</font></font></p>
<div id="id_nakamura_2FTubularEdgeScene" class="image">
<img src="./Chapter 1 _ GPU-Based Space Colonization Algorithm_files/TubularEdgeScene.jpg" alt="TubularEdge.scene --Example of rendering by TubularEdge.shader">
<p class="caption"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1.12: TubularEdge.scene --Example of rendering with TubularEdge.shader
</font></font></p>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that you can render Edge with a thick mesh, you can add lighting and so on.</font></font></p>

<h2><a id="h1-4"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.4　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Application</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With the above, we have realized the GPU implementation of Space Colonization. </font><font style="vertical-align: inherit;">In this section, we will introduce the cooperation with skinning animation as an application example.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With this application, it is possible to realize an expression that blanchs along the animated model shape.</font></font></p>

<h3><a id="h1-4-1"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.4.1　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rough flow</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The cooperation with skinning animation is developed according to the following flow.</font></font></p>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prepare an animation model</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prepare a point cloud that fills the volume of the model (point cloud that becomes an attraction)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Give Attraction and Node Bone information</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apply (skinning) Bone transformation to Node to change its position</font></font></li>
</ol>

<h3><a id="h1-4-2"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.4.2　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Preparation of resources</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The structure of the previous example</font></font></p>
<ul>
<li>Attraction</li>
<li>Node</li>
<li>Candidate</li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Make changes to have the Bone index.</font></font></p>
<div class="column">

<h3><a id="column-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">About Bone Limits Affected</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this application, the number of bones that affect each node is limited to one. </font><font style="vertical-align: inherit;">Originally, skinning animation could have multiple bones affecting each vertex, but in this example we simply limit it to only one.</font></font></p>
</div>
<div class="emlist-code">
<p class="caption">SkinnedAttraction.cs</p>
<pre class="emlist">public struct SkinnedAttraction {<font></font>
    public Vector3 position;<font></font>
    public int bone; // boneのindex<font></font>
    public int nearest;<font></font>
    public uint found;<font></font>
    public uint active;<font></font>
}<font></font>
</pre>
</div>
<div class="emlist-code">
<p class="caption">SkinnedNode.cs</p>
<pre class="emlist">public struct SkinnedNode {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public Vector3 position;</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public Vector3 animated; // Node position after skinning animation</font></font><font></font>
    public int index0; // boneのindex<font></font>
    public float t;<font></font>
    public float offset;<font></font>
    public float mass;<font></font>
    public int from;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public uint active;</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
</pre>
</div>
<div class="emlist-code">
<p class="caption">SkinnedCandidate.cs</p>
<pre class="emlist">public struct SkinnedCandidate<font></font>
{<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public Vector3 position;</font></font></font></font><font></font>
    public int node;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    public int bone; // boneのindex</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
</pre>
</div>

<h4><a id="h1-4-2-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animation model and volume</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prepare the animation model you want to link.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this example, </font><font style="vertical-align: inherit;">the model downloaded from </font><font style="vertical-align: inherit;">Clara.io </font></font><a id="fnb-Clara" href="https://freder.io/files/unity4/nakamura.html#fn-Clara" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is used (the </font><font style="vertical-align: inherit;">number of polygons is reduced by reduction with </font><font style="vertical-align: inherit;">MeshLab </font></font><a id="fnb-MeshLab" href="https://freder.io/files/unity4/nakamura.html#fn-MeshLab" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), and the animation is </font><font style="vertical-align: inherit;">generated by </font><font style="vertical-align: inherit;">mixamo </font></font><a id="fnb-mixamo" href="https://freder.io/files/unity4/nakamura.html#fn-mixamo" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p>
<div class="footnote" epub:type="footnote" id="fn-Clara"><p class="footnote">[*2] https://clara.io/view/d49ee603-8e6c-4720-bd20-9e3d7b13978a</p></div>
<div class="footnote" epub:type="footnote" id="fn-MeshLab"><p class="footnote">[*3] http://www.meshlab.net/</p></div>
<div class="footnote" epub:type="footnote" id="fn-mixamo"><p class="footnote">[*4] https://mixamo.com</p></div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to get the position of Attraction from the model volume, </font><font style="vertical-align: inherit;">we use a package called </font><font style="vertical-align: inherit;">VolumeSampler </font></font><a id="fnb-VolumeSampler" href="https://freder.io/files/unity4/nakamura.html#fn-VolumeSampler" class="noteref" epub:type="noteref"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that </font><font style="vertical-align: inherit;">generates a point cloud in the model volume </font><font style="vertical-align: inherit;">.</font></font></p>
<div class="footnote" epub:type="footnote" id="fn-VolumeSampler"><p class="footnote">[*5] https://github.com/mattatz/unity-volume-sampler</p></div>
<div class="column">

<h3><a id="column-2"></a>VolumeSampler</h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VolumeSampler acquires the volume of the model using the technique explained in Unity Graphics Programming vol.2 "Real-Time GPU-Based Voxelizer". </font><font style="vertical-align: inherit;">First, the volume inside the mesh is acquired as Voxel, and Poisson Disk Sampling is executed based on it to generate a point cloud that fills the inside of the mesh.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To generate a point cloud asset using VolumeSampler, click Window → VolumeSampler from the Unity toolbar to display Window, and as shown in the figure below.</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reference to the target mesh</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Point cloud sampling resolution</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you set and click the asset generation button, the Volume asset will be generated in the specified path.</font></font></p>
<div id="id_nakamura_2FVolumeSamplerWindow" class="image">
<img src="./Chapter 1 _ GPU-Based Space Colonization Algorithm_files/VolumeSamplerWindow.png" alt="VolumeSamplerWindow">
<p class="caption">
図1.13: VolumeSamplerWindow
</p>
</div>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generate a SkinnedAttraction array from the point cloud asset (Volume class) generated from VolumeSampler and apply it to ComputeBuffer.</font></font></p>
<div class="emlist-code">
<p class="caption">SkinnedSpaceColonization.cs</p>
<pre class="emlist">protected void Start() {<font></font>
    ...<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Generate a Skinned Attraction array from the point cloud of Volume</font></font><font></font>
    attractions = GenerateAttractions(volume);<font></font>
    count = attractions.Length;<font></font>
    attractionBuffer = new ComputeBuffer(<font></font>
        count,<font></font>
        Marshal.SizeOf(typeof(SkinnedAttraction)),<font></font>
        ComputeBufferType.Default<font></font>
    );<font></font>
    attractionBuffer.SetData(attractions);<font></font>
    ...<font></font>
}<font></font>
</pre>
</div>

<h4><a id="h1-4-2-2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Applying Bone information</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bone information of the nearest vertex from each position is applied to Skinned Attraction generated from the volume of Mesh.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The SetupSkin function prepares the vertices of the mesh and the bone buffer, and assigns the bone index to all Skinned Attraction on the GPU.</font></font></p>
<div class="emlist-code">
<p class="caption">SkinnedSpaceColonization.cs</p>
<pre class="emlist">protected void Start() {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    ...</font></font></font></font><font></font>
    SetupSkin();<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    ...</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
<font></font>
...<font></font>
<font></font>
protected void SetupSkin()<font></font>
{<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    var mesh = skinnedRenderer.sharedMesh;</font></font></font></font><font></font>
    var vertices = mesh.vertices;<font></font>
    var weights = mesh.boneWeights;<font></font>
    var indices = new int[weights.Length];<font></font>
    for(int i = 0, n = weights.Length; i &lt; n; i++)<font></font>
        indices[i] = weights[i].boneIndex0;<font></font>
<font></font>
    using (<font></font>
        ComputeBuffer<font></font>
        vertBuffer = new ComputeBuffer(<font></font>
            vertices.Length,<font></font>
            Marshal.SizeOf(typeof(Vector3))<font></font>
        ),<font></font>
        boneBuffer = new ComputeBuffer(<font></font>
            weights.Length,<font></font>
            Marshal.SizeOf(typeof(uint))<font></font>
        )<font></font>
    )<font></font>
    {<font></font>
        vertBuffer.SetData(vertices);<font></font>
        boneBuffer.SetData(indices);<font></font>
<font></font>
        var kernel = compute.FindKernel("SetupSkin");<font></font>
        compute.SetBuffer(kernel, "_Vertices", vertBuffer);<font></font>
        compute.SetBuffer(kernel, "_Bones", boneBuffer);<font></font>
        compute.SetBuffer(kernel, "_Attractions", attractionBuffer);<font></font>
        GPUHelper.Dispatch1D(compute, kernel, attractionBuffer.count);<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below is the implementation of the GPU kernel.</font></font></font></font></p>
<div class="emlist-code">
<p class="caption">SkinnedSpaceColonization.compute</p>
<pre class="emlist">void SetupSkin (uint3 id : SV_DispatchThreadID)<font></font>
{<font></font>
  uint idx = id.x;<font></font>
  uint count, stride;<font></font>
  _Attractions.GetDimensions(count, stride);<font></font>
  if (idx &gt;= count)<font></font>
    return;<font></font>
<font></font>
  SkinnedAttraction attr = _Attractions[idx];<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Get the index of the nearest vertex from the position of Skinned Attraction</font></font><font></font>
  float3 p = attr.position;<font></font>
  uint closest = -1;<font></font>
  float dist = 1e8;<font></font>
  _Vertices.GetDimensions(count, stride);<font></font>
  for (uint i = 0; i &lt; count; i++)<font></font>
  {<font></font>
    float3 v = _Vertices[i];<font></font>
    float l = distance(v, p);<font></font>
    if (l &lt; dist)<font></font>
    {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      dist = l;</font></font></font></font><font></font>
      closest = i;<font></font>
    }<font></font>
  }<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Set the bone index of the nearest vertex to Skinned Attraction</font></font><font></font>
  attr.bone = _Bones[closest];<font></font>
  _Attractions[idx] = attr;<font></font>
}<font></font>
</pre>
</div>

<h3><a id="h1-4-3"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.4.3　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implementation of algorithm in Compute Shader</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this application, some GPU kernels are modified to get the bone information needed for skinning animation in each step of the Space Colonization Algorithm.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The contents of the GPU kernel are almost the same, but for the generated SkinnedNode, it is necessary to obtain Bone information (Bone index) from the nearest Skinned Attraction, so</font></font></p>
<ul>
<li>Seed</li>
<li>Attract</li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the two GPU kernels, neighborhood search logic has been added.</font></font></p>
<div class="emlist-code">
<p class="caption">SkinnedSpaceColonization.compute</p>
<pre class="emlist">void Seed (uint3 id : SV_DispatchThreadID)<font></font>
{<font></font>
  uint idx = id.x;<font></font>
<font></font>
  uint count, stride;<font></font>
  _Seeds.GetDimensions(count, stride);<font></font>
  if (idx &gt;= count)<font></font>
    return;<font></font>
<font></font>
  SkinnedNode n;<font></font>
  uint i = CreateNode(n);<font></font>
  n.position = n.animated = _Seeds[idx];<font></font>
  n.t = 1;<font></font>
  n.offset = 0;<font></font>
  n.from = -1;<font></font>
  n.mass = lerp(_MassMin, _MassMax, nrand(id.xy));<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Search for the nearest Skinned Attraction and</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Copy the Bone index</font></font><font></font>
  uint nearest = -1;<font></font>
  float dist = 1e8;<font></font>
  _Attractions.GetDimensions(count, stride);<font></font>
  for (uint j = 0; j &lt; count; j++)<font></font>
  {<font></font>
    SkinnedAttraction attr = _Attractions[j];<font></font>
    float l = distance(attr.position, n.position);<font></font>
    if (l &lt; dist)<font></font>
    {<font></font>
      nearest = j;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      dist = l;</font></font></font></font><font></font>
    }<font></font>
  }<font></font>
  n.index0 = _Attractions[nearest].bone;<font></font>
<font></font>
  _Nodes[i] = n;<font></font>
}<font></font>
<font></font>
...<font></font>
<font></font>
void Attract (uint3 id : SV_DispatchThreadID)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  uint idx = id.x;</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  uint count, stride;</font></font></font></font><font></font>
  _Nodes.GetDimensions(count, stride);<font></font>
  if (idx &gt;= count)<font></font>
    return;<font></font>
<font></font>
  SkinnedNode n = _Nodes[idx];<font></font>
<font></font>
  if (n.active &amp;&amp; n.t &gt;= 1.0)<font></font>
  {<font></font>
    float3 dir = (0.0).xxx;<font></font>
    uint counter = 0;<font></font>
<font></font>
    float dist = 1e8;<font></font>
    uint nearest = -1;<font></font>
<font></font>
    _Attractions.GetDimensions(count, stride);<font></font>
    for (uint i = 0; i &lt; count; i++)<font></font>
    {<font></font>
      SkinnedAttraction attr = _Attractions[i];<font></font>
      if (attr.active &amp;&amp; attr.found &amp;&amp; attr.nearest == idx)<font></font>
      {<font></font>
        float3 dir2 = (attr.position - n.position);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        dir + = normalize (dir2);</font></font></font></font><font></font>
        counter++;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Search for the nearest Skinned Attraction</font></font><font></font>
        float l2 = length(dir2);<font></font>
        if (l2 &lt; dist)<font></font>
        {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
          dist = l2;</font></font></font></font><font></font>
          nearest = i;<font></font>
        }<font></font>
      }<font></font>
    }<font></font>
<font></font>
    if (counter &gt; 0)<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    {</font></font></font></font><font></font>
      SkinnedCandidate c;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      dir = dir / counter;</font></font></font></font><font></font>
      c.position = n.position + (dir * _GrowthDistance);<font></font>
      c.node = idx;<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      // Set the bone index of the nearest Skinned Attraction</font></font><font></font>
      c.bone = _Attractions[nearest].bone;<font></font>
      _CandidatesAppend.Append(c);<font></font>
    }<font></font>
  }<font></font>
}<font></font>
<font></font>
</pre>
</div>

<h4><a id="h1-4-3-1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skinning animation</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With the above implementation, you can now execute the Space Colonization Algorithm while setting the Bone information for Node.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After that, you can apply skinning animation to Node by getting the required Bone matrix from SkinnedMeshRenderer and moving the position of SkinnedNode on the GPU according to the deformation of Bone.</font></font></p>
<div class="emlist-code">
<p class="caption">SkinnedSpaceColonization.cs</p>
<pre class="emlist">protected void Start() {<font></font>
    ...<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Create a buffer for the bind pose matrix</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    var bindposes = skinnedRenderer.sharedMesh.bindposes;</font></font></font></font><font></font>
    bindPoseBuffer = new ComputeBuffer(<font></font>
        bindposes.Length,<font></font>
        Marshal.SizeOf(typeof(Matrix4x4))<font></font>
    );<font></font>
    bindPoseBuffer.SetData(bindposes);<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    ...</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></font></font><font></font>
<font></font>
protected void Animate()<font></font>
{<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Create a buffer representing the SkinnedMeshRenderer's Bone matrix that is updated as the animation plays</font></font><font></font>
    var bones = skinnedRenderer.bones.Select(bone =&gt; {<font></font>
        return bone.localToWorldMatrix;<font></font>
    }).ToArray();<font></font>
    using (<font></font>
        ComputeBuffer boneMatrixBuffer = new ComputeBuffer(<font></font>
            bones.Length,<font></font>
            Marshal.SizeOf(typeof(Matrix4x4))<font></font>
        )<font></font>
    )<font></font>
    {<font></font>
        boneMatrixBuffer.SetData(bones);<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        // Pass the Bone and Node buffers and perform GPU skinning</font></font><font></font>
        var kernel = compute.FindKernel("Animate");<font></font>
        compute.SetBuffer(kernel, "_BindPoses", bindPoseBuffer);<font></font>
        compute.SetBuffer(kernel, "_BoneMatrices", boneMatrixBuffer);<font></font>
        compute.SetBuffer(kernel, "_Nodes", nodeBuffer);<font></font>
        GPUHelper.Dispatch1D(compute, kernel, count);<font></font>
    }<font></font>
}<font></font>
</pre>
</div>
<div class="emlist-code">
<p class="caption">SkinnedSpaceColonization.compute</p>
<pre class="emlist">void Animate (uint3 id : SV_DispatchThreadID)<font></font>
{<font></font>
  uint idx = id.x;<font></font>
  uint count, stride;<font></font>
  _Nodes.GetDimensions(count, stride);<font></font>
  if (idx &gt;= count)<font></font>
    return;<font></font>
<font></font>
  SkinnedNode node = _Nodes[idx];<font></font>
  if (node.active)<font></font>
  {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    // Perform skinning</font></font><font></font>
    float4x4 bind = _BindPoses[node.index0];<font></font>
    float4x4 m = _BoneMatrices[node.index0];<font></font>
    node.animated = mul(mul(m, bind), float4(node.position, 1)).xyz;<font></font>
    _Nodes[idx] = node;<font></font>
  }<font></font>
}<font></font>
</pre>
</div>

<h3><a id="h1-4-4"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.4.4　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rendering</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The shaders for rendering are almost the same, except that the Edge is drawn by referring to the animated position after skinning animation, not the original position of the SkinnedNode.</font></font></p>
<div class="emlist-code">
<p class="caption">SkinnedTubularEdge.hlsl</p>
<pre class="emlist">v2g vert(appdata IN, uint iid : SV_InstanceID)<font></font>
{<font></font>
  ...<font></font>
  Edge e = _Edges[iid];<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  // Refer to the position after applying skinning animation</font></font><font></font>
  SkinnedNode a = _Nodes[e.a], b = _Nodes[e.b];<font></font>
  float3 ap = a.animated, bp = b.animated;<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  float3 dir = bp - ap;</font></font></font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  bp = ap + normalize (dir) * length (dir) * bt;</font></font></font></font><font></font>
  float3 position = lerp(ap, bp, IN.vid);<font></font>
  OUT.position = mul(unity_ObjectToWorld, float4(position, 1)).xyz;<font></font>
  ...<font></font>
}<font></font>
</pre>
</div>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With the above implementation, you can get the capture picture shown at the beginning. </font><font style="vertical-align: inherit;">( </font></font><span class="imgref"><a href="https://freder.io/files/unity4/nakamura.html#id_nakamura_2FSkinnedAnimationScene"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 1.1</font></font></a></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SkinnedAnimation.scene)</font></font></p>

<h2><a id="h1-5"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.5　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Summary</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this chapter, we introduced the GPU implementation of the Space Colonization Algorithm that generates a blanching shape along a point cloud, and an application example that combines it with skinning animation.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With this technique,</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attraction distance</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Growth distance</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The range to kill the attraction (kill distance)</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can control the density of branches with these three parameters, but you can generate more diverse models by changing these parameters locally or with time.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, in the sample, Attraction runs the algorithm only with what was generated during initialization, but you should be able to generate more different patterns by dynamically increasing Attraction.</font></font></p>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you are interested, try various applications of this algorithm to find interesting patterns.</font></font></p>

<h2><a id="h1-6"></a><span class="secno"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.6　</font></font></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reference</font></font></h2>
<ul>
<li>Modeling Trees with a Space Colonization Algorithm - http://algorithmicbotany.org/papers/colonization.egwnp2007.large.pdf</li>
<li>Algorithmic Design with Houdini - https://vimeo.com/305061631#t=1500s</li>
</ul></body></html>